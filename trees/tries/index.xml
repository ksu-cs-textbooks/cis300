<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tries :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/trees/tries/</link><description>Tries AVL trees give us an efficient mechanism for storage and retrieval, particularly if we need to be able to process the elements in order of their keys. However, there are special cases where we can achieve better performance. One of these special cases occurs when we need to store a list of words, as we might need in a word game, for example. For such applications, a trie provides for even more efficient storage and retrieval.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/trees/tries/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Tries</title><link>https://textbooks.cs.ksu.edu/cis300/trees/tries/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/tries/intro/</guid><description>Introduction to Tries A trie is a nonempty tree storing a set of words in the following way:
Each child of a node is labeled with a character. Each node contains a boolean indicating whether the labels in the path from the root to that node form a word in the set. The word, “trie”, is taken from the middle of the word, “retrieval”, but to avoid confusion, it is pronounced like “try” instead of like “tree”.</description></item><item><title>Multiple Implementations of Children</title><link>https://textbooks.cs.ksu.edu/cis300/trees/tries/multiple-impl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/tries/multiple-impl/</guid><description>Multiple Implementations of Children The trie implementation given in the previous section offers very efficient lookups - a word of length $ m $ can be looked up in $ O(m) $ time, no matter how many words are in the trie. However, it wastes a large amount of space. In a typical trie, a majority of the nodes will have no more than one child; however, each node contains a 26-element array to store its children.</description></item><item><title>Traversing a Trie</title><link>https://textbooks.cs.ksu.edu/cis300/trees/tries/traversing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/tries/traversing/</guid><description>Traversing a Trie As with other kinds of trees, there are occasions where we need to process all the elements stored in a trie in order. Here, the elements are strings, which are not stored explicitly in the trie, but implicitly based on the labels of various nodes. Thus, an individual node does not contain a string; however, if its bool has a value of true, then the path to that node describes a string stored in the trie.</description></item><item><title>Tries in Word Games</title><link>https://textbooks.cs.ksu.edu/cis300/trees/tries/word-games/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/tries/word-games/</guid><description>Tries in Word Games One application of tries is for implementing word games such as Boggle® or Scrabble®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.
A Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4 x 4 or 5 x 5 grid for holding these dice.</description></item></channel></rss>