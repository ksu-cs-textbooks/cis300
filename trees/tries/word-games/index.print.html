<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Tries in Word Games One application of tries is for implementing word games such as BoggleÂ® or ScrabbleÂ®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.
A Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4Â xÂ 4 or 5Â xÂ 5 grid for holding these dice. The face of each die contains a single letter, except that one face of one die contains â€œQuâ€. The tray has a large cover such that the dice can be placed in the cover and the tray placed upside-down on top of the cover. The whole thing can then be shaken, then inverted so that each die ends up in a different grid cell, forming a random game board such as:"><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tries in Word Games :: Data Structures in C#"><meta name=twitter:description content="Tries in Word Games One application of tries is for implementing word games such as BoggleÂ® or ScrabbleÂ®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.
A Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4Â xÂ 4 or 5Â xÂ 5 grid for holding these dice. The face of each die contains a single letter, except that one face of one die contains â€œQuâ€. The tray has a large cover such that the dice can be placed in the cover and the tray placed upside-down on top of the cover. The whole thing can then be shaken, then inverted so that each die ends up in a different grid cell, forming a random game board such as:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/trees/tries/word-games/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Tries in Word Games :: Data Structures in C#"><meta property="og:description" content="Tries in Word Games One application of tries is for implementing word games such as BoggleÂ® or ScrabbleÂ®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.
A Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4Â xÂ 4 or 5Â xÂ 5 grid for holding these dice. The face of each die contains a single letter, except that one face of one die contains â€œQuâ€. The tray has a large cover such that the dice can be placed in the cover and the tray placed upside-down on top of the cover. The whole thing can then be shaken, then inverted so that each die ends up in a different grid cell, forming a random game board such as:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Trees"><meta property="article:modified_time" content="2023-06-07T09:47:27-05:00"><meta itemprop=name content="Tries in Word Games :: Data Structures in C#"><meta itemprop=description content="Tries in Word Games One application of tries is for implementing word games such as BoggleÂ® or ScrabbleÂ®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.
A Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4Â xÂ 4 or 5Â xÂ 5 grid for holding these dice. The face of each die contains a single letter, except that one face of one die contains â€œQuâ€. The tray has a large cover such that the dice can be placed in the cover and the tray placed upside-down on top of the cover. The whole thing can then be shaken, then inverted so that each die ends up in a different grid cell, forming a random game board such as:"><meta itemprop=dateModified content="2023-06-07T09:47:27-05:00"><meta itemprop=wordCount content="1594"><title>Tries in Word Games :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/trees/tries/word-games/ rel=canonical type=text/html title="Tries in Word Games :: Data Structures in C#"><link href=/cis300/trees/tries/word-games/index.xml rel=alternate type=application/rss+xml title="Tries in Word Games :: Data Structures in C#"><link href=/cis300/trees/tries/word-games/tele.html rel=alternate type=text/html title="Tries in Word Games :: Data Structures in C#"><link href=/cis300/trees/tries/word-games/embed.html rel=alternate type=text/html title="Tries in Word Games :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1768892768 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1768892768 defer></script><script src=/cis300/js/search-lunr.min.js?1768892768 defer></script><script src=/cis300/js/search.min.js?1768892768 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1768892768"</script><script src=/cis300/js/lunr/lunr.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1768892768 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892768 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892768 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1768892768 rel=stylesheet><link href=/cis300/css/theme.min.css?1768892768 rel=stylesheet><link href=/cis300/css/format-print.min.css?1768892768 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/trees/tries/word-games/",window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1768892768 rel=stylesheet></head><body class="mobile-support print" data-url=/cis300/trees/tries/word-games/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#tries-in-word-games>Tries in Word Games</a></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement class=a11y-only><a itemprop=item href=/cis300/><span itemprop=name>Data Structures in C#</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/><span itemprop=name>Trees</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/tries/><span itemprop=name>Tries</span></a><meta itemprop=position content="3">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Tries in Word Games</span><meta itemprop=position content="4"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-edit" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=https://github.com/ksu-cs-textbooks/cis300/edit/main/content/trees/tries/word-games.md rel=external target=_blank title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a></div><div class="topbar-button topbar-button-print" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/tries/word-games/index.print.html title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a></div><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/tries/traversing/ title="Traversing a Trie (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/priority-queues/ title="Priority Queues (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more><div class="topbar-button topbar-button-embed" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/tries/word-games/embed.html title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a></div><div class="topbar-button topbar-button-tele" data-content-empty=disable data-width-s=area-more data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/tries/word-games/tele.html title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a></div></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable trees" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=tries-in-word-games>Tries in Word Games</h1></div><h2 id=tries-in-word-games>Tries in Word Games</h2><p>One application of tries is for implementing word games such as
BoggleÂ® or ScrabbleÂ®. This section discusses how a trie can be
used to reduce dramatically the amount of time spent searching for words
in such games. We will focus specifically on Boggle, but the same
principles apply to other word games as well.</p><p>A Boggle game consists of either 16 or 25 dice with letters on their
faces, along with a tray containing a 4Â xÂ 4 or 5Â xÂ 5 grid
for holding these dice. The face of each die contains a single letter,
except that one face of one die contains &ldquo;Qu&rdquo;. The tray has a large
cover such that the dice can be placed in the cover and the tray placed
upside-down on top of the cover. The whole thing can then be shaken,
then inverted so that each die ends up in a different grid cell, forming
a random game board such as:</p><p><a href=#R-image-4bb9c383cdebb137f0031d487ad32b07 class=lightbox-link><img alt="A Boggle game board" class="border lazy lightbox figure-image" loading=lazy src=/cis300/trees/tries/word-games/boggle.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-4bb9c383cdebb137f0031d487ad32b07><img alt="A Boggle game board" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/trees/tries/word-games/boggle.jpg></a></p><p>Players are then given a certain amount of time during which they
compete to try to form as many unique words as they can from these
letters. The letters of a word must be adjacent either horizontally,
vertically, or diagonally, and no die may be used more than once in a
single word. There is a minimum word length, and longer words are worth
more points. For example, the above game board contains the words,
&ldquo;WITCH&rdquo;, &ldquo;ITCH&rdquo;, &ldquo;PELLET&rdquo;, &ldquo;TELL&rdquo;, and &ldquo;DATA&rdquo;, among many others.</p><p><a href=#R-image-81e809fdcfc7222d743f900ec257b7af class=lightbox-link><img alt="Words on a Boggle game board" class="border lazy lightbox figure-image" loading=lazy src=/cis300/trees/tries/word-games/boggle2.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-81e809fdcfc7222d743f900ec257b7af><img alt="Words on a Boggle game board" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/trees/tries/word-games/boggle2.jpg></a></p><p>Suppose we want to build a program that plays Boggle against a human
opponent. The program would need to look for words on a given board. The
dictionary of valid words can of course be stored in a trie. In what follows,
we will show how the structure of a trie can be particularly helpful in
guiding this search so that words are found more quickly.</p><p>We can think of a search from a given starting point as a traversal of a
tree. The root of the tree is the starting point, and its children are
searches starting from adjacent dice. We must be careful, however, to
include in such a tree only those adjacent dice that do not already
occur on the path to the given die. For example, if we start a search at
the upper-left corner of the above board, its children would be the
three adjacent dice containing &ldquo;I&rdquo;, &ldquo;C&rdquo;, and &ldquo;A&rdquo;. The children of &ldquo;I&rdquo;,
then, would not include &ldquo;H&rdquo; because it is already on the path to &ldquo;I&rdquo;.
Part of this tree would look like this:</p><p><a href=#R-image-be7ee6cc8ed0d336d47ba0d8dc99adfe class=lightbox-link><img alt="A part of a tree representing a Boggle search space" class="border lazy lightbox figure-image" loading=lazy src=/cis300/trees/tries/word-games/boggle-tree.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-be7ee6cc8ed0d336d47ba0d8dc99adfe><img alt="A part of a tree representing a Boggle search space" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/trees/tries/word-games/boggle-tree.jpg></a></p><p>Note that this tree is not a data structure - it need not be explicitly
stored anywhere. Rather, it is a mathematical object that helps us to
design an algorithm for finding all of the words. Each word on the board
is simply a path in this tree starting from the root. We can therefore
traverse this tree in much the same way as we outlined in <a href=/cis300/trees/tries/traversing/>the previous
section</a> for tries.
For each node in the tree, we can look up the path leading to that node,
and output it if it is a word in the dictionary.</p><p>In order to be able to implement such a traversal, we need to be able to
find the children of a node. These children are the adjacent cells that
are not used in the path to the node. An efficient way to keep track of
the cells used in this path is with a <strong>bool[Â ,Â ]</strong> of the same
size as the Boggle board - a value of <strong>true</strong> in this array will
indicate that the corresponding cell on the board has been used in the
current path. The children of a node are then the adjacent cells whose
entries in this array are <strong>false</strong>.</p><p>A preorder traversal of this tree will therefore need the following
parameters (and possibly others, depending on how we want to output the
words found):</p><ul><li>The row index of the current cell.</li><li>The column index of the current cell.</li><li>The <strong>bool[Â ,Â ]</strong> described above. The current cell will
have a <strong>false</strong> entry in this array.</li><li>A <strong>StringBuilder</strong> giving the letters on the path up to, but not
including, the current cell.</li></ul><p>The preorder traversal will first need to update the cells used by
setting the location corresponding to the current cell to <strong>true</strong>.
Likewise, it will need to update the <strong>StringBuilder</strong> by appending the
contents of the current cell. Then it will need to process the root by
looking up the contents of the <strong>StringBuilder</strong> - if this forms a word,
it should output this word. Then it should process the children: for
each adjacent cell whose entry in the <strong>bool[Â ,Â ]</strong> is
<strong>false</strong>, it should make a recursive call on that cell. After all the
children have been processed, it will need to return the
<strong>bool[Â ,Â ]</strong> and the <strong>StringBuilder</strong> to their
earlier states by setting the array entry back to <strong>false</strong> and removing
the character(s) appended earlier.</p><p>Once such a method is written, we can call it once for each cell on the
board. For each of these calls, all entries in the <strong>bool[Â ,Â ]</strong>
should be false, and the <strong>StringBuilder</strong> should be empty.</p><p>While the algorithm described above will find all the words on a Boggle
board, a 5Â xÂ 5 board will require quite a while for the algorithm
to process. While this might be acceptable if we are implementing a game
that humans can compete with, from an algorithmic standpoint, we would
like to improve the performance. (In fact, there are probably better
ways to make a program with which humans can compete, as this search
will only find words that begin near the top of the board.)</p><p>We can begin to see how to improve the performance if we observe the
similarity between the trees we have been discussing and a trie
containing the word list. Consider, for example, a portion of the child
labeled &lsquo;h&rsquo; in a trie representing a large set of words:</p><p><a href=#R-image-793a695d7338681da3abca0a86bcc5ad class=lightbox-link><img alt="A portion of a trie." class="border lazy lightbox figure-image" loading=lazy src=/cis300/trees/tries/word-games/trie-portion.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-793a695d7338681da3abca0a86bcc5ad><img alt="A portion of a trie." class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/trees/tries/word-games/trie-portion.jpg></a></p><p>We have omitted some of the children because they are irrelevant to the
search we are performing (e.g., there is no die containing &ldquo;E&rdquo; adjacent
to &ldquo;H&rdquo; on the above game board). Also, we are assuming a minimum word
length of 4; hence, &ldquo;ha&rdquo;, &ldquo;hi&rdquo;, and &ldquo;hit&rdquo; are not shown as words in this
trie.</p><p>Notice the similarity between the trie portion shown above and the tree
shown earlier. The root of the tree has children representing dice
containing &ldquo;I&rdquo; and &ldquo;A&rdquo;, and the former node has children representing
dice containing &ldquo;T&rdquo;, &ldquo;C&rdquo;, and &ldquo;A&rdquo;; likewise, though they are listed in a
different order, the trie has children labeled &lsquo;i&rsquo; and &lsquo;a&rsquo;, and the
former node has children labeled &rsquo;t&rsquo;, &lsquo;c&rsquo;, and &lsquo;a&rsquo;.</p><p>What is more important to our discussion, however, is that the trie does
not have a child labeled &lsquo;c&rsquo;, as there is no English word beginning with
&ldquo;hc&rdquo;. Similarly, the child labeled &lsquo;i&rsquo; does not have a child labeled
&lsquo;i&rsquo;, as there is no English word beginning with &ldquo;hii&rdquo;. If there are no
words in the word list beginning with these prefixes, there is no need
to search the subtrees rooted at the corresponding nodes when doing the
preorder traversal. Using the trie to prune the search in this way ends
up avoiding many subtrees that don&rsquo;t lead to any words. As a result,
only a small fraction of the original tree is searched.</p><p>In order to take advantage of the trie in this way, we need a method in
the trie implementation to return the child having a given label, or
<strong>null</strong> if there is no such child. Alternatively, we might provide a
method that takes a <strong>string</strong> and returns the trie that this <strong>string</strong>
leads to, or <strong>null</strong> if there is no such trie (this method would make
it easier to handle the die containing &ldquo;Qu&rdquo;). Either way, we can then
traverse the trie as we are doing the preorder traversal described
above, and avoid searching a subtree whenever the trie becomes null.</p><p>This revised preorder traversal needs an extra parameter - a trie giving
all completions of words beginning with the prefix given by the
<strong>StringBuilder</strong> parameter. We will need to ensure that this parameter
is never <strong>null</strong>. The algorithm then proceeds as follows:</p><ul><li>From the given trie, get the subtrie containing the completions of
words beginning with the contents of the current cell.</li><li>If this subtrie is not <strong>null</strong>:<ul><li>Set the location in the <strong>bool[Â ,Â ]</strong> corresponding to
the current cell to <strong>true</strong>.</li><li>Append the contents of the current cell to the
<strong>StringBuilder</strong>.</li><li>If the subtrie obtained above contains the empty <strong>string</strong>,
output the contents of the <strong>StringBuilder</strong> as a word found.</li><li>Recursively traverse each adjacent cell whose corresponding
entry in the <strong>bool[Â ,Â ]</strong> is <strong>false</strong>. The recursive
calls should use the subtrie obtained above.</li><li>Set the location in the <strong>bool[Â ,Â ]</strong> corresponding to
the current cell to <strong>false</strong>.</li><li>Remove the contents of the current cell from the end of the
<strong>StringBuilder</strong> (i.e., decrease its <strong>Length</strong> by the
appropriate amount).</li></ul></li></ul><p>We would then apply the above algorithm to each cell on the board. For
each cell, we would use a <strong>bool[Â ,Â ]</strong> whose entries are all
<strong>false</strong>, an empty <strong>StringBuilder</strong>, and the entire trie of valid words. Note that we
have designed the preorder traversal so that it leaves each of these
parameters unchanged; hence, we only need to initialize them once. The
resulting search will find all of the words on the board quickly.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>8.0.0</p><p>Last modified by:
<i class='fa-fw fas fa-user'></i> <a href=mailto:rhowell@ksu.edu>Rod Howell</a>
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/3e0469bee25761d3b32ffe45d587c629a8118d82>Jun 7, 2023</a></p></div></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1768892768></script><script src=/cis300/js/clipboard/clipboard.min.js?1768892768 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1768892768 defer></script><script src=/cis300/js/theme.min.js?1768892768 defer></script></body></html>