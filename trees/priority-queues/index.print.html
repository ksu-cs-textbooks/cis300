<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Priority Queues Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined priority. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Priority Queues :: Data Structures in C#"><meta name=twitter:description content="Priority Queues Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined priority. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/trees/priority-queues/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Priority Queues :: Data Structures in C#"><meta property="og:description" content="Priority Queues Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined priority. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Priority Queues :: Data Structures in C#"><meta itemprop=description content="Priority Queues Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined priority. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="249"><title>Priority Queues :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723839635 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723839635 rel=stylesheet><link href=/cis300/css/fonts.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723839635 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723839635 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723839635 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723839635 rel=stylesheet><link href=/cis300/css/print.css?1723839635 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723839635 rel=stylesheet><script src=/cis300/js/variant.js?1723839635></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723839635 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/trees/priority-queues/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/><span itemprop=name>Trees</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Priority Queues</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/tries/word-games/ title="Tries in Word Games (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/priority-queues/heaps/ title="Heaps (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=priority-queues>Priority Queues</h1></div><h2 id=priority-queues>Priority Queues</h2><p>Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined <em>priority</em>. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its
priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored.</p><p>The general name for such a data structure is a <em>priority queue</em>. Priority queues typically support the following operations:</p><ul><li>Adding a data element, together with a priority.</li><li>Obtaining the number of data elements currently in the structure.</li><li>Obtaining the maximum of all priorities of elements in the structure.</li><li>Removing a data element having maximum priority.</li></ul><p>Obviously, the last two operations above can only be done when the structure is nonempty. A variation on the above focuses on minimum priority rather than maximum priority. This variation is called a <em>min-priority queue</em>. Because we will later cover applications of min-priority queues, we will focus on this variation in this section. In the sub-sections that follow, we will first consider a general structure that can be used in various ways to give efficient priority queue implementations. We will then look at one specific implementation. We will conclude by giving an example of how min-priority queues are used in file compression algorithms.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Priority Queues</h1><article class=default><header class=headline></header><div hidden><h1 id=heaps>Heaps</h1></div><h2 id=heaps>Heaps</h2><p>A common structure for implementing a priority queue is known as a
<em>heap</em>. A heap is a tree whose nodes contain elements with priorities
that can be ordered. Furthermore, if the heap is nonempty, its root
contains the maximum priority of any node in the heap, and each of its
children is also a heap. Note that this implies that, in any subtree,
the maximum priority is at the root. We define a <em>min-heap</em> similarly,
except that the minimum priority is at the root. Below is an example of
a min-heap with integer priorities (the data elements are not shown &mdash;
only their priorities):</p><p><a href=#R-image-3f38095672eeb8d8d777dba8bd6a084a class=lightbox-link><img alt="A min-heap." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/priority-queues/heaps/heap.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3f38095672eeb8d8d777dba8bd6a084a><img alt="A min-heap." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/priority-queues/heaps/heap.jpg></a></p><p>Note that this structure is different from a binary search tree, as
there are elements in the left child that have larger priorities than
the root. Although some ordering is imposed on the nodes (i.e.,
priorities do not decrease as we go down a path from the root), the
ordering is less rigid than for a binary search tree. As a result, there
is less overhead involved in maintaining this ordering; hence, a
min-heap tends to give better performance than an AVL tree, which could
also be used to implement a min-priority queue. Although the definition
of a heap does not require it, the implementations we will consider will
be binary trees, as opposed to trees with an arbitrary number of
children.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>The heap data structure is
unrelated to the pool of memory from which instances of reference types
are constructed &mdash; this also, unfortunately, is called a heap.</p></div></div><p>One advantage to using a min-heap to implement a min-priority queue is
fairly obvious &mdash; an element with minimum priority is always at the root
if the min-heap is nonempty. This makes it easy to find the minimum
priority and an element with this priority. Let&rsquo;s consider how we might
remove an element with minimum priority. Assuming the min-heap is
nonempty, we need to remove the element at the root. Doing so leaves us
with two min-heaps (either of which might be empty). To complete the
removal, we need a way to merge two min-heaps into one. Note that if we
can do this, we also have a way of adding a new element: we form a
1-node min-heap from the new element and its priority, then merge this
min-heap with the original one.</p><p>Let us therefore consider the problem of merging two min-heaps into one.
If either min-heap is empty, we can simply use the other one. Suppose
that both are nonempty. Then the minimum priority of each is located at
its root. The minimum priority overall must therefore be the smaller of
these two priorities. Let <em>s</em> denote the heap whose root has the smaller
priority and <em>b</em> denote the heap whose root has the larger priority.
Then the root of <em>s</em> should be the root of the resulting min-heap.</p><p>Now that we have determined the root of the result, let&rsquo;s consider what
we have left. <em>s</em> has two children, both of which are min-heaps, and <em>b</em>
is also a min-heap. We therefore have three min-heaps, but only two
places to put them - the new left and right children of <em>s</em>. To reduce
the number of min-heaps to two, we can merge two of them into one. This
is simply a recursive call.</p><p>We have therefore outlined a general strategy for merging two min-heaps.
There two important details that we have omitted, though:</p><ul><li>Which two min-heaps do we merge in the recursive call?</li><li>Which of the two resulting min-heaps do we make the new left child
of the new root?</li></ul><p>There are various ways these questions can be answered. Some ways lead
to efficient implementations, whereas others do not. For example, if we
always merge the right child of <em>s</em> with <em>b</em> and make the result the new
right child of the new root, it turns out that all of our min-heaps will have
empty left children. As a result, in the worst case, the time needed to
merge two min-heaps is proportional to the total number of elements in
the two min-heaps. This is poor performance. In <a href=/cis300/trees/priority-queues/leftist-heaps/>the next
section</a> we will
consider a specific implementation that results in a worst-case running
time proportional to the logarithm of the total number of nodes.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=leftist-heaps>Leftist Heaps</h1></div><h2 id=leftist-heaps>Leftist Heaps</h2><p>One efficient way to complete the merge algorithm outlined in <a href=/cis300/trees/priority-queues/heaps/>the
previous section</a> revolves
around the concept of the <em>null path length</em> of a tree. For any tree <i>t</i>, null path length of <i>t</i> is defined
to be
<span class="math align-center">$ 0 $</span> if <i>t</i> is empty, or one more than the minimum of the null path
lengths of its children if <i>t</i> is nonempty. Another way to understand
this concept is that it gives the minimum number of steps needed to get
from the root to an empty subtree. For an empty tree, there is no root,
so we somewhat arbitrarily define the null path length to be <span style=white-space:nowrap><span class="math align-center">$ 0 $</span>.</span> For
single-node trees or binary trees with at least one empty child, the
null path length is
<span class="math align-center">$ 1 $</span> because only one step is needed to reach an empty
subtree.</p><p>One reason that the null path length is important is that it can be
shown that any binary tree with
<span class="math align-center">$ n $</span> nodes has a null path length that is
no more than <span style=white-space:nowrap><span class="math align-center">$ \lg(n + 1) $</span>.</span> Furthermore, recall that in the merging
strategy outlined in <a href=/cis300/trees/priority-queues/heaps/>the previous
section</a>, there is some
flexibility in choosing which child of a node will be used in the
recursive call. Because the strategy reaches a base case when one of the
min-heaps is empty, the algorithm will terminate the most quickly if we
do the recursive call on the child leading us more quickly to an empty
subtree &mdash; i.e., if we use the child with smaller null path length.
Because this length is logarithmic in the number of nodes in the
min-heap, this choice will quickly lead us to the base case and
termination.</p><p>A common way of implementing this idea is to use what is known as a
<em>leftist heap</em>. A leftist heap is a binary tree that forms a heap such
that for every node, the null path length of the right child is no more
than the null path length of the left child. For such a structure,
completing the merge algorithm is simple:</p><ul><li>For the recursive call, we merge the right child of <em>s</em> with <em>b</em>,
where <em>s</em> and <em>b</em> are as defined in <a href=/cis300/trees/priority-queues/heaps/>the previous
section</a>.</li><li>When combining the root and left child of <em>s</em> with the result of the
recursive call, we arrange the children so that the result is a
leftist heap.</li></ul><p>We can implement this idea by defining two classes, <strong>LeftistTree&lt;T></strong>
and <strong>MinPriorityQueue&lt;TPriority, TValue></strong>. For the
<strong>LeftistTree&lt;T></strong> class, we will only be concerned with the shape of
the tree &mdash; namely, that the null path length of the right child is never
more than the null path length of the left child. We will adopt a
strategy similar to what we did with <a href=/cis300/trees/avl/>AVL
trees</a>. Specifically a
<strong>LeftistTree&lt;T></strong> will be immutable so that we can always be sure
that it is shaped properly. It will then be a straightforward matter to
implement a <strong>MinPriorityQueue&lt;TPriority, TValue></strong>, where
<strong>TPriority</strong> is the type of the priorities, and <strong>TValue</strong> is the type
of the values.</p><p>The implementation of <strong>LeftistTree&lt;T></strong> ends up being very similar to
the implementation we described for <a href=/cis300/trees/avl/>AVL tree
nodes</a>, but without the
rotations. We need three <strong>public</strong> properties using the default
implementation with <strong>get</strong> accessors: the data (of type <strong>T</strong>) and the
two children (of type <strong>LeftistTree&lt;T>?</strong>). We also need a <strong>private</strong>
field to store the null path length (of type <strong>int</strong>). We can define a
<strong>static</strong> method to obtain the null path length of a given
<strong>LeftistTree&lt;T>?</strong>. This method is essentially the same as the
<strong>Height</strong> method for an AVL tree, except that if the given tree is
<strong>null</strong>, we return 0. A constructor takes as its parameters a data
element of type <strong>T</strong> and two children of type <strong>LeftistTree&lt;T>?</strong>. It
can initialize its data with the first parameter. To initialize its
children, it first needs to determine their null path lengths using the
<strong>static</strong> method above. It then assigns the two <strong>LeftistTree&lt;T>?</strong>
parameters to its child fields so that the right child&rsquo;s null path
length is no more than the left child&rsquo;s. Finally, it can initialize its
own null path length by adding 1 to its right child&rsquo;s null path length.</p><p><span id=where></span> Let&rsquo;s now consider how we can implement
<strong>MinPriorityQueue&lt;TPriority, TValue></strong>. The first thing we need to
consider is the type, <strong>TPriority</strong>. This needs to be a non-nullable type that can be
ordered (usually it will be a numeric type like <strong>int</strong>). We can
restrict <strong>TPriority</strong> to be a non-nullable subtype of <strong>IComparable&lt;TPriority></strong>
by using a <strong>where</strong> clause, as we did for dictionaries (see
&ldquo;<a href=/cis300/dictionaries/linked-list-impl/>Implementing a Dictionary with a Linked
List</a>&rdquo;).</p><p>We then need a <strong>private</strong> field in which to store a leftist tree. We
can store both the priority and the data element in a node if we use a
<strong>LeftistTree&lt;KeyValuePair&lt;TPriority, TValue>>?</strong>; thus, the keys are
the priorities and the values are the data elements. We also need a
<strong>public int</strong> property to get of the number of elements in the
min-priority queue. This property can use the default implementation
with <strong>get</strong> and <strong>private set</strong> accessors.</p><p>In order to implement <strong>public</strong> methods to add an element with a
priority and to remove an element with minimum priority, we need the
following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>LeftistTree</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TPriority</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;?</span>
</span></span><span class=line><span class=cl>    <span class=n>Merge</span><span class=p>(</span><span class=n>LeftistTree</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TPriority</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;?</span> <span class=n>h1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>LeftistTree</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TPriority</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;?</span> <span class=n>h2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This method consist of three cases. The first two cases occur when
either of the parameters is <strong>null</strong>. In each such case, we return the
other parameter. In the third case, when neither parameter is <strong>null</strong>,
we first need to compare the priorities in the data stored in the root
nodes of the parameters. A priority is stored in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.key?view=net-6.0#system-collections-generic-keyvaluepair-2-key" rel=external target=_blank><strong>Key</strong></a>
property of the <strong>KeyValuePair</strong>, and we have constrained this type so
that it has a <strong>CompareTo</strong> method that will compare one instance with
another. Once we have determined which root has a smaller priority, we
can construct and return a new
<strong>LeftistTree&lt;KeyValuePair&lt;TPriority,Â TValue>></strong> whose data
is the data element with smaller priority, and whose children are the
left child of this data element and the result of recursively merging
the right child of this element with the parameter whose root has larger
priority.</p><p>The remaining methods and properties of
<strong>MinPriorityQueue&lt;TPriority,Â TValue></strong> are now fairly
straightforward.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=huffman-trees>Huffman Trees</h1></div><h2 id=huffman-trees>Huffman Trees</h2><p>In this section, we&rsquo;ll consider an application of min-priority queues to
the general problem of compressing files. Consider, for example, a plain
text file like <a href=/cis300/trees/priority-queues/huffman-trees/pg5.txt>this copy of the U. S. Constitution</a>. This file
is encoded using UTF-8, the most common encoding for plain text files.
The characters most commonly appearing in English-language text files
are each encoded as one byte (i.e., eight bits) using this scheme. For
example, in the text file referenced above, every character is encoded
as a single byte (the first three bytes of the file are an optional code
indicating that it is encoded in UTF-8 format). Furthermore, some byte
values occur much more frequently than others. For example, the encoding
of the blank character occurs over 6000 times, whereas the encoding of
&lsquo;$&rsquo; occurs only once, and the encoding of &lsquo;=&rsquo; doesn&rsquo;t occur at all.</p><p>One of the techniques used by most file compression schemes is to find a
variable-width encoding scheme for the file. Such a scheme uses fewer
bits to encode commonly-occurring byte values and more bits to encode
rarely-occurring byte values. Byte values that do not occur at all in
the file are not given an encoding.</p><p>Consider, for example, a file containing the single string,
&ldquo;Mississippi&rdquo;, with no control characters signaling the end of the line.
If we were to use one byte for each character, as UTF-8 would do, we
would need 11 bytes (or 88 bits). However, we could encode the
characters in binary as follows:</p><ul><li>M: 100</li><li>i: 0</li><li>p: 101</li><li>s: 11</li></ul><p>Obviously because each character is encoded with fewer than 8 bits, this
will give us a shorter encoding. However, because &lsquo;i&rsquo; and &rsquo;s&rsquo;, which
each occur four times in the string, are given shorter encodings than
&lsquo;M&rsquo; and &lsquo;p&rsquo;, which occur a total of three times combined, the number of
bits is further reduced. The encoded string is</p><pre><code>100011110111101011010
</code></pre><p>which is only 21 bits, or less than 3 bytes.</p><p>In constructing such an encoding scheme, it is important that the
encoded string can be decoded unambiguously. For example, it would
appear that the following scheme might be even better:</p><ul><li>M: 01</li><li>i: 0</li><li>p: 10</li><li>s: 1</li></ul><p>This scheme produces the following encoding:</p><pre><code>01011011010100
</code></pre><p>which is only 14 bits, or less than 2 bytes. However, when we try to
decode it, we immediately run into problems. Is the first 0 an &lsquo;i&rsquo; or
the first bit of an &lsquo;M&rsquo;? We could decode this string as &ldquo;isMsMsMisii&rdquo;,
or a number of other possible strings.</p><p>The first encoding above, however, has only one decoding, &ldquo;Mississippi&rdquo;.
The reason for this is that this encoding is based on the following
binary tree:</p><p><a href=#R-image-dfcc92c2790faf5497ead8f6b9048e25 class=lightbox-link><img alt="A Huffman tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/priority-queues/huffman-trees/huffman.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-dfcc92c2790faf5497ead8f6b9048e25><img alt="A Huffman tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/priority-queues/huffman-trees/huffman.jpg></a></p><p>To get the encoding for a character, we trace the path to that character
from the root, and record a 0 each time we go left and a 1 each time we
go right. Thus, because the path to &lsquo;M&rsquo; is right, left, left, we have an
encoding of 100. To decode, we simply use the encoding to trace out a
path in the tree, and when we reach a character (or more generally, a
byte value), we record that value. If we form the tree such that each
node has either two empty children or two nonempty children, then when
tracing out a path, we will always either have a choice of two
alternatives or be at a leaf storing a byte value. The decoding will
therefore be unambiguous. Such a tree that gives an encoding whose
length is minimized over all such encodings is called a <em>Huffman tree</em>.</p><p>Before we can find a Huffman tree for a file, we need to determine how
many times each byte value occurs. There are 256 different byte values
possible; hence we will need an array of 256 elements to keep track of
the number of occurrences of each. Because files can be large, this
array should be a <strong>long[Â ]</strong>. We can then use element <em>i</em> of this
array to keep track of the number of occurrences of byte value <em>i</em>.
Thus, after constructing this array, we can read the file one byte at a
time as described in <a href=/cis300/io/other-file-io/>&ldquo;Other File
I/O&rdquo;</a>, and for each
<strong>byte</strong> <code>b</code> that we read, we increment the value at location <code>b</code> of the
array.</p><p>Having built this frequency table, we can now use it to build a Huffman
tree. We will build this tree from the bottom up, storing subtrees in a
min-priority queue. The priority of each subtree will be the total
number of occurrences of all the byte values stored in its leaves. We
begin by building a 1-node tree from each nonzero value in the frequency
table. As we iterate through the frequency table, if we find that
location <em>i</em> is nonzero, we construct a node containing <em>i</em> and add that
node to the min-priority queue. The priority we use when adding the node
is the number of occurrences of <em>i</em>, which is simply the value at
location <em>i</em> of the frequency table.</p><p>Once the min-priority queue has been loaded with the leaves, can begin
combining subtrees into larger trees. We will need to handle as a
special case an empty min-priority queue, which can result only from an
empty input file. In this case, there is no Huffman tree, as there are
no byte values that need to be encoded. Otherwise, as long as the
min-priority queue has more than one element, we:</p><ul><li>Get and remove the two smallest priorities and their associated
trees.</li><li>Construct a new binary tree with these trees as its children and 0
as its data (which will be unused).</li><li>Add the resulting tree to the min-priority queue with a priority
equal to the sum of the priorities of its children.</li></ul><p>Because each iteration removes two elements from the min-priority queue
and adds one, eventually the min-priority queue will contain only one
element. It can be shown that this last remaining element is a Huffman
tree for the file.</p><p>Most file compression schemes involve more than just converting to a
Huffman-tree encoding. Furthermore, even if this is the only technique
used, simply writing the encoded data is insufficient to compress the
file, as the Huffman tree is needed to decompress it. Therefore, some
representation of the Huffman tree must also be written. In addition, a
few extra bits may be needed to reach a byte boundary. Because of this,
the length of the decompressed file is also needed for decompression so
that the extra bits are not interpreted as part of the encoded data. Due
to this additional output, compressing a short file will likely result
in a longer file than the original.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5>May 22, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723839635 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723839635 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1723839635></script><script src=/cis300/js/theme.js?1723839635 defer></script></body></html>