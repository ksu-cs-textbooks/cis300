




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.2.0+tip">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="K-State CIS 300: Data Structures">
    <meta name="author" content="Rod Howell and Josh Weese">
    <title>Trees :: Data Structures in C#</title>
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1686240615" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1686240615" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1686240615" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1686240615" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1686240615" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1686240615" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/perfect-scrollbar.min.css?1686240615" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/nucleus.css?1686240615" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1686240615" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1686240615" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme.css?1686240615" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme-light-theme.css?1686240615" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/ie.css?1686240615" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/variant.css?1686240615" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/print.css?1686240615" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/format-print.css?1686240615" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/variant.js?1686240615"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis300/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis300/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis300/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/custom.css?1686240615" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/jquery.min.js?1686240615" defer></script>

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis300/trees/">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div class="navigation">
             <a class="nav nav-next" href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/" title="Binary Search Trees (&#129106;)"><i class="fas fa-chevron-right fa-fw"></i></a>
          </div>
          <div class="navigation">
             <a class="nav nav-prev" href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/binary-search/" title="Implementing a Dictionary with an Array-Like Structure (&#129104;)"><i class="fas fa-chevron-left fa-fw"></i></a>
          </div>
          <div id="top-print-link">
            <a class="print-link" title='Print whole chapter (CTRL+ALT+p)' href="https://ksu-cs-textbooks.github.io/cis300/trees/index.print.html">
              <i class="fas fa-print fa-fw"></i>
            </a>
          </div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis300/trees/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis300/trees/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="top-github-link">
            <a class="github-link" title='Edit (CTRL+ALT+e)' href="https://gitlab.cs.ksu.edu/-/ide/project/cis300/cis300-book/edit/master/-/content/trees/_index.md" target="blank">
              <i class="fas fa-pen fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" title='Menu (CTRL+ALT+m)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <span id="toc-menu" title='Table of Contents (CTRL+ALT+t)'><i class="fas fa-list-alt fa-fw"></i></span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <meta itemprop="itemListOrder" content="Descending" />
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="2" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis300/"><span itemprop="name">Data Structures in C#</span></a> > </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><meta itemprop="position" content="1" /><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis300/trees/" aria-disabled="true"><span itemprop="name">Trees</span></a></li>
            </ol>
          </div>
          <div class="default-animation progress">
            <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#trees">Trees</a></li>
  </ul>
</nav>
            </div>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
          <article class="default">
<div hidden><h1>Trees</h1></div>
<h2 id="trees">Trees</h2>
<p>

<a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/binary-search">Binary search</a> provides an efficient way to find elements in a sorted array-like structure. However, inserting or removing from an array-like structure can be expensive because all subsequent data elements must be moved to accommodate the change. On the other hand, linked lists can be modified efficiently, provided we have a reference to the cell preceding the insertion or deletion point. However, finding a cell can be expensive because the only way to search a linked list is to start at the front and work through it a cell at a time. We would like a data structure that provides both efficient lookups and efficient insertions and deletions.</p>
<p>To meet this challenge, we want a linked structure so that changes can be made cheaply by changing a few references. However, we want the individual cells in the structure to be arranged in a way that supports something like a binary search. The specific structure that we want is called a binary search tree, which is a particular kind of tree.
In this chapter, we will examine various kinds of trees. We will start by defining trees and developing a strategy for processing them. We will then present binary search trees, which will provide a partial solution to our challenge of finding a data structure to support efficient lookups, insertions, and deletions. However, there will be cases in which binary search trees have poor performance. We will therefore give a refinement known as AVL trees, which give good performance in all cases. We will then examine two other uses of trees - tries and priority queues.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
          <article class="default">
<div hidden><h1>Introduction to Trees</h1></div>
<h2 id="introduction-to-trees">Introduction to Trees</h2>
<p>A <em>tree</em> is a mathematical structure having a hierarchical nature. A
tree may be <em>empty</em>, or it may consist of:</p>
<ul>
<li>a <em>root</em>, and</li>
<li>zero or more <em>children</em>, each of which is also a tree.</li>
</ul>
<p>Consider, for example, a folder (or directory) in a Windows file system.
This folder and all its sub-folders form a tree &mdash; the root of the tree
is the folder itself, and its children are the folders directly
contained within it. Because a folder (with its
sub-folders) forms a tree, each of the sub-folders directly contained
within the folder are also trees. In this example, there are no empty
trees &mdash; an empty folder is a nonempty tree containing a root but no
children.</p>

  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>We are only considering actual folders,
not shortcuts, symbolic links, etc.</p>
    </div>
</div>
<p>We have at least a couple of ways of presenting a tree graphically. One
way is as done within Windows Explorer:</p>
<p><img src="windows-tree.jpg" alt="A Windows file system tree"></p>
<p>Here, children are shown in a vertically-aligned list, indented under
the root. An alternative depiction is as follows:</p>
<p><img src="tree-example.jpg" alt="A tree"></p>
<p>Here, children are shown by drawing lines to them downward from the
root.</p>
<p>Other examples of trees include various kinds of search spaces. For
example, for a chess-playing program, the search for a move can be
performed on a game tree whose root is a board position and whose
children are the game trees formed from each board position reachable
from the root position by a single move. Also, in the sections that
follow, we will consider various data structures that form trees.</p>
<p>.NET provides access to the folders in a file system tree
via the


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.directoryinfo?view=net-6.0" target="_blank" rel="noopener"><strong>DirectoryInfo</strong></a>
class, found in the <strong>System.IO</strong> namespace. This class has a


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.directoryinfo.-ctor?view=net-6.0#system-io-directoryinfo-ctor%28system-string%29" target="_blank" rel="noopener">constructor</a>
that takes as its only parameter a <strong>string</strong> giving the path to a
folder (i.e., a directory) and constructs a <strong>DirectoryInfo</strong> describing
that folder. We can obtain such a <strong>string</strong> from the user using a


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.folderbrowserdialog?view=windowsdesktop-6.0" target="_blank" rel="noopener"><strong>FolderBrowserDialog</strong></a>.
This class is similar to a 

<a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/file-dialogs">file
dialog</a> and can be added
to a form in the Design window in the same way. If <code>uxFolderBrowser</code> is
a <strong>FolderBrowserDialog</strong>, we can use it to obtain a <strong>DirectoryInfo</strong>
for a user-selected folder as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (uxFolderBrowser.ShowDialog() == DialogResult.OK)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DirectoryInfo folder = <span style="color:#66d9ef">new</span>(uxFolderBrowser.SelectedPath);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Process the folder</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Various properties of a <strong>DirectoryInfo</strong> give information about the
folder; for example:</p>
<ul>
<li>

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.directoryinfo.name?view=net-6.0#system-io-directoryinfo-name" target="_blank" rel="noopener"><strong>Name</strong></a>
gets the name of the folder as a <strong>string</strong>.</li>
<li>

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.filesysteminfo.fullname?view=net-6.0#system-io-filesysteminfo-fullname" target="_blank" rel="noopener"><strong>FullName</strong></a>
gets the full path of the folder as a <strong>string</strong>.</li>
<li>

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.directoryinfo.parent?view=net-6.0#system-io-directoryinfo-parent" target="_blank" rel="noopener"><strong>Parent</strong></a>
gets the parent folder as a <strong>DirectoryInfo?</strong>. If the current folder is the root of its file system, this property is <strong>null</strong>.</li>
</ul>
<p>In addition, its


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.directoryinfo.getdirectories?view=net-6.0#system-io-directoryinfo-getdirectories" target="_blank" rel="noopener"><strong>GetDirectories</strong></a>
method takes no parameters and returns a <strong>DirectoryInfo[ ]</strong> whose
elements describe the contained folders (i.e., the elements of the array
are the children of the folder). For example, if <code>d</code> refers to a
<strong>DirectoryInfo</strong> for the folder <strong>Ksu.Cis300.HelloWorld</strong> from the
figures above, then <strong>d.GetDirectories()</strong> would return a 3-element
array whose elements describe the folders <strong>bin</strong>, <strong>obj</strong>, and
<strong>Properties</strong>. The following method illustrates how we can write the
names of the folders contained within a given folder to a


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter?view=net-6.0" target="_blank" rel="noopener"><strong>StreamWriter</strong></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Writes the names of the directories contained in the given directory </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// (excluding their sub-directories) to the given StreamWriter.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;dir&#34;&gt;The directory whose contained directories are to</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// be written.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;output&#34;&gt;The output stream to write to.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> WriteSubDirectories(DirectoryInfo dir, StreamWriter output)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (DirectoryInfo d <span style="color:#66d9ef">in</span> dir.GetDirectories())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        output.WriteLine(d.Name);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For a more interesting problem, suppose we want to write to a
<strong>StreamWriter</strong> the structure of an entire folder, as follows:</p>
<pre>
Ksu.Cis300.HelloWorld
  bin
    Debug
    Release
  obj
    Debug
      TempPE
  Properties
</pre>
<p>We can break this task into the following steps:</p>
<ol>
<li>
<p>Write the name of the folder:</p>
<pre>Ksu.Cis300.HelloWorld</pre>
</li>
<li>
<p>Write the structure of each child folder, indented one level (i.e.,
two spaces):</p>
<ul>
<li>
<p>First child:</p>
<pre>
  bin
    Debug
    Release
</pre>
</li>
<li>
<p>Second child:</p>
<pre>
  obj
    Debug
      TempPE
</pre>
</li>
<li>
<p>Third child:</p>
<pre>
  Properties
</pre>
</li>
</ul>
</li>
</ol>
<p><span id="recursion"></span> Note that writing the structure of a child
folder is an instance of the original problem that we want to solve -
i.e., writing the structure of a folder. The only difference is that the
folders are different and the amount of indentation is different. We can
solve such a problem using a technique called <em>recursion</em>. Recursion
involves a method calling itself. Because of the recursive nature of a
tree (i.e., each child of a tree is also a tree), recursion is commonly
used in processing trees.</p>
<p>In order to use recursion, we first must define precisely what we want
our method to accomplish, wherever it might be called. For this problem,
we want to write to a given <strong>StreamWriter</strong> a list of all the folders
contained within a given folder, including the given folder itself and
all sub-folders in the entire tree, where each folder is indented two
spaces beyond its parent&rsquo;s indentation. Furthermore, the entire tree
below a given folder (i.e., excluding the folder itself) should be
listed below that folder, but before any folders that are outside that
folder. In order to write such a method, we need three parameters:</p>
<ul>
<li>a <strong>DirectoryInfo</strong> giving the root folder;</li>
<li>a <strong>StreamWriter</strong> where the output is to be written; and</li>
<li>an <strong>int</strong> giving the level of indentation for the root folder,
where each level of indentation is two spaces.</li>
</ul>
<p>Because the root folder must be written first, we begin there. We first
must write two blanks for every level of indentation, then write the
name of the root folder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Writes the directory structure for the given root directory to the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// given StreamWriter, indenting all entries to the given indentation</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// level (incomplete). </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;root&#34;&gt;The root directory.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;output&#34;&gt;The output stream to which to write&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;level&#34;&gt;The current indentation level.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> WriteTree(DirectoryInfo root, StreamWriter output, <span style="color:#66d9ef">int</span> level)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; level; i++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        output.Write(<span style="color:#e6db74">&#34;  &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    output.WriteLine(root.Name);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We now need to write the sub-directories . . .</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can get the children using <strong>root.GetDirectories()</strong>. Each of the
elements of the array this method returns will be a <strong>DirectoryInfo</strong>
whose structure we want to write. Looking back at how we described what
we want the <strong>WriteTree</strong> method to accomplish, we see that it is
exactly what we want to do for each child. We can therefore make a
recursive call for each child, specifying that the indentation level
should be one deeper than the level for <code>root</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Writes the directory structure for the given root directory to the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// given StreamWriter, indenting all entries to the given indentation</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// level (incomplete). </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;root&#34;&gt;The root directory.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;output&#34;&gt;The output stream to which to write&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;level&#34;&gt;The current indentation level.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> WriteTree(DirectoryInfo root, StreamWriter output, <span style="color:#66d9ef">int</span> level)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; level; i++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        output.Write(<span style="color:#e6db74">&#34;  &#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    output.WriteLine(root.Name);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (DirectoryInfo d <span style="color:#66d9ef">in</span> root.GetDirectories())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        WriteTree(d, output, level + <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This method accomplishes the desired task, provided the directory tree
does not contain symbolic links or anything similar that might be
represented using a <strong>DirectoryInfo</strong>, but is not an actual folder.
While it is possible to detect these and avoid following them, we will
not consider that here.</p>
<p>There is something that may seem mysterious about what we have done. In
order to convince ourselves that this method is written correctly, we
need to know that the recursive calls work correctly; however, the
recursive calls are to the same method. Our reasoning therefore seems
circular. However, we are actually using a mathematical principle from
the discipline of formally proving software correctness: in order to
prove that a recursive method meets its specification we may assume that
any recursive calls meet that same specification, provided that these
recursive calls are all on smaller problem instances.</p>
<p>The restriction that recursive calls are on smaller problem instances is
what avoids circular reasoning regarding recursion. We associate with
each problem instance a nonnegative integer describing its size. For a
problem involving a tree, this size is typically the number of <em>nodes</em>
in the tree, where a node is a root of some subtree. Because every node
in a child is also in the tree containing the child, but the root of the
containing tree is not in the child, a child is always smaller, provided
the tree is finite. (For directory trees, if the underlying file system
is a Windows system, the tree will be finite; however if it is a
non-Windows system, the trees may appear to Windows as being infinite -
the above method actually will not work in such cases.)</p>
<p>The validity of this strategy is based on the fact that for any method,
the following three statements cannot be simultaneously true:</p>
<ol>
<li>All of the method&rsquo;s recursive calls (if there are any) are on inputs
of smaller size, where the size is defined to be a nonnegative
integer.</li>
<li>When the method is given any input, if all of the method&rsquo;s recursive
calls produce correct results, then the method itself produces a
correct result.</li>
<li>There is at least one input for which the method does not produce a
correct result.</li>
</ol>
<p>Thus, if we can ensure that Statements 1 and 2 are true, then Statement
3 must be false; i.e., the method will be correct. To ensure Statement
2, we only need to concern ourselves with cases in which all recursive
calls produce correct results; hence, we simply assume that each
recursive call produces correct results.</p>
<p>To see why the three statements above cannot be simultaneously true,
let&rsquo;s first suppose Statement 3 is true. Let <em>S</em> be the set of all
inputs for which the method does not produce a correct result. Then
because Statement 3 is true, this set is nonempty. Because each input in
<em>S</em> has a nonnegative integer size, there is an input <em>I</em> in <em>S</em> with
smallest size. Now suppose Statement 1 is true. Then when the method is
run on input <em>I</em>, each of the recursive calls is given an input smaller
than <em>I</em>; hence, because <em>I</em> is a smallest input in <em>S</em>, none of these
inputs is in <em>S</em>. Therefore, each of the recursive calls produces a
correct result. We therefore have an input, <em>I</em> on which all of the
method&rsquo;s recursive calls produce correct results, but the method itself
does not produce a correct result. Statement 2 is therefore false.</p>
<p>Once we understand this strategy, recursion is as easy to use as calling
a method written by someone else. In fact, we should treat recursive
calls in exactly the same way &mdash; we need to understand what the recursive
call is supposed to accomplish, but not necessarily how it accomplishes
it. Furthermore, because processing trees typically involves solving the
same problem for multiple nodes in the tree, recursion is the natural
technique to use.</p>
<p>A recursive method for processing a tree will break down into cases,
each fitting into one of the following categories:</p>
<ul>
<li>A <em>base case</em> is a case that is simple enough that a recursive call
is not needed. Empty trees are always base cases, and sometimes
other trees are as well.</li>
<li>A <em>recursive case</em> is a case that requires one or more recursive
calls to handle it.</li>
</ul>
<p>A recursive method will always contain cases of <em>both</em> these types. If
there were no base cases, the recursion would never terminate. If there
were no recursive cases, the method wouldn&rsquo;t be recursive. Most
recursive methods are, in fact, structured as an <strong>if</strong>-statement, with
some cases being base cases and some cases being recursive cases.
However, for some recursive methods, such as <strong>WriteTree</strong> above, the
base cases aren&rsquo;t as obvious. Note that in that method, the recursive
call appears in a loop; hence, if the loop doesn&rsquo;t iterate (because the
array returned is empty), no recursive calls are made. Furthermore, if
the directory tree is finite, there must be some sub-directories that
have no children. When the <strong>GetDirectories</strong> method is called for such
a directory, it returns an empty array. These directories are therefore
the base cases.</p>
<p>The <strong>WriteTree</strong> method above is actually an example of processing an
entire tree using a <em>preorder traversal</em>. In a preorder traversal, the
root of the tree is processed first, then each of the children is
processed using a recursive call. This results in each node&rsquo;s being
processed prior to any node contained in any of its children. For the
<strong>WriteTree</strong> method, this means that the name of any folder is written
before any folders contained anywhere within it.</p>
<p>When debugging a recursive method, we should continue to think about it
in the same way &mdash; that is, assume that all recursive calls work
correctly. In order to isolate an error, we need to find an instance
that causes an error, but whose recursive calls all work correctly. It
will almost always be possible to find such a case that is small &mdash; in
fact, small cases tend to be the most likely ones to fit this
description. When debugging, it therefore makes sense to start with the
smallest cases, and slowly increase their size until one is found that
causes an error. When using the debugger to step through code, first
delete all breakpoints from this method, then use 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/debugger/#debugger-buttons">Step
Over</a> to step over
the recursive calls. If a recursive call doesn&rsquo;t work correctly, you
have found a smaller instance that causes an error &mdash; work on that
instance instead. Otherwise, you can focus on the top-level code for the
instance you are debugging. This is much easier to think about that
trying to work through different levels of recursion.</p>
<p>There are times when it is useful to know exactly what happens when a
recursive call (or any method call, for that matter) is made. Prior to
transferring control to the top of the method being called, all local
variables and the address of the current code location are pushed onto
the <em>call stack</em>. This call stack is just like any other stack, except
that it has a smaller amount of space available to it. You can, in fact,
examine the call stack when debugging &mdash; from the &ldquo;Debug&rdquo; menu, select
&ldquo;Windows -&gt; Call Stack&rdquo;. This will open a window
showing the contents of the call stack. The line on top shows the line
of code currently ready for execution. Below it is the line that called
the current method, and below that line is the line that called that
method, etc. By double-clicking on an entry in the call stack, you can
use the other debugging tools to examine the values of the local
variables for the method containing that line of code. If this method is
recursive, the values displayed for the local variables are their values
at that level of recursion.</p>

  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>This only applies to the values
stored in local variables - in particular, if a local variable is a


<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/reference-value">reference type</a>, the
value of the object to which it refers will not revert to its earlier
state. For example, if a local variable is an array, the debugger will
show the value of this variable to refer to the array that it referred
to at that point, but the values shown in that array will be its current
values.</p>
    </div>
</div>
<p>One consequence of method calls using a call stack with limited space
available is that moderately deep recursion can fill up the call stack.
If this happens, a <strong>StackOverflowException</strong> will be thrown. Thus,
infinite recursion will always throw this exception, as will recursion
that is nested too deeply. For this reason, it is usually a bad idea to
use recursion on a 

<a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists">linked
list</a> - if the list is
very long, the recursion will be nested too deeply. We must also take
care in using recursion with trees, as long paths in a tree can lead to
a <strong>StackOverflowException</strong>. Due to the branching nature of trees,
however, we can have very large trees with no long paths. In fact, there
are many cases in which we can be sure that a tree doesn&rsquo;t contain any
long paths. In such cases, recursion is often a useful technique.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Binary Search Trees</h1></div>
<h2 id="binary-search-trees">Binary Search Trees</h2>
<p>We motivated our discussion of trees by expressing a need for a linked
data structure that supports a binary search or something similar. We
will present such a data structure - a binary search tree - in this
section. While it will support efficient lookups, insertions, and
deletions for many applications, we will see that there are cases in
which it performs no better than a linked list. In 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">the next
section</a>, we will add some
refinements that will guarantee good performance.</p>
<p>Before we can define a binary search tree, we need to define a more
primitive structure, a <em>binary tree</em>. We will then use binary trees to
define binary search trees, and show how to build them and search them.
We will then show how to remove elements from them. We conclude this
section by presenting the <em>inorder traversal</em> algorithm, which processes
all the elements in a binary search tree in order.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
          <article class="default">
<div hidden><h1>Binary Trees</h1></div>
<h2 id="binary-trees">Binary Trees</h2>
<p>A <em>binary tree</em> is a tree in which each node has exactly two children,
either of which may be empty. For example, the following is a binary
tree:</p>
<p><img src="binary-tree.jpg" alt="A binary tree"></p>
<p>Note that some of the nodes above are drawn with only one child or no
children at all. In these cases, one or both children are empty. Note
that we always draw one child to the left and one child to the right. As
a result, if one child is empty, we can always tell which child is empty
and which child is not. We call the two children the <em>left</em> child and
the <em>right</em> child.</p>
<p>We can implement a single node of a binary tree as a data structure and
use it to store data. The implementation is simple, like 

<a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro">the
implementation of a linked list
cell</a>. Let&rsquo;s call
this type <strong>BinaryTreeNode&lt;T&gt;</strong>, where <strong>T</strong> will be the type of data
we will store in it. We need three <strong>public</strong> properties:</p>
<ul>
<li>a <strong>Data</strong> property of type <strong>T</strong>;</li>
<li>a <strong>LeftChild</strong> property of type <strong>BinaryTreeNode&lt;T&gt;?</strong>; and</li>
<li>a <strong>RightChild</strong> property of type <strong>BinaryTreeNode&lt;T&gt;?</strong>.</li>
</ul>
<p>We can define both <strong>get</strong> and <strong>set</strong> accessors using the default
implementation for each of these properties. However, it is sometimes
advantageous to make this type immutable. In such a case, we would not
define any <strong>set</strong> accessors, but we would need to be sure to define a
constructor that takes three parameters to initialize these three
properties. While immutable nodes tend to degrade the performance
slightly, they also tend to be easier to work with. For example, with
immutable nodes it is impossible to build a structure with a cycle in
it.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Introduction to Binary Search Trees</h1></div>
<h2 id="introduction-to-binary-search-trees">Introduction to Binary Search Trees</h2>
<p>In this section and 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/remove">the
next</a>,
we will present a binary search tree as a data structure that can be
used to implement a


<a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries">dictionary</a>
whose key type can be ordered. This implementation will provide
efficient lookups, insertions, and deletions in most cases; however,
there will be cases in which the performance is bad. In 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">a later
section</a>,
we will show how to extend this good performance to all cases.</p>
<p>A <em>binary search tree</em> is a 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/binary-trees">binary
tree</a> containing
key-value pairs whose keys can be ordered. Furthermore, the data items
are arranged such that the key in each node is:</p>
<ul>
<li>greater than all the keys in its left child; and</li>
<li>less than all the keys in its right child.</li>
</ul>
<p>Note that this implies that all keys must be unique. For example, the
following is a binary search tree storing integer keys (only the keys
are shown):</p>
<p><img src="binary-search-tree-ex.jpg" alt="A binary search tree"></p>
<p>The hierarchical nature of this structure allows us to do something like
a binary search to find a key. Suppose, for example, that we are looking
for 41 in the above tree. We first compare 41 with the key in the root.
Because 41 &lt; 54, we can safely ignore the right child, as all
keys there must be greater than 54. We therefore compare 41 to the key
in the root of the left child. Because 41 &gt; 23, we look in the
right child, and compare 41 to 35. Because 41 &gt; 35, we look in
the right child, where we find the key we are looking for.</p>
<p>Note the similarity of the search described above to a binary search. It
isn&rsquo;t exactly the same, because there is no guarantee that the root is
the middle element in the tree &mdash; in fact, it could be the first or the
last. In many applications, however, when we build a binary search tree
as we will describe below, the root of the tree tends to be roughly the
middle element. When this is the case, looking up a key is very
efficient. 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">Later</a>, we will
show how we can build and maintain a binary search tree so that this is
always the case.</p>
<p>It isn&rsquo;t hard to implement the search strategy outlined above using a
loop. However, in order to reinforce the concept of recursion as a tree
processing technique, let&rsquo;s consider how we would implement the search
using recursion. The algorithm breaks into four cases:</p>
<ul>
<li>The tree is empty. In this case, the element we are looking for is
not present.</li>
<li>The key we are looking for is at the root - we have found what we
are looking for.</li>
<li>The key we are looking for is less than the key at the root. We then
need to look for the given key in the left child. Because this is a
smaller instance of our original problem, we can solve it using a
recursive call.</li>
<li>The key we are looking for is greater than the key at the root. We
then look in the right child using a recursive call.</li>
</ul>

  
  
<div class="box notices cstyle warning">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
    <div class="box-content">
<p>It is important to handle the case of an empty tree first, as the other
cases don&rsquo;t make sense if the tree is empty. In fact, if we are using
<strong>null</strong> to represent an empty binary search tree (as is fairly common),
we will get a compiler warning if we don&rsquo;t do this, and ultimately a <strong>NullReferenceException</strong> if we try to access the key
at an empty root.</p>
    </div>
</div>
<p>If we need to compare
elements using a


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-6.0#system-icomparable-1-compareto%28-0%29" target="_blank" rel="noopener"><strong>CompareTo</strong></a>
method, it would be more efficient to structure the code so that this
method is only called once; e.g.,</p>
<ul>
<li>If the tree is empty . . . .</li>
<li>Otherwise:
<ul>
<li>Get the result of the comparison.</li>
<li>If the result is 0 . . . .</li>
<li>Otherwise, if the result is negative . . . .</li>
<li>Otherwise . . . .</li>
</ul>
</li>
</ul>
<p>This method would need to take two parameters &mdash; the key we are looking
for and the tree we are looking in. This second parameter will actually
be a reference to a node, which will either be the root of the tree or
<strong>null</strong> if the tree is empty. Because this method requires a parameter
that is not provided to the <strong>TryGetValue</strong> method, this method would be
a <strong>private</strong> method that the <strong>TryGetValue</strong> method can call. This
<strong>private</strong> method would then return the node containing the key, or
<strong>null</strong> if this key was not found. The <strong>TryGetValue</strong> method can be
implemented easily using this <strong>private</strong> method.</p>
<p>We also need to be able to implement the <strong>Add</strong> method. Let&rsquo;s first
consider how to do this assuming we are representing our binary search
tree with immutable nodes. The first thing to observe is that because we
can&rsquo;t modify an immutable node, we will need to build a binary search
tree containing the nodes in the current tree, plus a new node
containing the new key and value. In order to accomplish this, we will
describe a <strong>private</strong> recursive method that returns the result of
adding a given key and value to a given binary search tree. The <strong>Add</strong>
method will then need to call this <strong>private</strong> method and save the
resulting tree.</p>
<p>We therefore want to design a <strong>private</strong> method that will take three
parameters:</p>
<ul>
<li>a binary search tree (i.e., reference to a node);</li>
<li>the key we want to add; and</li>
<li>the value we want to add.</li>
</ul>
<p>It will return the binary search tree that results from adding the given
key and value to the given tree.</p>
<p>This method again has four cases:</p>
<ul>
<li>The tree is empty. In this case, we need to construct a node
containing the given key and value and two empty children, and
return this node as the resulting tree.</li>
<li>The root of the tree contains a key equal to the given key. In this
case, we can&rsquo;t add the item - we need to throw an exception.</li>
<li>The given key is less than the key at the root. We can then use a
recursive call to add the given key and value to the left child. The
tree returned by the recursive call needs to be the left child of
the result to be returned by the method. We therefore construct a
new node containing the data and right child from the given tree,
but having the result of the recursive call as its left child. We
return this new node.</li>
<li>The given key is greater than the key at the root. We use a
recursive call to add it to the right child, and construct a new
node with the result of the recursive call as its right child. We
return this new node.</li>
</ul>
<p>Note that the above algorithm only adds the given data item when it
reaches an empty tree. Not only is this the most straightforward way to
add items, but it also tends to keep paths in the tree short, as each
insertion is only lengthening one path. 

<a href="https://github.com/RodHowell-Algorithms/Tree-Viewer" target="_blank" rel="noopener">This
page</a> contains an
application that will
show the result of adding a key at a time to a binary search tree.</p>

  
  
<div class="box notices cstyle warning">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
    <div class="box-content">
<p>The
keys in this application are treated as strings; hence, you can use
numbers if you want, but they will be compared as strings (e.g.,
&ldquo;10&rdquo; &lt; &ldquo;5&rdquo; because &lsquo;1&rsquo; &lt; &lsquo;5&rsquo;). For this reason, it is
usually better to use either letters, words, or integers that all have
the same number of digits.</p>
    </div>
</div>
<p>The above algorithm can be implemented in the same way if mutable binary
tree nodes are used; however, we can improve its performance a bit by
avoiding the construction of new nodes when recursive calls are made.
Instead, we can change the child to refer to the tree returned. If we
make this optimization, the tree we return will be the same one that we
were given in the cases that make recursive calls. However, we still
need to construct a new node in the case in which the tree is empty. For
this reason, it is still necessary to return the resulting tree, and we
need to make sure that the <strong>Add</strong> method always uses the returned tree.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Removing from a Binary Search Tree</h1></div>
<h2 id="removing-from-a-binary-search-tree">Removing from a Binary Search Tree</h2>
<p>Before we can discuss how to remove an element from a binary search
tree, we must first define exactly how we want the method to behave.
Consider first the case in which the tree is built from immutable nodes.
We are given a key and a binary search tree, and we want to return the
result of removing the element having the given key. However, we need to
decide what we will do if there is no element having the given key. This
does not seem to be exceptional behavior, as we may have no way of
knowing in advance whether the key is in the tree (unless we waste time
looking for it). Still, we might want to know whether the key was found.
We therefore need two pieces of information from this method - the
resulting tree and a <strong>bool</strong> indicating whether the key was found. In
order to accommodate this second piece of information, we make the
<strong>bool</strong> an 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/out-ref"><strong>out</strong> parameter</a>.</p>
<p>We can again break the problem into cases and use recursion, as we did
for 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/intro">adding an element</a>. However, removing an element is complicated by the fact that its node
might have two nonempty children. For example, suppose we want to remove
the element whose key is 54 in the following binary search tree:</p>
<p><img src="binary-search-tree-ex.jpg" alt="A binary search tree"></p>
<p>In order to preserve the correct ordering of the keys, we should replace
54 with either the next-smaller key (i.e., 41) or the next-larger key
(i.e., 64). By convention, we will replace it with the next-larger key,
which is the smallest key in its right child. We therefore have a
sub-problem to solve - removing the element with the smallest key from a
nonempty binary search tree. We will tackle this problem first.</p>
<p>Because we will not need to remove the smallest key from an empty tree,
we don&rsquo;t need to worry about whether the removal was successful - a
nonempty binary search tree always has a smallest key. However, we still
need two pieces of information from this method:</p>
<ul>
<li>the element removed (so that we can use it to replace the element to
be removed in the original problem); and</li>
<li>the resulting tree (so that we can use it as the new right child in
solving the original problem).</li>
</ul>
<p>We will therefore use an <strong>out</strong> parameter for the element removed, and
return the resulting tree.</p>
<p>Because we don&rsquo;t need to worry about empty trees, and because the
smallest key in a binary search tree is never larger than the key at the
root, we only have two cases:</p>
<ul>
<li>The left child is empty. In this case, there are no keys smaller
than the key at the root; i.e., the key at the root is the smallest.
We therefore assign the data at the root to the <strong>out</strong> parameter,
and return the right child, which is the result of removing the
root.</li>
<li>The left child is nonempty. In this case, there is a key smaller
than the key at the root; furthermore, it must be in the left child.
We therefore use a recursive call on the left child to obtain the
result of removing the element with the smallest key from that child. We
can pass as the <strong>out</strong> parameter to this recursive call the <strong>out</strong>
parameter that we were given - the recursive call will assign to it
the element removed. Because our nodes are immutable, we then need to construct a new node whose data
and right child are the same as in the given tree, but whose left
child is the tree returned by the recursive call. We return this
node.</li>
</ul>
<p>Having this sub-problem solved, we can now return to the original
problem. We again have four cases, but one of these cases breaks into
three sub-cases:</p>
<ul>
<li>The tree is empty. In this case the key we are looking for is not
present, so we set the <strong>out</strong> parameter to <strong>false</strong> and return an
empty tree.</li>
<li>The key we are looking for is at the root. In this case, we can set
the <strong>out</strong> parameter to <strong>true</strong>, but in order to remove the
element, we have three sub-cases:
<ul>
<li>The left child is empty. We can then return the right child (the
result of removing the root).</li>
<li>The right child is empty. We can then return the left child.</li>
<li>Both children are nonempty. We must then obtain the result of
removing the smallest key from the right child. We then
construct a new node whose data is the element removed from the
right child, the left child is the left child of the given tree,
and the right child is the result of removing the smallest key
from that child. We return this node.</li>
</ul>
</li>
<li>The key we are looking for is less than the key at the root. We then
obtain the result of removing this key from the left child using a
recursive call. We can pass as the <strong>out</strong> parameter to this
recursive call the <strong>out</strong> parameter we were given and let the
recursive call set its value. We then construct a new node whose
data and right child are the same as in the given tree, but whose
left child is the tree returned by the recursive call. We return
this node.</li>
<li>The key we are looking for is greater than the key at the root. This
case is symmetric to the above case.</li>
</ul>
<p>As we did with adding elements, we can optimize the methods described
above for mutable nodes by modifying the contents of a node rather than
constructing new nodes.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Inorder Traversal</h1></div>
<h2 id="inorder-traversal">Inorder Traversal</h2>
<p>When we store keys and values in an ordered dictionary, we typically
want to be able to process the keys in increasing order. The
&ldquo;processing&rdquo; that we do may be any of a number of things - for example,
writing the keys and values to a file or adding them to the end of a
list. Whatever processing we want to do, we want to do it increasing
order of keys.</p>
<p>If we are implementing the dictionary using a binary search tree, this
may at first seem to be a rather daunting task. Consider traversing the
keys in the following binary search tree in increasing order:</p>
<p><img src="binary-search-tree-ex.jpg" alt="A binary search tree"></p>
<p>Processing these keys in order involves frequent jumps in the tree, such
as from 17 to 23 and from 41 to 54. It may not be immediately obvious
how to proceed. However, if we just think about it with the purpose of
writing a recursive method, it actually becomes rather straightforward.</p>
<p>As with most tree-processing algorithms, if the given tree is nonempty,
we start at the root (if it is empty, there are no nodes to process).
However, the root isn&rsquo;t necessarily the first node that we want to
process, as there may be keys that are smaller than the one at the root.
These key are all in the left child. We therefore want to process first
all the nodes in the left child, in increasing order of their keys. This
is a smaller instance of our original problem - a recursive call on the
left child solves it. At this point all of the keys less than the one at
the root have been processed. We therefore process the root next
(whatever the &ldquo;processing&rdquo; might be). This just leaves the nodes in the
right child, which we want to process in increasing order of their keys.
Again, a recursive call takes care of this, and we are finished.</p>
<p>The entire algorithm is therefore as follows:</p>
<ul>
<li>If the given tree is nonempty:
<ul>
<li>Do a recursive call on the left child to process all the nodes
in it.</li>
<li>Process the root.</li>
<li>Do a recursive call on the right child to process all the nodes
in it.</li>
</ul>
</li>
</ul>
<p>This algorithm is known as an <em>inorder traversal</em> because it processes
the root between the processing of the two children. Unlike 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/intro">preorder
traversal</a>, this
algorithm only makes sense for binary trees, as there must be exactly
two children in order for &ldquo;between&rdquo; to make sense.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
          <article class="default">
<div hidden><h1>AVL Trees</h1></div>
<h2 id="avl-trees">AVL Trees</h2>
<p>Up to this point, we haven&rsquo;t addressed the performance of binary search
trees. In considering this performance, let&rsquo;s assume that the time
needed to compare two keys is bounded by some fixed constant. The main
reason we do this is that this cost doesn&rsquo;t depend on the number of keys
in the tree; however, it may depend on the sizes of the keys, as, for
example, if keys are <strong>string</strong>s. However, we will ignore this
complication for the purpose of this discussion.</p>
<p>Each of the methods we have described for finding a key, adding a key
and a value, or removing a key and its associated value, follows a
single path in the given tree. As a result, the time needed for each of
these methods is at worst proportional to the <em>height</em> of the tree,
where the height is defined to be the length of the longest path from
the root to any node. (Thus, the height of a one-node tree is <span style="white-space:nowrap">
<span class="math align-center">$ 0 $</span>,</span> because
no steps are needed to get from the root to the only node - the root
itself &mdash; and the height of a two-node tree is always <span style="white-space:nowrap">
<span class="math align-center">$ 1 $</span>.</span>) In other words,
we say that the worst-case running time of each of these methods is in
<span style="white-space:nowrap">
<span class="math align-center">$ O(h) $</span>,</span> where 
<span class="math align-center">$ h $</span> is the height of the tree.</p>
<p>Depending on the shape of the tree, 
<span class="math align-center">$ O(h) $</span> running time might be very
good. For example, it is possible to show that if keys are randomly
taken from a uniform distribution and successively added to an initially
empty binary search tree, the expected height is in <span style="white-space:nowrap">
<span class="math align-center">$ O(\log n) $</span>,</span>
where 
<span class="math align-center">$ n $</span> is the number of nodes. In this case, we would expect
logarithmic performance for lookups, insertions, and deletions. In fact,
there are many applications in which the height of a binary search tree
remains fairly small in comparison to the number of nodes.</p>
<p>On the other hand, such a shape is by no means guaranteed. For example,
suppose a binary search tree were built by adding the <strong>int</strong> keys 1
through 
<span class="math align-center">$ n $</span> in increasing order. Then 1 would go at the root, and 2
would be its right child. Each successive key would then be larger than
any key currently in the tree, and hence would be added as the right
child of the last node on the path going to the right. As a result, the
tree would have the following shape:</p>
<p><img src="bst-chain.jpg" alt="A badly-shaped binary search tree"></p>
<p>The height of this tree is <span style="white-space:nowrap">
<span class="math align-center">$ n - 1 $</span>;</span> consequently, lookups will
take time linear in <span style="white-space:nowrap">
<span class="math align-center">$ n $</span>,</span> the number of elements, in the worst case. This
performance is comparable with that of a linked list. In order to
guaranteed good performance, we need a way to ensure that the height of
a binary search tree does not grow too quickly.</p>
<p>One way to accomplish this is to require that each node always has
children that differ in height by at most <span style="white-space:nowrap">
<span class="math align-center">$ 1 $</span>.</span> In order for this
restriction to make sense, we need to extend the definition of the
height of a tree to apply to an empty tree. Because the height of a
one-node tree is <span style="white-space:nowrap">
<span class="math align-center">$ 0 $</span>,</span> we will define the height of an empty tree to be <span style="white-space:nowrap">
<span class="math align-center">$ -1 $</span>.</span>
We call this restricted form of a binary search tree an <em>AVL tree</em>
(&ldquo;AVL&rdquo; stands for the names of the inventors, Adelson-Velskii and
Landis).</p>
<p>

<a href="https://github.com/RodHowell-Algorithms/Min-AVL-Trees" target="_blank" rel="noopener">This repository</a>
contains a Java application that displays an AVL tree of a given
height using as few nodes as possible. For example, the following screen
capture shows an AVL tree of height 
<span class="math align-center">$ 7 $</span> having a minimum number of nodes:</p>
<p><img src="min-avl.jpg" alt="An AVL tree with height 7 and minimum number of nodes"></p>
<p>As the above picture illustrates, a minimum of 
<span class="math align-center">$ 54 $</span> nodes are required for
an AVL tree to reach a height of <span style="white-space:nowrap">
<span class="math align-center">$ 7 $</span>.</span> In general, it can be shown that the
height of an AVL tree is at worst proportional to <span style="white-space:nowrap">
<span class="math align-center">$ \log n $</span>,</span> where 
<span class="math align-center">$ n $</span>
is the number of nodes in the tree. Thus, if we can maintain the shape
of an AVL tree efficiently, we should have efficient lookups and
updates.</p>
<p>Regarding the AVL tree shown above, notice that the tree is not as
well-balanced as it could be. For example, 
<span class="math align-center">$ 0 $</span> is at depth <span style="white-space:nowrap">
<span class="math align-center">$ 7 $</span>,</span> whereas <span style="white-space:nowrap">
<span class="math align-center">$ 52 $</span>,</span>
which also has two empty children, is only at depth <span style="white-space:nowrap">
<span class="math align-center">$ 4 $</span>.</span> Furthermore, it
is possible to arrange 
<span class="math align-center">$ 54 $</span> nodes into a binary tree with height as small
as <span style="white-space:nowrap">
<span class="math align-center">$ 5 $</span>.</span> However, maintaining a more-balanced structure would likely
require more work, and as a result, the overall performance might not be
as good. As we will show in what follows, the balance criterion for an
AVL tree can be maintained without a great deal of overhead.</p>
<p>The first thing we should consider is how we can efficiently determine
the height of a binary tree. We don&rsquo;t want to have to explore the entire
tree to find the longest path from the root &mdash; this would be way too
expensive. Instead, we store the height of a tree
in its root. If our nodes are mutable, we should use a
<strong>public</strong> property with both <strong>get</strong> and <strong>set</strong> accessors for this purpose. However,
such a setup places the burden of maintaining the heights on the user of
the binary tree node class. Using immutable nodes allows a much cleaner
(albeit slightly less efficient) solution. In what follows, we will show
how to modify the definition of an immutable binary tree node so that
whenever a binary tree is created from such nodes, the resulting tree is
guaranteed to satisfy the AVL tree balance criterion. As a result, user
code will be able to form AVL trees as if they were ordinary binary
search trees.</p>
<p>In order to allow convenient and efficient access to the height, even
for empty trees, we can store the height of a tree in a <strong>private</strong> field in its root, and provide a <strong>static</strong> method to take a nullable binary
tree node as its only parameter and return its height. Making this
method <strong>static</strong> will allow us to handle empty (i.e., <strong>null</strong>) trees.
If the tree is empty, this method will return <span style="white-space:nowrap">
<span class="math align-center">$ -1 $</span>;</span> otherwise, it will
return the height stored in the tree. This method can be <strong>public</strong>.</p>
<p>We then can modify the constructor so that it initializes the height
field. Using the above method, it can find the heights of each child,
and add 
<span class="math align-center">$ 1 $</span> to the maximum of these values. This is the height of the node
being constructed. It can initialize the height field to this value, and
because the nodes are immutable, this field will store the correct
height from that point on.</p>
<p>Now that we have a way to find the height of a tree efficiently, we can
focus on how we maintain the balance property. Whenever an insertion or
deletion would cause the balance property to be violated for a
particular node, we perform a <em>rotation</em> at that node. Suppose, for
example, that we have inserted an element into a node&rsquo;s left child, and
that this operation causes the height of the new left child to be 
<span class="math align-center">$ 2 $</span>
greater than the height of the right child (note that this same scenario
could have occurred if we had removed an element from the right child).
We can then rotate the tree using a <em>single rotate right</em>:</p>
<p><img src="single-rotate.jpg" alt="A single rotate right"></p>
<p>The tree on the left above represents the tree whose left child has a
height 
<span class="math align-center">$ 2 $</span> greater than its right child. The root and the lines to its
children are drawn using dashes to indicate that the root node has not
yet been constructed &mdash; we have at this point simply built a new left
child, and the tree on the left shows the tree that would be formed if
we were building an ordinary binary search tree. The circles in the
picture indicate individual nodes, and the triangles indicate arbitrary
trees (which may be empty). Note that the because the left child has a
height 
<span class="math align-center">$ 2 $</span> greater than the right child, we know that the left child
cannot be empty; hence, we can safely depict it as a node with two
children. The labels are chosen to indicate the order of the elements &mdash;
e.g., as &ldquo;a&rdquo; 
<span class="math align-center">$ \lt $</span> &ldquo;b&rdquo;, every key in tree <em>a</em> is less than the key in
node <em>b</em>. The tree on the right shows the tree that would be built by
performing this rotation. Note that the rotation preserves the order of
the keys.</p>
<p>Suppose the name of our class implementing a binary tree node is
<strong>BinaryTreeNode&lt;T&gt;</strong>, and suppose it has the following properties:</p>
<ul>
<li><strong>Data:</strong> gets the data stored in the node.</li>
<li><strong>LeftChild:</strong> gets the left child of the node.</li>
<li><strong>RightChild:</strong> gets the right child of the node.</li>
</ul>
<p>Then the following code can be used to perform a single rotate right:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Builds the result of performing a single rotate right on the binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// described by the given root, left child, and right child.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;root&#34;&gt;The data stored in the root of the original tree.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;left&#34;&gt;The left child of the root of the original tree.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;right&#34;&gt;The right child of the root of the original tree.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;returns&gt;The result of performing a single rotate right on the tree described</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// by the parameters.&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> BinaryTreeNode&lt;T&gt; SingleRotateRight(T root,
</span></span><span style="display:flex;"><span>    BinaryTreeNode&lt;T&gt; left, BinaryTreeNode&lt;T&gt;? right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    BinaryTreeNode&lt;T&gt; newRight = <span style="color:#66d9ef">new</span>(root, left.RightChild, right);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> BinaryTreeNode&lt;T&gt;(left.Data, left.LeftChild, newRight);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Relating this code to the tree on the left in the picture above, the
parameter <code>root</code> refers to <em>d</em>, the parameter <code>left</code> refers to the tree
rooted at node <em>b</em>, and the parameter <code>right</code> refers to the (possibly empty) tree <em>e</em>. The
code first constructs the right child of the tree on the right and
places it in the variable <code>newRight</code>. It then constructs the entire tree
on the right and returns it.</p>

  
  
<div class="box notices cstyle warning">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div>
    <div class="box-content">
<p>Don&rsquo;t try to write the code for doing rotations without looking at pictures of the rotations.</p>
    </div>
</div>
<p>Now that we have seen what a single rotate right does and how to code
it, we need to consider whether it fixes the problem. Recall that we
were assuming that the given left child (i.e., the tree rooted at <em>b</em> in
the tree on the left above) has a height 
<span class="math align-center">$ 2 $</span> greater than the given right
child (i.e., the tree <em>e</em> in the tree on the left above). Let&rsquo;s suppose
the tree <em>e</em> has height <span style="white-space:nowrap">
<span class="math align-center">$ h $</span>.</span> Then the tree rooted at <em>b</em> has height
<span style="white-space:nowrap">
<span class="math align-center">$ h + 2 $</span>.</span> By the definition of the height of a tree, either <em>a</em>
or <em>c</em> (or both) must have height <span style="white-space:nowrap">
<span class="math align-center">$ h + 1 $</span>.</span> Assuming that every
tree we&rsquo;ve built so far is an AVL tree, the children of <em>b</em> must differ
in height by at most <span style="white-space:nowrap">
<span class="math align-center">$ 1 $</span>;</span> hence, <em>a</em> and <em>c</em> must both have a height of at
least 
<span class="math align-center">$ h $</span> and at most <span style="white-space:nowrap">
<span class="math align-center">$ h + 1 $</span>.</span></p>
<p>Given these heights, let&rsquo;s examine the tree on the right. We have
assumed that every tree we&rsquo;ve built up to this point is an AVL tree, so
we don&rsquo;t need to worry about any balances within <em>a</em>, <em>c</em>, or <em>e</em>.
Because <em>c</em> has either height 
<span class="math align-center">$ h $</span> or height 
<span class="math align-center">$ h + 1 $</span> and <em>e</em> has
height <span style="white-space:nowrap">
<span class="math align-center">$ h $</span>,</span> the tree rooted at <em>d</em> satisfies the balance criterion.
However, if <em>c</em> has height 
<span class="math align-center">$ h + 1 $</span> and <em>a</em> has height <span style="white-space:nowrap">
<span class="math align-center">$ h $</span>,</span> then
the tree rooted at <em>d</em> has height <span style="white-space:nowrap">
<span class="math align-center">$ h + 2 $</span>,</span> and the balance
criterion is <em>not</em> satisfied. On the other hand, if <em>a</em> has height
<span style="white-space:nowrap">
<span class="math align-center">$ h + 1 $</span>,</span> the tree rooted at <em>d</em> will have a height of either

<span class="math align-center">$ h + 1 $</span> or <span style="white-space:nowrap">
<span class="math align-center">$ h + 2 $</span>,</span> depending on the height of <em>c</em>. In these
cases, the balance criterion is satisfied.</p>
<p>We therefore conclude that a single rotate right will restore the
balance if:</p>
<ul>
<li>The height of the original left child (i.e., the tree rooted at <em>b</em>
in the above figure) is 
<span class="math align-center">$ 2 $</span> greater than the height of the original
right child (tree <em>e</em> in the above figure); and</li>
<li>The height of the left child of the original left child (tree <em>a</em> in
the above figure) is greater than the height of the original right
child (tree <em>e</em>).</li>
</ul>
<p>For the case in which the height of the left child of the original left
child (tree <em>a</em>) is <em>not</em> greater than the height of the original right
child (tree <em>e</em>), we will need to use a different kind of rotation.</p>
<p>Before we consider the other kind of rotation, we can observe that if an
insertion or deletion leaves the right child with a height 
<span class="math align-center">$ 2 $</span> greater
than the left child and the right child of the right child with a height
greater than the left child, the mirror image of a single rotate right
will restore the balance. This rotation is called a <em>single rotate
left</em>:</p>
<p><img src="single-rotate-left.jpg" alt="A single rotate left"></p>
<p>Returning to the case in which the left child has a height 
<span class="math align-center">$ 2 $</span> greater
than the right child, but the left child of the left child has a height
no greater than the right child, we can in this case do a <em>double rotate
right</em>:</p>
<p><img src="double-rotate.jpg" alt="A double rotate right"></p>
<p>Note that we have drawn the trees a bit differently by showing more
detail. Let&rsquo;s now show that this rotation restores the balance in this
case. Suppose that in the tree on the left, <em>g</em> has height <span style="white-space:nowrap">
<span class="math align-center">$ h $</span>.</span> Then the
tree rooted at <em>b</em> has height <span style="white-space:nowrap">
<span class="math align-center">$ h + 2 $</span>.</span> Because the height of <em>a</em>
is no greater than the height of <em>g</em>, assuming all trees we have built
so far are AVL trees, <em>a</em> must have height <span style="white-space:nowrap">
<span class="math align-center">$ h $</span>,</span> and the tree rooted at
<em>d</em> must have height 
<span class="math align-center">$ h + 1 $</span> (thus, it makes sense to draw it as
having a root node). This means that <em>c</em> and <em>e</em> both must have heights
of either 
<span class="math align-center">$ h $</span> or <span style="white-space:nowrap">
<span class="math align-center">$ h - 1 $</span>.</span> It is now not hard to verify that the
balance criterion is satisfied at <em>b</em>, <em>f</em>, and <em>d</em> in the tree on the
right.</p>
<p>The only remaining case is the mirror image of the above &mdash; i.e., that
the right child has height 
<span class="math align-center">$ 2 $</span> greater than the left child, but the height
of the right child of the right child is no greater than the height of
the left child. In this case, a <em>double rotate left</em> can be applied:</p>
<p><img src="double-rotate-left.jpg" alt="A double rotate left"></p>
<p>We have shown how to restore the balance whenever the balance criterion
is violated. Now we just need to put it all together in a <strong>public
static</strong> method that will replace the constructor as far as user code is
concerned. In order to prevent the user from calling the constructor
directly, we also need to make the constructor <strong>private</strong>. We want this
<strong>static</strong> method to take the same parameters as the constructor:</p>
<ul>
<li>The data item that can be stored at the root, provided no rotation
is required.</li>
<li>The tree that can be used as the left child if no rotation is
required.</li>
<li>The tree that can be used as the right child if no rotation is
required.</li>
</ul>
<p>The purpose of this method is to build a tree including all the given
nodes, with the given data item following all nodes in the left child
and preceding all nodes in the right child, but satisfying the AVL tree
balance criterion. Because this method will be the only way for user
code to build a tree, we can assume that both of the given trees satisfy
the AVL balance criterion. Suppose that the name of the <strong>static</strong>
method to get the height of a tree is <strong>Height</strong>, and that the names of
the methods to do the remaining rotations are <strong>SingleRotateLeft</strong>,
<strong>DoubleRotateRight</strong>, and <strong>DoubleRotateLeft</strong>, respectively. Further
suppose that the parameter lists for each of these last three methods
are the same as for <strong>SingleRotateRight</strong> above, except that for the left rotations, <code>left</code> is nullable, not <code>right</code>. The following method
can then be used to build AVL trees:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Constructs an AVL Tree from the given data element and trees. The heights of </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// the trees must differ by at most two. The tree built will have the same </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// inorder traversal order as if the data were at the root, left were the left </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// child, and right were the right child.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;data&#34;&gt;A data item to be stored in the tree.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;left&#34;&gt;An AVL Tree containing elements less than data.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;right&#34;&gt;An AVL Tree containing elements greater than data.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;returns&gt;The AVL Tree constructed.&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> BinaryTreeNode&lt;T&gt; GetAvlTree(T data, BinaryTreeNode&lt;T&gt;? left,
</span></span><span style="display:flex;"><span>    BinaryTreeNode&lt;T&gt;? right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> diff = Height(left) - Height(right);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Math.Abs(diff) &gt; <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (diff == <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the heights differ by 2, left&#39;s height is at least 1; hence, it isn&#39;t null.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Height(left!.LeftChild) &gt; Height(right))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> SingleRotateRight(data, left, right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the heights differ by 2, but left.LeftChild&#39;s height is no more than</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// right&#39;s height, then left.RightChild&#39;s height must be greater than right&#39;s</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// height; hence, left.RightChild isn&#39;t null.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> DoubleRotateRight(data, left, right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (diff == -<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the heights differ by -2, right&#39;s height is at least 1; hence, it isn&#39;t null.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Height(right!.RightChild) &gt; Height(left))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> SingleRotateLeft(data, left, right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the heights differ by -1, but right.RightChild&#39;s height is no more than </span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// left&#39;s height, then right.LeftChild&#39;s height must be greater than right&#39;s </span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// height; hence right.LeftChild isn&#39;t null.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> DoubleRotateLeft(data, left, right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> BinaryTreeNode&lt;T&gt;(data, left, right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to build and maintain an AVL tree, user code simply needs to
call the above wherever it would have invoked the
<strong>BinaryTreeNode&lt;T&gt;</strong> constructor in building and maintaining an
ordinary binary search tree. The extra overhead is fairly minimal &mdash; each
time a new node is constructed, we need to check a few heights (which
are stored in fields), and if a rotation is needed, construct one or two
extra nodes. As a result, because the height of an AVL tree is
guaranteed to be logarithmic in the number of nodes, the worst-case
running times of both lookups and updates are in <span style="white-space:nowrap">
<span class="math align-center">$ O(\log n) $</span>,</span> where

<span class="math align-center">$ n $</span> is the number of nodes in the tree.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Tries</h1></div>
<h2 id="tries">Tries</h2>
<p>

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">AVL trees</a> give us an efficient mechanism for storage and  retrieval, particularly if we need to be able to process the elements in order of their keys.  However, there are special cases where we can achieve better performance.  One of these special cases occurs when we need to store a list of words, as we might need in a word game, for example.  For such applications, a <em>trie</em> provides for even more efficient storage and retrieval.</p>
<p>In this section, we first define a trie and give a rather straightforward implementation.  We then show how to improve performance by implementing different nodes in different ways. We then examine the use of a preorder traversal to traverse a trie.  We conclude by discussing an example of using a trie in a word game.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
          <article class="default">
<div hidden><h1>Introduction to Tries</h1></div>
<h2 id="introduction-to-tries">Introduction to Tries</h2>
<p>A <em>trie</em> is a nonempty tree storing a set of words in the following way:</p>
<ul>
<li>Each child of a node is labeled with a character.</li>
<li>Each node contains a boolean indicating whether the labels in the
path from the root to that node form a word in the set.</li>
</ul>
<p>The word, &ldquo;trie&rdquo;, is taken from the middle of the word, &ldquo;retrieval&rdquo;, but
to avoid confusion, it is pronounced like &ldquo;try&rdquo; instead of like &ldquo;tree&rdquo;.</p>
<p>Suppose, for example, that we want to store the following words:</p>
<ul>
<li>ape</li>
<li>apple</li>
<li>cable</li>
<li>car</li>
<li>cart</li>
<li>cat</li>
<li>cattle</li>
<li>curl</li>
<li>far</li>
<li>farm</li>
</ul>
<p>A trie storing these words (where we denote a value of <strong>true</strong> for the
boolean with a <code>*</code>) is as follows:</p>
<p><img src="trie-example.jpg" alt="A trie"></p>
<p>Thus, for example, if we follow the path from the root through the
labels &lsquo;c&rsquo;, &lsquo;a&rsquo;, and &lsquo;r&rsquo;, we reach a node with a <strong>true</strong> boolean value
(shown by the <code>*</code> in the above picture); hence, &ldquo;car&rdquo; is in this set of
words. However, if we follow the path through the labels &lsquo;c&rsquo;, &lsquo;u&rsquo;, and
&lsquo;r&rsquo;, the node we reach has a <strong>false</strong> boolean; hence, &ldquo;cur&rdquo; is not in
this set. Likewise, if we follow the path through &lsquo;a&rsquo;, we reach a node
from which there is no child labeled &lsquo;c&rsquo;; hence, &ldquo;ace&rdquo; is not in this
set.</p>
<p>Note that each subtree of a trie is also a trie, although the &ldquo;words&rdquo; it
stores may begin to look a little strange. For example if we follow the
path through &lsquo;c&rsquo; and &lsquo;a&rsquo; in the above figure, we reach a trie that
contains the following &ldquo;words&rdquo;:</p>
<ul>
<li>&ldquo;ble&rdquo;</li>
<li>&ldquo;r&rdquo;</li>
<li>&ldquo;rt&rdquo;</li>
<li>&ldquo;t&rdquo;</li>
<li>&ldquo;ttle&rdquo;</li>
</ul>
<p>These are actually the <em>completions</em> of the original words that begin
with the prefix &ldquo;ca&rdquo;. Note that if, in this subtree, we take the path
through &rsquo;t&rsquo;, we reach a trie containing the following completions:</p>
<ul>
<li>&quot;&quot; [i.e., the empty string]</li>
<li>&ldquo;tle&rdquo;</li>
</ul>
<p>In particular, the empty string is a word in this trie. This motivates
an alternative definition of the boolean stored in each node: it
indicates whether the empty string is stored in the trie rooted at this
node. This definition may be somewhat preferable to the one given above,
as it does not depend on any context, but instead focuses entirely on
the trie rooted at that particular node.</p>
<p>One of the main advantages of a trie over an 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">AVL
tree</a> is the speed with
which we can look up words. Assuming we can quickly find the child with
a given label, the time we need to look up a word is proportional to the
length of the word, no matter how many words are in the trie. Note that
in looking up a word that is present in an AVL tree, we will at least
need to compare the given word with its occurrence in the tree, in
addition to any other comparisons done during the search. The time it
takes to do this one comparison is proportional to the length of the
word, as we need to verify each character (we actually ignored the cost
of such comparisons when we analyzed the performance of AVL trees).
Consequently, we can expect a significant performance improvement by
using a trie if our set of words is large.</p>
<p>Let&rsquo;s now consider how we can implement a trie. There are various ways
that this can be done, but we&rsquo;ll consider a fairly straightforward
approach in this section (we&rsquo;ll improve the implementation in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/multiple-impl">the next
section</a>). We
will assume that the words we are storing are comprised of only the 26
lower-case English letters. In this implementation, a single node will
contain the following <strong>private</strong> fields:</p>
<ul>
<li>A <strong>bool</strong> storing whether the empty string is contained in the trie
rooted at this node (or equivalently, whether this node ends a word
in the entire trie).</li>
<li>A 26-element array of nullable tries storing the children, where element 0
stores the child labeled &lsquo;a&rsquo;, element 1 stores the child labeled
&lsquo;b&rsquo;, etc. If there is no child with some label, the corresponding
array element is <strong>null</strong>.</li>
</ul>
<p>For maintainability, we should use <strong>private</strong> constants to store the above array&rsquo;s size (i.e., 26) and the first letter of the alphabet (i.e., &lsquo;a&rsquo;). Note that in this implementation, other than this last constant, no <strong>char</strong>s or <strong>string</strong>s are
actually stored. We can see if a node has a child labeled by a given
<strong>char</strong> by finding the difference between that <strong>char</strong> and and the first letter of the alphabet, and
using that difference as the array index. For example, suppose the array
field is named <code>_children</code>, the constant giving the first letter of the alphabet is <code>_alphabetStart</code>, and <code>label</code> is a <strong>char</strong> variable
containing a lower-case letter. Because <strong>char</strong> is technically a
numeric type, we can perform arithmetic with <strong>char</strong>s; thus, we can
obtain the child labeled by <code>label</code> by retrieving
<code>_children[label - _alphabetStart]</code>. More specifically, if <code>_alphabetStart</code> is &lsquo;a&rsquo; and <code>label</code>
contains &rsquo;d&rsquo;, then the difference, <code>label - _alphabetStart</code>, will be 3; hence,
the child with label &rsquo;d&rsquo; will be stored at index 3. We have therefore
achieved our goal of providing quick access to a child with a given
label.</p>
<p>Let&rsquo;s now consider how to implement a lookup. We can define a <strong>public</strong>
method for this purpose within the class implementing a trie node:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Contains(<span style="color:#66d9ef">string</span> s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    . . .
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>This method does not need a trie node as a parameter because
the method will belong to a trie node. Thus, the method will be able to
access the node as


<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/static-this"><strong>this</strong></a>, and may
access its <strong>private</strong> fields directly by their names.</p>
    </div>
</div>
<p>The method
consists of five cases:</p>
<ul>
<li><code>s</code> is <strong>null</strong>. Note that even though <code>s</code> is not defined to be nullable, because the method is <strong>public</strong>, user code could still pass a <strong>null</strong> value. In this case, we should throw an <strong>ArgumentNullException</strong>, provides more information than does a <strong>NullReferenceException</strong>.</li>
<li><code>s</code> is the empty <strong>string</strong>. In this case the <strong>bool</strong> stored in
this node indicates whether it is a word in this trie; hence, we can
simply return this <strong>bool</strong>.</li>
<li>The first character of <code>s</code> is not a lower-case English letter (i.e.,
it is less than &lsquo;a&rsquo; or greater than &lsquo;z&rsquo;). The constants defined for this class should be used in making this determination. In this case, <code>s</code> can&rsquo;t be stored
in this trie; hence, we can return <strong>false</strong>.</li>
<li>The child labeled with the first character of <code>s</code> (obtained as
described above) is missing (i.e., is <strong>null</strong>). Then <code>s</code> isn&rsquo;t
stored in this trie. Again, we return <strong>false</strong>.</li>
<li>The child labeled with the first character of <code>s</code> is present (i.e.,
non-<strong>null</strong>). In this case, we need to determine whether the
substring following the first character of <code>s</code> is in the trie rooted
at the child we retrieved. This can be found using a recursive call
to this method within the child trie node. We return the result of
this recursive call.</li>
</ul>
<p>In order to be able to look up words, we need to be able to build a trie
to look in. We therefore need to be able to add words to a trie. It&rsquo;s
not practical to make a trie node immutable, as there is too much
information that would need to be copied if we need to replace a node
with a new one (we would need to construct a new node for each letter of
each word we added). We therefore should provide a <strong>public</strong> method
within the trie node class for the purpose of adding a word to the trie
rooted at this node:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Add(<span style="color:#66d9ef">string</span> s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    . . .
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This time there are four cases:</p>
<ul>
<li><code>s</code> is <strong>null</strong>. This case should be handled as in the <strong>Contains</strong> method above.</li>
<li><code>s</code> is the empty <strong>string</strong>. Then we can record this word by setting
the <strong>bool</strong> in this node to <strong>true</strong>.</li>
<li>The first character of <code>s</code> is not a lower-case English letter. Then
we can&rsquo;t add the word. In this case, we&rsquo;ll need to throw an
exception.</li>
<li>The first character is a lower-case English letter. In this case, we
need to add the substring following the first character of <code>s</code> to
the child labeled with the first letter. We do this as follows:
<ul>
<li>We first need to make sure that the child labeled with the first letter of <code>s</code> is non-<strong>null</strong>. Thus, if this child is <strong>null</strong>, we construct a new trie node and place
it in the array location for this child.</li>
<li>We can now
add the substring following the first letter of <code>s</code> to this child by
making a recursive call.</li>
</ul>
</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Multiple Implementations of Children</h1></div>
<h2 id="multiple-implementations-of-children">Multiple Implementations of Children</h2>
<p>The trie implementation given in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a> offers very
efficient lookups - a word of length 
<span class="math align-center">$ m $</span> can be looked up in 
<span class="math align-center">$ O(m) $</span>
time, no matter how many words are in the trie. However, it wastes a
large amount of space. In a typical trie, a majority of the nodes will
have no more than one child; however, each node contains a 26-element
array to store its children. Furthermore, each of these arrays is
automatically initialized so that all its elements are <strong>null</strong>. This
initialization takes time. Hence, building a trie may be rather
inefficient as well.</p>
<p>We can implement a trie more efficiently if we can customize the
implementation of a node based on the number of children it has. Because
most of the nodes in a trie can be expected to have either no children
or only one child, we can define alternate implementations for these
special cases:</p>
<ul>
<li>For a node with no children, there is no need to represent any
children - we only need the <strong>bool</strong> indicating whether the trie
rooted at this node contains the empty <strong>string</strong>.</li>
<li>For a node with exactly one child, we maintain a single reference to
that one child. If we do this, however, we won&rsquo;t be able to infer
the child&rsquo;s label from where we store the child; hence, we also need
to have a <strong>char</strong> giving the child&rsquo;s label. We also need the
<strong>bool</strong> indicating whether the trie rooted at this node contains
the empty <strong>string</strong>.</li>
</ul>
<p>For all other nodes, we can use an implementation similar to the one
outlined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a>. We will still
waste some space with the nodes having more than one child but fewer
than 26; however, the amount of space wasted will now be much less.
Furthermore, in each of these three implementations, we can quickly
access the child with a given label (or determine that there is no such
child).</p>
<p>Conceptually, this sounds great, but we run into some obstacles as soon
as we try to implement this approach. Because we are implementing nodes
in three different ways, we need to define three different classes. Each
of these classes defines a different type. So how do we build a trie
from three different types of nodes? In particular, how do we define the
type of a child when that child may be any of three different types?</p>
<p>The answer is to use a C# construct called an <em>interface</em>. An interface
facilitates <em>abstraction</em> - hiding lower-level details in order to focus
on higher-level details. At a high level (i.e., ignoring the specific
implementations), these three different classes appear to be the same:
they are all used to implement tries of words made up of lower-case
English letters. More specifically, we want to be able to add a
<strong>string</strong> to any of these classes, as well as to determine whether they
contain a given <strong>string</strong>. An interface allows us to define a type that
has this functionality, and to define various sub-types that have
different implementations, but still have this functionality.</p>
<p>A simple example of an interface is


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=net-6.0" target="_blank" rel="noopener"><strong>IComparable&lt;T&gt;</strong></a>.
Recall from the section, 

<a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/linked-list-impl">&ldquo;Implementing a Dictionary with a Linked
List&rdquo;</a>,
that we can constrain the keys in a dictionary implementation to be of a
type that can be ordered by using a <strong>where</strong> clause on the <strong>class</strong>
statement, as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dictionary</span>&lt;TKey, TValue&gt; <span style="color:#66d9ef">where</span> TKey : notnull, IComparable&lt;TKey&gt;
</span></span></code></pre></div><p>The 

<a href="https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/IComparable.cs,3911354c40e0c30e" target="_blank" rel="noopener">source code for the <strong>IComparable&lt;T&gt;</strong>
interface</a>
has been posted by Microsoft®. The essential part of this definition
is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IComparable</span>&lt;<span style="color:#66d9ef">in</span> T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> CompareTo(T? other);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>(Don&rsquo;t worry about the <strong>in</strong> keyword with the type parameter in the
first line.) This definition defines the type <strong>IComparable&lt;T&gt;</strong> as
having a method <strong>CompareTo</strong> that takes a parameter of the generic type
<strong>T?</strong> and returns an <strong>int</strong>. Note that there is no <strong>public</strong> or
<strong>private</strong> access modifier on the method definition. This is because
access modifiers are disallowed within interfaces &mdash; all definitions are
implicitly <strong>public</strong>. Note also that there is no actual definition of
the <strong>CompareTo</strong> method, but only a header followed by a semicolon.
Definitions of method bodies are also disallowed within interfaces &mdash; an
interface doesn&rsquo;t define the behavior of a method, but only how it
should be used (i.e., its parameter list and return type). For this
reason, it is impossible to construct an instance of an interface
directly. Instead, one or more sub-types of the interface must be
defined, and these sub-types must provide definitions for the behavior
of <strong>CompareTo</strong>. As a result, because the <strong>Dictionary&lt;TKey,
TValue&gt;</strong> class restricts type <strong>TKey</strong> to be a sub-type of
<strong>IComparable&lt;T&gt;</strong>, its can use the <strong>CompareTo</strong> method of any
instance of type <strong>TKey</strong>.</p>
<p>Now suppose that we want to define a class <strong>Fraction</strong> and use it as a
key in our dictionary implementation. We would begin the class
definition within Visual Studio® as follows:</p>
<img src="interface-example1.jpg" alt="Beginning an implementation of an interface." style="zoom:67%;" />
<p>At the end of the first line of the <strong>class</strong> definition, <code>: IComparable&lt;Fraction&gt;</code> indicates that the class being defined is a
subtype of <strong>IComparable&lt;Fraction&gt;</strong>. In general, we can list one or
more interface names after the colon, separating these names with
commas. Each name that we list requires that all of the methods,
properties, and 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/indexers">indexers</a>
from that interface must be fully defined within this class. If we hover
the mouse over the word, <code>IComparable&lt;Fraction&gt;</code>, a drop-down menu
appears. By selecting &ldquo;Implement interface&rdquo; from this menu, all of the
required members of the interface are provided for us:</p>
<img src="interface-example2.jpg" alt="Interface members are auto-filled." style="zoom:67%;" />

  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>In order to implement a method specified in an interface, we
must define it as <strong>public</strong>.</p>
    </div>
</div>
<p>We now just need to replace the <strong>throw</strong>
with the proper code for the <strong>CompareTo</strong> method and fill in any other
class members that we need; for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> Ksu.Cis300.Fractions
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// An immutable fraction whose instances can be ordered.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span> : IComparable&lt;Fraction&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// Gets the numerator.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Numerator { <span style="color:#66d9ef">get</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// Gets the denominator.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Denominator { <span style="color:#66d9ef">get</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// Constructs a new fraction with the given numerator and denominator.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;param name=&#34;numerator&#34;&gt;The numerator.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;param name=&#34;denominator&#34;&gt;The denominator.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> Fraction(<span style="color:#66d9ef">int</span> numerator, <span style="color:#66d9ef">int</span> denominator)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (denominator &lt;= <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Numerator = numerator;
</span></span><span style="display:flex;"><span>            Denominator = denominator;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// Compares this fraction with the given fraction.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;param name=&#34;other&#34;&gt;The fraction to compare to.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// &lt;returns&gt;A negative value if this fraction is less</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// than other, 0 if they are equal, or a positive value if this</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/// fraction is greater than other or if other is null.&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> CompareTo(Fraction? other)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (other == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> prod1 = (<span style="color:#66d9ef">long</span>)Numerator * other.Denominator;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">long</span> prod2 = (<span style="color:#66d9ef">long</span>)other.Numerator * Denominator;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> prod1.CompareTo(prod2);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Other class members</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>The <strong>CompareTo</strong> method above is <em>not</em> recursive. The
<strong>CompareTo</strong> method that it calls is a member of the <strong>long</strong>
structure, not the <strong>Fraction</strong> class.</p>
    </div>
</div>
<p>As we suggested above, interfaces can also include properties. For
example,


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1?view=net-6.0" target="_blank" rel="noopener"><strong>ICollection&lt;T&gt;</strong></a>
is a generic interface implemented by both arrays and the class
<span style="white-space:nowrap">

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0" target="_blank" rel="noopener"><strong>List&lt;T&gt;</strong></a>.</span>
This interface contains the following member (among others):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> Count { <span style="color:#66d9ef">get</span>; }
</span></span></code></pre></div><p>This member specifies that every subclass must contain a property called
<strong>Count</strong> with a getter. At first, it would appear that an array does
not have such a property, as we cannot write something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] a = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> k = a.Count;  <span style="color:#75715e">// This gives a syntax error.</span>
</span></span></code></pre></div><p><span id="explicit-impl"></span> In fact, an array does contain a
<strong>Count</strong> property, but this property is available only when the array
is treated as an <strong>ICollection&lt;T&gt;</strong> (or an
<span style="white-space:nowrap">

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1?view=net-6.0" target="_blank" rel="noopener"><strong>IList&lt;T&gt;</strong></a>,</span>
which is an interface that is a subtype of <strong>ICollection&lt;T&gt;</strong>, and is
also implemented by arrays). For example, we can write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] a = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>ICollection&lt;<span style="color:#66d9ef">int</span>&gt; col = a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> k = col.Count;
</span></span></code></pre></div><p>or</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">int</span>[] a = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> k = ((ICollection&lt;<span style="color:#66d9ef">int</span>&gt;)a).Count;
</span></span></code></pre></div><p>This behavior occurs because an array <em>explicitly implements</em> the
<strong>Count</strong> property. We can do this as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExplicitImplementationExample</span>&lt;T&gt; : ICollection&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ICollection&lt;T&gt;.Count
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">get</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Code to return the proper value</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Other class members</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Thus, if we create an instance of
<strong>ExplicitImplementationExample&lt;T&gt;</strong>, we cannot access its <strong>Count</strong>
property unless we either store it in a variable of type
<strong>ICollection&lt;T&gt;</strong> or cast it to this type. Note that whereas the
<strong>public</strong> access modifier is required when implementing an interface
member, neither the <strong>public</strong> nor the <strong>private</strong> access modifier is
allowed when <em>explicitly</em> implementing an interface member.</p>
<p>We can also include


<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/indexers">indexers</a> within
interfaces. For example, the <strong>IList&lt;T&gt;</strong> interface is defined as
follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">IList</span>&lt;T&gt; : ICollection&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    T <span style="color:#66d9ef">this</span>[<span style="color:#66d9ef">int</span> index] { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> IndexOf(T item);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> Insert(<span style="color:#66d9ef">int</span> index, T item);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> RemoveAt(<span style="color:#66d9ef">int</span> index);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>: ICollection&lt;T&gt;</code> at the end of the first line specifies that
<strong>IList&lt;T&gt;</strong> is a subtype of <strong>ICollection&lt;T&gt;</strong>; thus, the interface
includes all members of <strong>ICollection&lt;T&gt;</strong>, plus the ones listed. The
first member listed above specifies an indexer with a get accessor and a
set accessor.</p>
<p>Now that we have seen a little of what interfaces are all about, let&rsquo;s
see how we can use them to provide three different implementations of
trie nodes. We first need to define an interface, which we will call
<strong>ITrie</strong>, specifying the two <strong>public</strong> members of 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">our previous
implementation of a trie
node</a>. We do, however,
need to make one change to the way the <strong>Add</strong> method is called. This
change is needed because when we add a <strong>string</strong> to a trie, we may need
to change the implementation of the root node. We can&rsquo;t simply change
the type of an object - instead, we&rsquo;ll need to construct a new instance
of the appropriate implementation. Hence, the <strong>Add</strong> method will need
to return the root of the resulting trie. Because this node may have any
of the three implementations, the return type of this method should be
<strong>ITrie</strong>. Also, because we will need the constants from our previous implementation in each of the implementations of <strong>ITrie</strong>, the code will be more maintainable if we include them once within this interface definition. Note that this will have the effect of making them <strong>public</strong>. The <strong>ITrie</strong> interface is therefore as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// An interface for a trie.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ITrie</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The first character of the alphabet we use.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> AlphabetStart = <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The number of characters in the alphabet.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> AlphabetSize = <span style="color:#ae81ff">26</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Determines whether this trie contains the given string.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;s&#34;&gt;The string to look for.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;returns&gt;Whether this trie contains s.&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> Contains(<span style="color:#66d9ef">string</span> s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Adds the given string to this trie.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;s&#34;&gt;The string to add.&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;returns&gt;The resulting trie.&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span>    ITrie Add(<span style="color:#66d9ef">string</span> s);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We will then need to define three classes, each of which implements the
above interface. We will use the following names for these classes:</p>
<ul>
<li><strong>TrieWithNoChildren</strong> will be used for nodes with no children.</li>
<li><strong>TrieWithOneChild</strong> will be used for nodes with exactly one child.</li>
<li><strong>TrieWithManyChildren</strong> will be used for all other nodes; this will
be the class described in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a> with a few
modifications.</li>
</ul>
<p>These three classes will be similar because they each will implement the
<strong>ITrie</strong> interface. This implies that they will each need a
<strong>Contains</strong> method and an <strong>Add</strong> method as specified by the interface
definition. However, the code for each of these methods will be
different, as will other aspects of the implementations. For example,
the <strong>TrieWithNoChildren</strong> and <strong>TrieWithOneChild</strong> classes need
<strong>private</strong> fields as described at the beginning of this section,
whereas the <strong>TrieWithManyChildren</strong> classes needs the same <strong>private</strong>
fields as outlined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a>. In each case,
whenever we need to refer to a trie, we will use the type <strong>ITrie</strong>.</p>
<p>The <strong>Add</strong> methods for both <strong>TrieWithNoChildren</strong> and
<strong>TrieWithOneChild</strong> will need to be able to construct instances of
<strong>TrieWithOneChild</strong> and <strong>TrieWithManyChildren</strong>, respectively, when
they have no room for the <strong>string</strong> being added. The instances they
will need to construct will need information regarding the <strong>string</strong>s
already being stored, plus the <strong>string</strong> being added; hence, we will
need to define constructors for both <strong>TrieWithOneChild</strong> and
<strong>TrieWithManyChildren</strong>. Each of these constructors will need to take
the <strong>string</strong> being added as one of its parameters. Because the
instance being constructed also needs to retain all of the information
stored in the implementation that calls it, additional parameters for
each of these constructors will correspond to the <strong>private</strong> fields of
the implementation that will need to call it.</p>
<p>Thus, the parameters for the <strong>TrieWithOneChild</strong> constructor will be a
<strong>string</strong> to be stored (i.e., the one being added) and a <strong>bool</strong>
indicating whether the empty <strong>string</strong> is also to be stored (i.e.,
because it was stored in the original <strong>TrieWithNoChildren</strong>).
Furthermore, because the empty <strong>string</strong> can always be added to a
<strong>TrieWithNoChildren</strong> without constructing a new node, this constructor
should never be passed the empty <strong>string</strong>. The constructor can then
operate as follows:</p>
<ul>
<li>If the given <strong>string</strong> is <strong>null</strong>, throw an <strong>ArgumentNullException</strong>.</li>
<li>If the given <strong>string</strong> is empty or begins with a character that is
not a lower-case English letter, throw an exception.</li>
<li>Initialize the <strong>bool</strong> field with the given <strong>bool</strong>.</li>
<li>Initialize the <strong>char</strong> field with the first character of the given
<strong>string</strong>.</li>
<li>Initialize the <strong>ITrie</strong> field with the result of constructing a new
<strong>TrieWithNoChildren</strong> and adding to it the substring of the given
<strong>string</strong> following the first character.</li>
</ul>
<p>The parameters for the <strong>TrieWithManyChildren</strong> constructor will need to
be a <strong>string</strong> to be stored (i.e., the one being added), a <strong>bool</strong>
indicating whether the empty <strong>string</strong> is to be stored, a <strong>char</strong>
giving the label of a child, and an <strong>ITrie</strong> giving a child (these last
three parameters will come from the original <strong>TrieWithOneChild</strong>). It
can use the last three parameters to initialize its <strong>bool</strong> field and
one of its children (computing the child&rsquo;s index as in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a>). It can then
use its own <strong>Add</strong> method to add the given <strong>string</strong>, as there will
always be room to add a <strong>string</strong> to this implementation; hence, it can
ignore the value returned by the <strong>Add</strong> method. Furthermore, because
the <strong>Add</strong> method does error checking on the given <strong>string</strong>, the only
error checking this constructor needs to do is to check that neither the given <strong>string</strong> nor the given <strong>ITrie</strong> is <strong>null</strong>, and to
verify that the given <strong>char</strong> is a lower-case English letter.</p>
<p>Aside from replacing the constants with those defined in the <strong>ITrie</strong> interface, the <strong>Contains</strong> method for <strong>TrieWithManyChildren</strong> can be exactly the
same as for the implementation in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a>. For the other
two classes, the structure of the method is similar. Specifically, the
empty <strong>string</strong> needs to be handled first (after checking that the <strong>string</strong> isn&rsquo;t <strong>null</strong>) and in exactly the same way,
as the empty <strong>string</strong> is represented in the same way in all three
implementations. Nonempty <strong>string</strong>s, however, are represented
differently, and hence need to be handled differently. This is easy for
the <strong>TrieWithNoChildren</strong> class, as this implementation can&rsquo;t store a
nonempty <strong>string</strong>; hence, its <strong>Contains</strong> method should simply return
<strong>false</strong> when the given <strong>string</strong> is nonempty. For <strong>TrieWithOneChild</strong>, we need to check to
see if the first character of the given <strong>string</strong> matches the child&rsquo;s
label. If so, we can recursively look for the remainder of the
<strong>string</strong> in that child. Otherwise, we should simply return <strong>false</strong>,
as this <strong>string</strong> is not in this trie.</p>
<p>The <strong>Add</strong> method for <strong>TrieWithManyChildren</strong> needs some modification
from the description given in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a>. The most significant change is that this
method must return the resulting trie, which will always be <strong>this</strong>, as
this implementation never needs to be replaced by another to accommodate
a new <strong>string</strong>. Also, the names of the constants need to be replaced by the constants defined in the <strong>ITrie</strong> interface. Finally, where a
new child is constructed, it should be a
<strong>TrieWithNoChildren</strong>, but any other occurrences of the type <strong>Trie</strong> should be replaced with <strong>ITrie</strong>.</p>
<p>The <strong>Add</strong> method for <strong>TrieWithNoChildren</strong> will need to handle a <strong>null</strong> or
empty <strong>string</strong> in the same way as the above <strong>Add</strong> method. However,
this implementation cannot store a nonempty <strong>string</strong>. In this case, it
will need to construct and return a new <strong>TrieWithOneChild</strong> containing
the <strong>string</strong> to be added and the <strong>bool</strong> stored in this node.</p>
<p>The <strong>Add</strong> method for <strong>TrieWithOneChild</strong> will need five cases:</p>
<ul>
<li>A <strong>null string</strong>: This case can be handled in the same way as for the other two classes.</li>
<li>The empty <strong>string</strong>: This case can be handled in the same way as
for the other two classes.</li>
<li>A nonempty <strong>string</strong> whose first character is not a lower-case letter: An exception should be thrown.</li>
<li>A nonempty <strong>string</strong> whose first character matches the child&rsquo;s
label: The remainder of the <strong>string</strong> can be added to the child
using the child&rsquo;s <strong>Add</strong> method. Because this method may return a
different node, we need to replace the child with the value this
method returns. We can then return <strong>this</strong>, as we didn&rsquo;t need more
room for the given <strong>string</strong>.</li>
<li>A nonempty <strong>string</strong> whose first character is a lower-case letter but does not match the
child&rsquo;s label. In this case, we need to return a new
<strong>TrieWithManyChildren</strong> containing the given <strong>string</strong> and all of
the information already being stored.</li>
</ul>
<p>Code that uses such a trie will need to refer to it as an <strong>ITrie</strong>
whenever possible. The only exception to this rule occurs when we are
constructing a new trie, as we cannot construct an instance of an
interface. Here, we want to construct the simplest implementation &mdash; a
<strong>TrieWithNoChildren</strong>. Otherwise, the only difference in usage as
compared to the implementation of 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">the previous
section</a> is that the
<strong>Add</strong> method now returns the resulting trie, whose root may be a
different object; hence, we will need to be sure to replace the current
trie with whatever the <strong>Add</strong> method returns.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Traversing a Trie</h1></div>
<h2 id="traversing-a-trie">Traversing a Trie</h2>
<p>As with other kinds of trees, there are occasions where we need to
process all the elements stored in a trie in order. Here, the elements
are strings, which are not stored explicitly in the trie, but implicitly
based on the labels of various nodes. Thus, an individual node does not
contain a <strong>string</strong>; however, if its <strong>bool</strong> has a value of <strong>true</strong>,
then the path to that node describes a string stored in the trie. We can
therefore associate this string with this node. Note that this string is
a prefix of any string associated with any node in any of this node&rsquo;s
children; hence, it is alphabetically less than any string found in any
of the children. Thus, in order to process each of the strings in
alphabetic order, we need to do a 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro">preorder
traversal</a>, which
processes the root before recursively processing the children.</p>
<p>In order to process the string associated with a node, we need to be
able to retrieve this string. Because we will have followed the path
describing this string in order to get to the node associated with it,
we can build this string on the way to the node and pass it as a
parameter to the preorder traversal of the trie rooted at this node.
Because we will be building this string a character at a time, to do
this efficiently we should use a


<a href="https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilders"><strong>StringBuilder</strong></a>
instead of a <strong>string</strong>. Thus, the preorder traversal method for a trie
will take a <strong>StringBuilder</strong> parameter describing the path to that
trie, in addition to any other parameters needed to process the strings
associated with its nodes.</p>
<p>Before we present the algorithm itself, we need to address one more
important issue. We want the <strong>StringBuilder</strong> parameter to describe the
path to the node we are currently working on. Because we will need to do
a recursive call on each child, we will need to modify the
<strong>StringBuilder</strong> to reflect the path to that child. In order to be able
to do this, we will need to ensure that the recursive calls don&rsquo;t change
the contents of the <strong>StringBuilder</strong> (or more precisely, that they undo
any changes that they make).</p>
<p>Because we are implementing a preorder traversal, the first thing we
will need to do is to process the root. This involves determining
whether the root is associated with a string contained in the trie, and
if so, processing that string. Determining whether the root is
associated with a contained string is done by checking the <strong>bool</strong> at
the root. If it is <strong>true</strong>, we can convert the <strong>StringBuilder</strong>
parameter to a <strong>string</strong> and process it by doing whatever processing
needs to be done for each string in our specific application.</p>
<p>Once we have processed the root, we need to recursively process each of
the children in alphabetic order of their labels. How we accomplish this
depends on how we are implementing the trie - we will assume the
implementation of 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/multiple-impl">the previous
section</a>. Because
this implementation uses three different classes depending on how many
children a node has, we will need to write three different versions of
the preorder traversal, one for each class:</p>
<ul>
<li>For a <strong>TrieWithNoChildren</strong>, there is nothing to do (after processing the root).</li>
<li>Because a <strong>TrieWithOneChild</strong> has exactly one child, we need a
single recursive call on this child. Before we make this call, we
will need to append the child&rsquo;s label to the <strong>StringBuilder</strong>.
Following the recursive call, we will need to remove the character
that we added by reducing its


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.length?view=net-6.0#system-text-stringbuilder-length" target="_blank" rel="noopener"><strong>Length</strong></a>
property by 1.</li>
<li>We handle a <strong>TrieWithManyChildren</strong> in a similar way as a
<strong>TrieWithOneChild</strong>, only we will need to iterate through the
array of children and process each non-<strong>null</strong> child with a
recursive call. Note that for each of these children, its label will
need to be appended to the <strong>StringBuilder</strong> prior to the recursive
call and removed immediately after. We can obtain the label of a
child by adding the first letter of the alphabet to its array index and


<a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stacks/#cast">casting</a> the result to a
<strong>char</strong>.</li>
</ul>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Tries in Word Games</h1></div>
<h2 id="tries-in-word-games">Tries in Word Games</h2>
<p>One application of tries is for implementing word games such as
Boggle® or Scrabble®. This section discusses how a trie can be
used to reduce dramatically the amount of time spent searching for words
in such games. We will focus specifically on Boggle, but the same
principles apply to other word games as well.</p>
<p>A Boggle game consists of either 16 or 25 dice with letters on their
faces, along with a tray containing a 4 x 4 or 5 x 5 grid
for holding these dice. The face of each die contains a single letter,
except that one face of one die contains &ldquo;Qu&rdquo;. The tray has a large
cover such that the dice can be placed in the cover and the tray placed
upside-down on top of the cover. The whole thing can then be shaken,
then inverted so that each die ends up in a different grid cell, forming
a random game board such as:</p>
<p><img src="boggle.jpg" alt="A Boggle game board"></p>
<p>Players are then given a certain amount of time during which they
compete to try to form as many unique words as they can from these
letters. The letters of a word must be adjacent either horizontally,
vertically, or diagonally, and no die may be used more than once in a
single word. There is a minimum word length, and longer words are worth
more points. For example, the above game board contains the words,
&ldquo;WITCH&rdquo;, &ldquo;ITCH&rdquo;, &ldquo;PELLET&rdquo;, &ldquo;TELL&rdquo;, and &ldquo;DATA&rdquo;, among many others.</p>
<p><img src="boggle2.jpg" alt="Words on a Boggle game board"></p>
<p>Suppose we want to build a program that plays Boggle against a human
opponent. The program would need to look for words on a given board. The
dictionary of valid words can of course be stored in a trie. In what follows,
we will show how the structure of a trie can be particularly helpful in
guiding this search so that words are found more quickly.</p>
<p>We can think of a search from a given starting point as a traversal of a
tree. The root of the tree is the starting point, and its children are
searches starting from adjacent dice. We must be careful, however, to
include in such a tree only those adjacent dice that do not already
occur on the path to the given die. For example, if we start a search at
the upper-left corner of the above board, its children would be the
three adjacent dice containing &ldquo;I&rdquo;, &ldquo;C&rdquo;, and &ldquo;A&rdquo;. The children of &ldquo;I&rdquo;,
then, would not include &ldquo;H&rdquo; because it is already on the path to &ldquo;I&rdquo;.
Part of this tree would look like this:</p>
<p><img src="boggle-tree.jpg" alt="A part of a tree representing a Boggle search space"></p>
<p>Note that this tree is not a data structure - it need not be explicitly
stored anywhere. Rather, it is a mathematical object that helps us to
design an algorithm for finding all of the words. Each word on the board
is simply a path in this tree starting from the root. We can therefore
traverse this tree in much the same way as we outlined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/traversing">the previous
section</a> for tries.
For each node in the tree, we can look up the path leading to that node,
and output it if it is a word in the dictionary.</p>
<p>In order to be able to implement such a traversal, we need to be able to
find the children of a node. These children are the adjacent cells that
are not used in the path to the node. An efficient way to keep track of
the cells used in this path is with a <strong>bool[ , ]</strong> of the same
size as the Boggle board - a value of <strong>true</strong> in this array will
indicate that the corresponding cell on the board has been used in the
current path. The children of a node are then the adjacent cells whose
entries in this array are <strong>false</strong>.</p>
<p>A preorder traversal of this tree will therefore need the following
parameters (and possibly others, depending on how we want to output the
words found):</p>
<ul>
<li>The row index of the current cell.</li>
<li>The column index of the current cell.</li>
<li>The <strong>bool[ , ]</strong> described above. The current cell will
have a <strong>false</strong> entry in this array.</li>
<li>A <strong>StringBuilder</strong> giving the letters on the path up to, but not
including, the current cell.</li>
</ul>
<p>The preorder traversal will first need to update the cells used by
setting the location corresponding to the current cell to <strong>true</strong>.
Likewise, it will need to update the <strong>StringBuilder</strong> by appending the
contents of the current cell. Then it will need to process the root by
looking up the contents of the <strong>StringBuilder</strong> - if this forms a word,
it should output this word. Then it should process the children: for
each adjacent cell whose entry in the <strong>bool[ , ]</strong> is
<strong>false</strong>, it should make a recursive call on that cell. After all the
children have been processed, it will need to return the
<strong>bool[ , ]</strong> and the <strong>StringBuilder</strong> to their
earlier states by setting the array entry back to <strong>false</strong> and removing
the character(s) appended earlier.</p>
<p>Once such a method is written, we can call it once for each cell on the
board. For each of these calls, all entries in the <strong>bool[ , ]</strong>
should be false, and the <strong>StringBuilder</strong> should be empty.</p>
<p>While the algorithm described above will find all the words on a Boggle
board, a 5 x 5 board will require quite a while for the algorithm
to process. While this might be acceptable if we are implementing a game
that humans can compete with, from an algorithmic standpoint, we would
like to improve the performance. (In fact, there are probably better
ways to make a program with which humans can compete, as this search
will only find words that begin near the top of the board.)</p>
<p>We can begin to see how to improve the performance if we observe the
similarity between the trees we have been discussing and a trie
containing the word list. Consider, for example, a portion of the child
labeled &lsquo;h&rsquo; in a trie representing a large set of words:</p>
<p><img src="trie-portion.jpg" alt="A portion of a trie."></p>
<p>We have omitted some of the children because they are irrelevant to the
search we are performing (e.g., there is no die containing &ldquo;E&rdquo; adjacent
to &ldquo;H&rdquo; on the above game board). Also, we are assuming a minimum word
length of 4; hence, &ldquo;ha&rdquo;, &ldquo;hi&rdquo;, and &ldquo;hit&rdquo; are not shown as words in this
trie.</p>
<p>Notice the similarity between the trie portion shown above and the tree
shown earlier. The root of the tree has children representing dice
containing &ldquo;I&rdquo; and &ldquo;A&rdquo;, and the former node has children representing
dice containing &ldquo;T&rdquo;, &ldquo;C&rdquo;, and &ldquo;A&rdquo;; likewise, though they are listed in a
different order, the trie has children labeled &lsquo;i&rsquo; and &lsquo;a&rsquo;, and the
former node has children labeled &rsquo;t&rsquo;, &lsquo;c&rsquo;, and &lsquo;a&rsquo;.</p>
<p>What is more important to our discussion, however, is that the trie does
not have a child labeled &lsquo;c&rsquo;, as there is no English word beginning with
&ldquo;hc&rdquo;. Similarly, the child labeled &lsquo;i&rsquo; does not have a child labeled
&lsquo;i&rsquo;, as there is no English word beginning with &ldquo;hii&rdquo;. If there are no
words in the word list beginning with these prefixes, there is no need
to search the subtrees rooted at the corresponding nodes when doing the
preorder traversal. Using the trie to prune the search in this way ends
up avoiding many subtrees that don&rsquo;t lead to any words. As a result,
only a small fraction of the original tree is searched.</p>
<p>In order to take advantage of the trie in this way, we need a method in
the trie implementation to return the child having a given label, or
<strong>null</strong> if there is no such child. Alternatively, we might provide a
method that takes a <strong>string</strong> and returns the trie that this <strong>string</strong>
leads to, or <strong>null</strong> if there is no such trie (this method would make
it easier to handle the die containing &ldquo;Qu&rdquo;). Either way, we can then
traverse the trie as we are doing the preorder traversal described
above, and avoid searching a subtree whenever the trie becomes null.</p>
<p>This revised preorder traversal needs an extra parameter - a trie giving
all completions of words beginning with the prefix given by the
<strong>StringBuilder</strong> parameter. We will need to ensure that this parameter
is never <strong>null</strong>. The algorithm then proceeds as follows:</p>
<ul>
<li>From the given trie, get the subtrie containing the completions of
words beginning with the contents of the current cell.</li>
<li>If this subtrie is not <strong>null</strong>:
<ul>
<li>Set the location in the <strong>bool[ , ]</strong> corresponding to
the current cell to <strong>true</strong>.</li>
<li>Append the contents of the current cell to the
<strong>StringBuilder</strong>.</li>
<li>If the subtrie obtained above contains the empty <strong>string</strong>,
output the contents of the <strong>StringBuilder</strong> as a word found.</li>
<li>Recursively traverse each adjacent cell whose corresponding
entry in the <strong>bool[ , ]</strong> is <strong>false</strong>. The recursive
calls should use the subtrie obtained above.</li>
<li>Set the location in the <strong>bool[ , ]</strong> corresponding to
the current cell to <strong>false</strong>.</li>
<li>Remove the contents of the current cell from the end of the
<strong>StringBuilder</strong> (i.e., decrease its <strong>Length</strong> by the
appropriate amount).</li>
</ul>
</li>
</ul>
<p>We would then apply the above algorithm to each cell on the board. For
each cell, we would use a <strong>bool[ , ]</strong> whose entries are all
<strong>false</strong>, an empty <strong>StringBuilder</strong>, and the entire trie of valid words. Note that we
have designed the preorder traversal so that it leaves each of these
parameters unchanged; hence, we only need to initialize them once. The
resulting search will find all of the words on the board quickly.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
    
    
          <article class="default">
<div hidden><h1>Priority Queues</h1></div>
<h2 id="priority-queues">Priority Queues</h2>
<p>Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined <em>priority</em>.  We have already seen two instances of such data structures: stacks and queues.  With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its
priority.  More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored.</p>
<p>The general name for such a data structure is a <em>priority queue</em>.  Priority queues typically  support the following operations:</p>
<ul>
<li>Adding a data element, together with a priority.</li>
<li>Obtaining the number of data elements currently in the structure.</li>
<li>Obtaining the maximum of all priorities of elements in the structure.</li>
<li>Removing a data element having maximum priority.</li>
</ul>
<p>Obviously, the last two operations above can only be done when the structure is nonempty.  A variation on the above focuses on minimum priority rather than maximum priority.  This variation is called a <em>min-priority queue</em>.  Because we will later cover applications of min-priority queues, we will focus on this variation in this section.  In the sub-sections that follow, we will first consider a general structure that can be used in various ways to give efficient priority queue implementations.  We will then look at one specific implementation.  We will conclude by giving an example of how min-priority queues are used in file compression algorithms.</p>

            <footer class="footline">
            </footer>
          </article>

          <section>
    
    
          <article class="default">
<div hidden><h1>Heaps</h1></div>
<h2 id="heaps">Heaps</h2>
<p>A common structure for implementing a priority queue is known as a
<em>heap</em>. A heap is a tree whose nodes contain elements with priorities
that can be ordered. Furthermore, if the heap is nonempty, its root
contains the maximum priority of any node in the heap, and each of its
children is also a heap. Note that this implies that, in any subtree,
the maximum priority is at the root. We define a <em>min-heap</em> similarly,
except that the minimum priority is at the root. Below is an example of
a min-heap with integer priorities (the data elements are not shown &mdash;
only their priorities):</p>
<p><img src="heap.jpg" alt="A min-heap."></p>
<p>Note that this structure is different from a binary search tree, as
there are elements in the left child that have larger priorities than
the root. Although some ordering is imposed on the nodes (i.e.,
priorities do not decrease as we go down a path from the root), the
ordering is less rigid than for a binary search tree. As a result, there
is less overhead involved in maintaining this ordering; hence, a
min-heap tends to give better performance than an AVL tree, which could
also be used to implement a min-priority queue. Although the definition
of a heap does not require it, the implementations we will consider will
be binary trees, as opposed to trees with an arbitrary number of
children.</p>

  
  
<div class="box notices cstyle note">
    <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
    <div class="box-content">
<p>The heap data structure is
unrelated to the pool of memory from which instances of reference types
are constructed &mdash; this also, unfortunately, is called a heap.</p>
    </div>
</div>
<p>One advantage to using a min-heap to implement a min-priority queue is
fairly obvious &mdash; an element with minimum priority is always at the root
if the min-heap is nonempty. This makes it easy to find the minimum
priority and an element with this priority. Let&rsquo;s consider how we might
remove an element with minimum priority. Assuming the min-heap is
nonempty, we need to remove the element at the root. Doing so leaves us
with two min-heaps (either of which might be empty). To complete the
removal, we need a way to merge two min-heaps into one. Note that if we
can do this, we also have a way of adding a new element: we form a
1-node min-heap from the new element and its priority, then merge this
min-heap with the original one.</p>
<p>Let us therefore consider the problem of merging two min-heaps into one.
If either min-heap is empty, we can simply use the other one. Suppose
that both are nonempty. Then the minimum priority of each is located at
its root. The minimum priority overall must therefore be the smaller of
these two priorities. Let <em>s</em> denote the heap whose root has the smaller
priority and <em>b</em> denote the heap whose root has the larger priority.
Then the root of <em>s</em> should be the root of the resulting min-heap.</p>
<p>Now that we have determined the root of the result, let&rsquo;s consider what
we have left. <em>s</em> has two children, both of which are min-heaps, and <em>b</em>
is also a min-heap. We therefore have three min-heaps, but only two
places to put them - the new left and right children of <em>s</em>. To reduce
the number of min-heaps to two, we can merge two of them into one. This
is simply a recursive call.</p>
<p>We have therefore outlined a general strategy for merging two min-heaps.
There two important details that we have omitted, though:</p>
<ul>
<li>Which two min-heaps do we merge in the recursive call?</li>
<li>Which of the two resulting min-heaps do we make the new left child
of the new root?</li>
</ul>
<p>There are various ways these questions can be answered. Some ways lead
to efficient implementations, whereas others do not. For example, if we
always merge the right child of <em>s</em> with <em>b</em> and make the result the new
right child of the new root, it turns out that all of our min-heaps will have
empty left children. As a result, in the worst case, the time needed to
merge two min-heaps is proportional to the total number of elements in
the two min-heaps. This is poor performance. In 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/leftist-heaps">the next
section</a> we will
consider a specific implementation that results in a worst-case running
time proportional to the logarithm of the total number of nodes.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Leftist Heaps</h1></div>
<h2 id="leftist-heaps">Leftist Heaps</h2>
<p>One efficient way to complete the merge algorithm outlined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps">the
previous section</a> revolves
around the concept of the <em>null path length</em> of a tree. For any tree <i>t</i>, null path length of <i>t</i> is defined
to be 
<span class="math align-center">$ 0 $</span> if <i>t</i> is empty, or one more than the minimum of the null path
lengths of its children if <i>t</i> is nonempty. Another way to understand
this concept is that it gives the minimum number of steps needed to get
from the root to an empty subtree. For an empty tree, there is no root,
so we somewhat arbitrarily define the null path length to be <span style="white-space:nowrap">
<span class="math align-center">$ 0 $</span>.</span> For
single-node trees or binary trees with at least one empty child, the
null path length is 
<span class="math align-center">$ 1 $</span> because only one step is needed to reach an empty
subtree.</p>
<p>One reason that the null path length is important is that it can be
shown that any binary tree with 
<span class="math align-center">$ n $</span> nodes has a null path length that is
no more than <span style="white-space:nowrap">
<span class="math align-center">$ \lg(n + 1) $</span>.</span> Furthermore, recall that in the merging
strategy outlined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps">the previous
section</a>, there is some
flexibility in choosing which child of a node will be used in the
recursive call. Because the strategy reaches a base case when one of the
min-heaps is empty, the algorithm will terminate the most quickly if we
do the recursive call on the child leading us more quickly to an empty
subtree &mdash; i.e., if we use the child with smaller null path length.
Because this length is logarithmic in the number of nodes in the
min-heap, this choice will quickly lead us to the base case and
termination.</p>
<p>A common way of implementing this idea is to use what is known as a
<em>leftist heap</em>. A leftist heap is a binary tree that forms a heap such
that for every node, the null path length of the right child is no more
than the null path length of the left child. For such a structure,
completing the merge algorithm is simple:</p>
<ul>
<li>For the recursive call, we merge the right child of <em>s</em> with <em>b</em>,
where <em>s</em> and <em>b</em> are as defined in 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps">the previous
section</a>.</li>
<li>When combining the root and left child of <em>s</em> with the result of the
recursive call, we arrange the children so that the result is a
leftist heap.</li>
</ul>
<p>We can implement this idea by defining two classes, <strong>LeftistTree&lt;T&gt;</strong>
and <strong>MinPriorityQueue&lt;TPriority, TValue&gt;</strong>. For the
<strong>LeftistTree&lt;T&gt;</strong> class, we will only be concerned with the shape of
the tree &mdash; namely, that the null path length of the right child is never
more than the null path length of the left child. We will adopt a
strategy similar to what we did with 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">AVL
trees</a>. Specifically a
<strong>LeftistTree&lt;T&gt;</strong> will be immutable so that we can always be sure
that it is shaped properly. It will then be a straightforward matter to
implement a <strong>MinPriorityQueue&lt;TPriority, TValue&gt;</strong>, where
<strong>TPriority</strong> is the type of the priorities, and <strong>TValue</strong> is the type
of the values.</p>
<p>The implementation of <strong>LeftistTree&lt;T&gt;</strong> ends up being very similar to
the implementation we described for 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl">AVL tree
nodes</a>, but without the
rotations. We need three <strong>public</strong> properties using the default
implementation with <strong>get</strong> accessors: the data (of type <strong>T</strong>) and the
two children (of type <strong>LeftistTree&lt;T&gt;?</strong>). We also need a <strong>private</strong>
field to store the null path length (of type <strong>int</strong>). We can define a
<strong>static</strong> method to obtain the null path length of a given
<strong>LeftistTree&lt;T&gt;?</strong>. This method is essentially the same as the
<strong>Height</strong> method for an AVL tree, except that if the given tree is
<strong>null</strong>, we return 0. A constructor takes as its parameters a data
element of type <strong>T</strong> and two children of type <strong>LeftistTree&lt;T&gt;?</strong>. It
can initialize its data with the first parameter. To initialize its
children, it first needs to determine their null path lengths using the
<strong>static</strong> method above. It then assigns the two <strong>LeftistTree&lt;T&gt;?</strong>
parameters to its child fields so that the right child&rsquo;s null path
length is no more than the left child&rsquo;s. Finally, it can initialize its
own null path length by adding 1 to its right child&rsquo;s null path length.</p>
<p><span id="where"></span> Let&rsquo;s now consider how we can implement
<strong>MinPriorityQueue&lt;TPriority, TValue&gt;</strong>. The first thing we need to
consider is the type, <strong>TPriority</strong>. This needs to be a non-nullable type that can be
ordered (usually it will be a numeric type like <strong>int</strong>). We can
restrict <strong>TPriority</strong> to be a non-nullable subtype of <strong>IComparable&lt;TPriority&gt;</strong>
by using a <strong>where</strong> clause, as we did for dictionaries (see
&ldquo;

<a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/linked-list-impl">Implementing a Dictionary with a Linked
List</a>&rdquo;).</p>
<p>We then need a <strong>private</strong> field in which to store a leftist tree. We
can store both the priority and the data element in a node if we use a
<strong>LeftistTree&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;?</strong>; thus, the keys are
the priorities and the values are the data elements. We also need a
<strong>public int</strong> property to get of the number of elements in the
min-priority queue. This property can use the default implementation
with <strong>get</strong> and <strong>private set</strong> accessors.</p>
<p>In order to implement <strong>public</strong> methods to add an element with a
priority and to remove an element with minimum priority, we need the
following method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> LeftistTree&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;?
</span></span><span style="display:flex;"><span>    Merge(LeftistTree&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;? h1, 
</span></span><span style="display:flex;"><span>        LeftistTree&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;? h2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    . . .
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This method consist of three cases. The first two cases occur when
either of the parameters is <strong>null</strong>. In each such case, we return the
other parameter. In the third case, when neither parameter is <strong>null</strong>,
we first need to compare the priorities in the data stored in the root
nodes of the parameters. A priority is stored in the


<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.key?view=net-6.0#system-collections-generic-keyvaluepair-2-key" target="_blank" rel="noopener"><strong>Key</strong></a>
property of the <strong>KeyValuePair</strong>, and we have constrained this type so
that it has a <strong>CompareTo</strong> method that will compare one instance with
another. Once we have determined which root has a smaller priority, we
can construct and return a new
<strong>LeftistTree&lt;KeyValuePair&lt;TPriority, TValue&gt;&gt;</strong> whose data
is the data element with smaller priority, and whose children are the
left child of this data element and the result of recursively merging
the right child of this element with the parameter whose root has larger
priority.</p>
<p>The remaining methods and properties of
<strong>MinPriorityQueue&lt;TPriority, TValue&gt;</strong> are now fairly
straightforward.</p>

            <footer class="footline">
            </footer>
          </article>

    
    
          <article class="default">
<div hidden><h1>Huffman Trees</h1></div>
<h2 id="huffman-trees">Huffman Trees</h2>
<p>In this section, we&rsquo;ll consider an application of min-priority queues to
the general problem of compressing files. Consider, for example, a plain
text file like 

<a href="pg5.txt">this copy of the U. S. Constitution</a>. This file
is encoded using UTF-8, the most common encoding for plain text files.
The characters most commonly appearing in English-language text files
are each encoded as one byte (i.e., eight bits) using this scheme. For
example, in the text file referenced above, every character is encoded
as a single byte (the first three bytes of the file are an optional code
indicating that it is encoded in UTF-8 format). Furthermore, some byte
values occur much more frequently than others. For example, the encoding
of the blank character occurs over 6000 times, whereas the encoding of
&lsquo;$&rsquo; occurs only once, and the encoding of &lsquo;=&rsquo; doesn&rsquo;t occur at all.</p>
<p>One of the techniques used by most file compression schemes is to find a
variable-width encoding scheme for the file. Such a scheme uses fewer
bits to encode commonly-occurring byte values and more bits to encode
rarely-occurring byte values. Byte values that do not occur at all in
the file are not given an encoding.</p>
<p>Consider, for example, a file containing the single string,
&ldquo;Mississippi&rdquo;, with no control characters signaling the end of the line.
If we were to use one byte for each character, as UTF-8 would do, we
would need 11 bytes (or 88 bits). However, we could encode the
characters in binary as follows:</p>
<ul>
<li>M: 100</li>
<li>i: 0</li>
<li>p: 101</li>
<li>s: 11</li>
</ul>
<p>Obviously because each character is encoded with fewer than 8 bits, this
will give us a shorter encoding. However, because &lsquo;i&rsquo; and &rsquo;s&rsquo;, which
each occur four times in the string, are given shorter encodings than
&lsquo;M&rsquo; and &lsquo;p&rsquo;, which occur a total of three times combined, the number of
bits is further reduced. The encoded string is</p>
<pre><code>100011110111101011010
</code></pre>
<p>which is only 21 bits, or less than 3 bytes.</p>
<p>In constructing such an encoding scheme, it is important that the
encoded string can be decoded unambiguously. For example, it would
appear that the following scheme might be even better:</p>
<ul>
<li>M: 01</li>
<li>i: 0</li>
<li>p: 10</li>
<li>s: 1</li>
</ul>
<p>This scheme produces the following encoding:</p>
<pre><code>01011011010100
</code></pre>
<p>which is only 14 bits, or less than 2 bytes. However, when we try to
decode it, we immediately run into problems. Is the first 0 an &lsquo;i&rsquo; or
the first bit of an &lsquo;M&rsquo;? We could decode this string as &ldquo;isMsMsMisii&rdquo;,
or a number of other possible strings.</p>
<p>The first encoding above, however, has only one decoding, &ldquo;Mississippi&rdquo;.
The reason for this is that this encoding is based on the following
binary tree:</p>
<p><img src="huffman.jpg" alt="A Huffman tree"></p>
<p>To get the encoding for a character, we trace the path to that character
from the root, and record a 0 each time we go left and a 1 each time we
go right. Thus, because the path to &lsquo;M&rsquo; is right, left, left, we have an
encoding of 100. To decode, we simply use the encoding to trace out a
path in the tree, and when we reach a character (or more generally, a
byte value), we record that value. If we form the tree such that each
node has either two empty children or two nonempty children, then when
tracing out a path, we will always either have a choice of two
alternatives or be at a leaf storing a byte value. The decoding will
therefore be unambiguous. Such a tree that gives an encoding whose
length is minimized over all such encodings is called a <em>Huffman tree</em>.</p>
<p>Before we can find a Huffman tree for a file, we need to determine how
many times each byte value occurs. There are 256 different byte values
possible; hence we will need an array of 256 elements to keep track of
the number of occurrences of each. Because files can be large, this
array should be a <strong>long[ ]</strong>. We can then use element <em>i</em> of this
array to keep track of the number of occurrences of byte value <em>i</em>.
Thus, after constructing this array, we can read the file one byte at a
time as described in 

<a href="https://ksu-cs-textbooks.github.io/cis300/io/other-file-io">&ldquo;Other File
I/O&rdquo;</a>, and for each
<strong>byte</strong> <code>b</code> that we read, we increment the value at location <code>b</code> of the
array.</p>
<p>Having built this frequency table, we can now use it to build a Huffman
tree. We will build this tree from the bottom up, storing subtrees in a
min-priority queue. The priority of each subtree will be the total
number of occurrences of all the byte values stored in its leaves. We
begin by building a 1-node tree from each nonzero value in the frequency
table. As we iterate through the frequency table, if we find that
location <em>i</em> is nonzero, we construct a node containing <em>i</em> and add that
node to the min-priority queue. The priority we use when adding the node
is the number of occurrences of <em>i</em>, which is simply the value at
location <em>i</em> of the frequency table.</p>
<p>Once the min-priority queue has been loaded with the leaves, can begin
combining subtrees into larger trees. We will need to handle as a
special case an empty min-priority queue, which can result only from an
empty input file. In this case, there is no Huffman tree, as there are
no byte values that need to be encoded. Otherwise, as long as the
min-priority queue has more than one element, we:</p>
<ul>
<li>Get and remove the two smallest priorities and their associated
trees.</li>
<li>Construct a new binary tree with these trees as its children and 0
as its data (which will be unused).</li>
<li>Add the resulting tree to the min-priority queue with a priority
equal to the sum of the priorities of its children.</li>
</ul>
<p>Because each iteration removes two elements from the min-priority queue
and adds one, eventually the min-priority queue will contain only one
element. It can be shown that this last remaining element is a Huffman
tree for the file.</p>
<p>Most file compression schemes involve more than just converting to a
Huffman-tree encoding. Furthermore, even if this is the only technique
used, simply writing the encoded data is insufficient to compress the
file, as the Huffman tree is needed to decompress it. Therefore, some
representation of the Huffman tree must also be written. In addition, a
few extra bits may be needed to reach a byte boundary. Because of this,
the length of the decompressed file is also needed for decompression so
that the extra bits are not interpreted as part of the encoded data. Due
to this additional output, compressing a short file will likely result
in a longer file than the original.</p>

            <footer class="footline">
            </footer>
          </article>

          </section>
          </section>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        </div>
      </main>
    
<div class="git-footer">
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cis300/cis300-book/-/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5">May 22, 2023</a>
</p>
</div>

    
    </div>
    <aside id="sidebar" class="default-animation">
      <div id="header-wrapper" class="default-animation">
        <div id="header" class="default-animation">
<a id="logo" href="https://ksu-cs-textbooks.github.io/cis300/">
  CIS 300 - Data Structures
</a>

        </div>
        <div class="searchbox default-animation">
          <label for="search-by"><i class="fas fa-search"></i></label>
          <input data-search-input id="search-by" type="search" placeholder="Search...">
          <span data-search-clear=""><i class="fas fa-times"></i></span>
        </div>
        <script>
          var contentLangs=['en'];
        </script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/auto-complete.js?1686240615" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/lunr.min.js?1686240615" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/lunr.stemmer.support.min.js?1686240615" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/lunr.multi.min.js?1686240615" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/lunr.en.min.js?1686240615" defer></script>
        <script src="https://ksu-cs-textbooks.github.io/cis300/js/search.js?1686240615" defer></script>
      </div>
      <div id="content-wrapper" class="highlightable">
        <ul class="topics collapsible-menu">
          <li data-nav-id="/io/" title="Input/Output" class="dd-item"><input type="checkbox" id="section-cbd3b3207f24308a668546abfa69f213" class="toggle"/><label for="section-cbd3b3207f24308a668546abfa69f213" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/io/"><b>1. </b>Input/Output</a><ul>
          <li data-nav-id="/io/dialogs/" title="Dialogs" class="dd-item"><input type="checkbox" id="section-61b1770a0bd16f4917e33b67edd271d2" class="toggle"/><label for="section-61b1770a0bd16f4917e33b67edd271d2" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/"><b>1.1. </b>Dialogs</a><ul>
          <li data-nav-id="/io/dialogs/message-boxes/" title="MessageBoxes" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/message-boxes/"><b>1.1.1. </b>MessageBoxes</a></li>
          <li data-nav-id="/io/dialogs/file-dialogs/" title="File Dialogs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/file-dialogs/"><b>1.1.2. </b>File Dialogs</a></li>
          <li data-nav-id="/io/dialogs/custom/" title="Custom Dialogs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/custom/"><b>1.1.3. </b>Custom Dialogs</a></li></ul></li>
          <li data-nav-id="/io/simple-text-file/" title="Simple Text File I/O" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/simple-text-file/"><b>1.2. </b>Simple Text File I/O</a></li>
          <li data-nav-id="/io/exceptions/" title="Exception Handling" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/exceptions/"><b>1.3. </b>Exception Handling</a></li>
          <li data-nav-id="/io/advanced-text-file/" title="Advanced Text File I/O" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/advanced-text-file/"><b>1.4. </b>Advanced Text File I/O</a></li>
          <li data-nav-id="/io/other-file-io/" title="Other File I/O" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/io/other-file-io/"><b>1.5. </b>Other File I/O</a></li></ul></li>
          <li data-nav-id="/strings/" title="strings and StringBuilders" class="dd-item"><input type="checkbox" id="section-9355ad26afa67cd4239c81429ad6e8ca" class="toggle"/><label for="section-9355ad26afa67cd4239c81429ad6e8ca" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/strings/"><b>2. </b>strings and StringBuilders</a><ul>
          <li data-nav-id="/strings/strings/" title="strings" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/strings/strings/"><b>2.1. </b>strings</a></li>
          <li data-nav-id="/strings/stringbuilders/" title="StringBuilders" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilders/"><b>2.2. </b>StringBuilders</a></li>
          <li data-nav-id="/strings/stringbuilder-impl/" title="Implementation of StringBuilders" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilder-impl/"><b>2.3. </b>Implementation of StringBuilders</a></li></ul></li>
          <li data-nav-id="/stacks-queues/" title="Stacks and Queues" class="dd-item"><input type="checkbox" id="section-deefdc256b7889ce66393d7269597a4b" class="toggle"/><label for="section-deefdc256b7889ce66393d7269597a4b" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/"><b>3. </b>Stacks and Queues</a><ul>
          <li data-nav-id="/stacks-queues/stacks/" title="Introduction to Stacks" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stacks/"><b>3.1. </b>Introduction to Stacks</a></li>
          <li data-nav-id="/stacks-queues/undo/" title="Implementing Undo and Redo for a TextBox" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/undo/"><b>3.2. </b>Implementing Undo and Redo for a TextBox</a></li>
          <li data-nav-id="/stacks-queues/paren/" title="Parenthesis Matching" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/paren/"><b>3.3. </b>Parenthesis Matching</a></li>
          <li data-nav-id="/stacks-queues/stack-impl/" title="Implementing a Stack" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl/"><b>3.4. </b>Implementing a Stack</a></li>
          <li data-nav-id="/stacks-queues/queues/" title="Introduction to Queues" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queues/"><b>3.5. </b>Introduction to Queues</a></li>
          <li data-nav-id="/stacks-queues/queue-impl/" title="Implementing a Queue" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queue-impl/"><b>3.6. </b>Implementing a Queue</a></li></ul></li>
          <li data-nav-id="/linked-lists/" title="Linked Lists" class="dd-item"><input type="checkbox" id="section-a51df6d53eeee393764eb46edb53958a" class="toggle"/><label for="section-a51df6d53eeee393764eb46edb53958a" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/"><b>4. </b>Linked Lists</a><ul>
          <li data-nav-id="/linked-lists/intro/" title="Introduction to Linked Lists" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro/"><b>4.1. </b>Introduction to Linked Lists</a></li>
          <li data-nav-id="/linked-lists/stacks-queues/" title="Implementing Stacks and Queues with Linked Lists" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/stacks-queues/"><b>4.2. </b>Implementing Stacks and Queues with Linked Lists</a></li>
          <li data-nav-id="/linked-lists/sieve-eratosthenes/" title="Finding Prime Numbers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/sieve-eratosthenes/"><b>4.3. </b>Finding Prime Numbers</a></li></ul></li>
          <li data-nav-id="/dictionaries/" title="Dictionaries" class="dd-item"><input type="checkbox" id="section-9011afb8a0159b09a13a971ca89bced8" class="toggle"/><label for="section-9011afb8a0159b09a13a971ca89bced8" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/"><b>5. </b>Dictionaries</a><ul>
          <li data-nav-id="/dictionaries/dictionary-tkey-tvalue/" title="The Dictionary&lt;TKey, TValue&gt; Class" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/dictionary-tkey-tvalue/"><b>5.1. </b>The Dictionary&lt;TKey, TValue&gt; Class</a></li>
          <li data-nav-id="/dictionaries/linked-list-impl/" title="Implementing a Dictionary with a Linked List" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/linked-list-impl/"><b>5.2. </b>Implementing a Dictionary with a Linked List</a></li>
          <li data-nav-id="/dictionaries/binary-search/" title="Implementing a Dictionary with an Array-Like Structure" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/dictionaries/binary-search/"><b>5.3. </b>Implementing a Dictionary with an Array-Like Structure</a></li></ul></li>
          <li data-nav-id="/trees/" title="Trees" class="dd-item active parent"><input type="checkbox" id="section-5e8305205d74771c71a9ea85594a7914" class="toggle" checked/><label for="section-5e8305205d74771c71a9ea85594a7914" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/trees/"><b>6. </b>Trees</a><ul>
          <li data-nav-id="/trees/intro/" title="Introduction to Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/intro/"><b>6.1. </b>Introduction to Trees</a></li>
          <li data-nav-id="/trees/bst/" title="Binary Search Trees" class="dd-item"><input type="checkbox" id="section-8d42cd93516505610f8b32c65bbeebda" class="toggle"/><label for="section-8d42cd93516505610f8b32c65bbeebda" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/"><b>6.2. </b>Binary Search Trees</a><ul>
          <li data-nav-id="/trees/bst/binary-trees/" title="Binary Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/binary-trees/"><b>6.2.1. </b>Binary Trees</a></li>
          <li data-nav-id="/trees/bst/intro/" title="Introduction to Binary Search Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/intro/"><b>6.2.2. </b>Introduction to Binary Search Trees</a></li>
          <li data-nav-id="/trees/bst/remove/" title="Removing from a Binary Search Tree" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/remove/"><b>6.2.3. </b>Removing from a Binary Search Tree</a></li>
          <li data-nav-id="/trees/bst/inorder/" title="Inorder Traversal" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/bst/inorder/"><b>6.2.4. </b>Inorder Traversal</a></li></ul></li>
          <li data-nav-id="/trees/avl/" title="AVL Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/avl/"><b>6.3. </b>AVL Trees</a></li>
          <li data-nav-id="/trees/tries/" title="Tries" class="dd-item"><input type="checkbox" id="section-5f1f75af2aa97dd0bdbedb3b3e5adc65" class="toggle"/><label for="section-5f1f75af2aa97dd0bdbedb3b3e5adc65" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/"><b>6.4. </b>Tries</a><ul>
          <li data-nav-id="/trees/tries/intro/" title="Introduction to Tries" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro/"><b>6.4.1. </b>Introduction to Tries</a></li>
          <li data-nav-id="/trees/tries/multiple-impl/" title="Multiple Implementations of Children" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/multiple-impl/"><b>6.4.2. </b>Multiple Implementations of Children</a></li>
          <li data-nav-id="/trees/tries/traversing/" title="Traversing a Trie" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/traversing/"><b>6.4.3. </b>Traversing a Trie</a></li>
          <li data-nav-id="/trees/tries/word-games/" title="Tries in Word Games" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/word-games/"><b>6.4.4. </b>Tries in Word Games</a></li></ul></li>
          <li data-nav-id="/trees/priority-queues/" title="Priority Queues" class="dd-item"><input type="checkbox" id="section-0e087c42aa39c815f492e3767eaf2ef7" class="toggle"/><label for="section-0e087c42aa39c815f492e3767eaf2ef7" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/"><b>6.5. </b>Priority Queues</a><ul>
          <li data-nav-id="/trees/priority-queues/heaps/" title="Heaps" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps/"><b>6.5.1. </b>Heaps</a></li>
          <li data-nav-id="/trees/priority-queues/leftist-heaps/" title="Leftist Heaps" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/leftist-heaps/"><b>6.5.2. </b>Leftist Heaps</a></li>
          <li data-nav-id="/trees/priority-queues/huffman-trees/" title="Huffman Trees" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/huffman-trees/"><b>6.5.3. </b>Huffman Trees</a></li></ul></li></ul></li>
          <li data-nav-id="/hashing/" title="Hash Tables" class="dd-item"><input type="checkbox" id="section-cd22fc50afca8a60e214c94b94daa169" class="toggle"/><label for="section-cd22fc50afca8a60e214c94b94daa169" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/"><b>7. </b>Hash Tables</a><ul>
          <li data-nav-id="/hashing/simple/" title="A Simple Hash Table Implementation" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/simple/"><b>7.1. </b>A Simple Hash Table Implementation</a></li>
          <li data-nav-id="/hashing/rehashing/" title="Rehashing" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/rehashing/"><b>7.2. </b>Rehashing</a></li>
          <li data-nav-id="/hashing/memoization/" title="Memoization" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/memoization/"><b>7.3. </b>Memoization</a></li>
          <li data-nav-id="/hashing/equality/" title="Equality in C#" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/equality/"><b>7.4. </b>Equality in C#</a></li>
          <li data-nav-id="/hashing/hash-functions/" title="Hash Codes" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/hashing/hash-functions/"><b>7.5. </b>Hash Codes</a></li></ul></li>
          <li data-nav-id="/graphs/" title="Graphs" class="dd-item"><input type="checkbox" id="section-fefd7704561bcadc124f3f3c72c54ab3" class="toggle"/><label for="section-fefd7704561bcadc124f3f3c72c54ab3" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/graphs/"><b>8. </b>Graphs</a><ul>
          <li data-nav-id="/graphs/intro/" title="Introduction to Graphs" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/graphs/intro/"><b>8.1. </b>Introduction to Graphs</a></li>
          <li data-nav-id="/graphs/dijkstra/" title="Shortest Paths" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/graphs/dijkstra/"><b>8.2. </b>Shortest Paths</a></li>
          <li data-nav-id="/graphs/breadth-first/" title="Unweighted Shortest Paths" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/graphs/breadth-first/"><b>8.3. </b>Unweighted Shortest Paths</a></li>
          <li data-nav-id="/graphs/impl/" title="Implementing a Graph" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/graphs/impl/"><b>8.4. </b>Implementing a Graph</a></li></ul></li>
          <li data-nav-id="/sorting/" title="Sorting" class="dd-item"><input type="checkbox" id="section-fd2166a393af1c48d2ffe636e6f952d8" class="toggle"/><label for="section-fd2166a393af1c48d2ffe636e6f952d8" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/"><b>9. </b>Sorting</a><ul>
          <li data-nav-id="/sorting/select/" title="Select Sorts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/select/"><b>9.1. </b>Select Sorts</a></li>
          <li data-nav-id="/sorting/insert/" title="Insert Sorts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/insert/"><b>9.2. </b>Insert Sorts</a></li>
          <li data-nav-id="/sorting/merge/" title="Merge Sorts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/merge/"><b>9.3. </b>Merge Sorts</a></li>
          <li data-nav-id="/sorting/split/" title="Split Sorts" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/split/"><b>9.4. </b>Split Sorts</a></li>
          <li data-nav-id="/sorting/hybrid/" title="Hybrid Sorting Algorithms" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/hybrid/"><b>9.5. </b>Hybrid Sorting Algorithms</a></li>
          <li data-nav-id="/sorting/strings/" title="Sorting Strings" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/sorting/strings/"><b>9.6. </b>Sorting Strings</a></li></ul></li>
          <li data-nav-id="/appendix/" title="Appendices" class="dd-item"><input type="checkbox" id="section-8a7f152ea576b5a4047f92c2cc1cabad" class="toggle"/><label for="section-8a7f152ea576b5a4047f92c2cc1cabad" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/"><b>A. </b>Appendices</a><ul>
          <li data-nav-id="/appendix/syntax/" title="C# Syntax" class="dd-item"><input type="checkbox" id="section-6a5a5cc3bca4007f0866907612ee033f" class="toggle"/><label for="section-6a5a5cc3bca4007f0866907612ee033f" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/"><b>A1. </b>C# Syntax</a><ul>
          <li data-nav-id="/appendix/syntax/reference-value/" title="Reference Types and Value Types" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/reference-value/"><b>A1.1. </b>Reference Types and Value Types</a></li>
          <li data-nav-id="/appendix/syntax/enumerations/" title="Enumerations" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/enumerations/"><b>A1.2. </b>Enumerations</a></li>
          <li data-nav-id="/appendix/syntax/structs/" title="Structures" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/structs/"><b>A1.3. </b>Structures</a></li>
          <li data-nav-id="/appendix/syntax/decimals/" title="The decimal Type" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/decimals/"><b>A1.4. </b>The decimal Type</a></li>
          <li data-nav-id="/appendix/syntax/const/" title="Read-Only and Constant Fields" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/const/"><b>A1.5. </b>Read-Only and Constant Fields</a></li>
          <li data-nav-id="/appendix/syntax/properties/" title="Properties" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/properties/"><b>A1.6. </b>Properties</a></li>
          <li data-nav-id="/appendix/syntax/indexers/" title="Indexers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/indexers/"><b>A1.7. </b>Indexers</a></li>
          <li data-nav-id="/appendix/syntax/static-this/" title="The Keywords static and this" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/static-this/"><b>A1.8. </b>The Keywords static and this</a></li>
          <li data-nav-id="/appendix/syntax/out-ref/" title="out and ref Parameters" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/out-ref/"><b>A1.9. </b>out and ref Parameters</a></li>
          <li data-nav-id="/appendix/syntax/foreach/" title="The foreach Statement" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/foreach/"><b>A1.10. </b>The foreach Statement</a></li>
          <li data-nav-id="/appendix/syntax/enumerators/" title="Enumerators" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/enumerators/"><b>A1.11. </b>Enumerators</a></li>
          <li data-nav-id="/appendix/syntax/switch/" title="The switch Statement" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/switch/"><b>A1.12. </b>The switch Statement</a></li>
          <li data-nav-id="/appendix/syntax/remainder/" title="The Remainder Operator" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/remainder/"><b>A1.13. </b>The Remainder Operator</a></li></ul></li>
          <li data-nav-id="/appendix/vs/" title="Visual Studio" class="dd-item"><input type="checkbox" id="section-805451f3a5b538fc2959767d013f4e16" class="toggle"/><label for="section-805451f3a5b538fc2959767d013f4e16" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/"><b>A2. </b>Visual Studio</a><ul>
          <li data-nav-id="/appendix/vs/installing-vs/" title="Installing Visual Studio" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/installing-vs/"><b>A2.1 </b>Installing Visual Studio</a></li>
          <li data-nav-id="/appendix/vs/repos/" title="Git Repositories" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/repos/"><b>A2.2. </b>Git Repositories</a></li>
          <li data-nav-id="/appendix/vs/solutions/" title="Visual Studio Solutions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/solutions/"><b>A2.3. </b>Visual Studio Solutions</a></li>
          <li data-nav-id="/appendix/vs/design-window/" title="The Design Window" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/design-window/"><b>A2.4. </b>The Design Window</a></li>
          <li data-nav-id="/appendix/vs/code-window/" title="The Code Window" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/code-window/"><b>A2.5. </b>The Code Window</a></li>
          <li data-nav-id="/appendix/vs/debugger/" title="The Debugger" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/debugger/"><b>A2.6. </b>The Debugger</a></li>
          <li data-nav-id="/appendix/vs/submitting/" title="Submitting Assignments" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/submitting/"><b>A2.7. </b>Submitting Assignments</a></li>
          <li data-nav-id="/appendix/vs/nunit/" title="Unit Testing" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/nunit/"><b>A2.8. </b>Unit Testing</a></li>
          <li data-nav-id="/appendix/vs/multiple/" title="Using Multiple Machines" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/multiple/"><b>A2.9. </b>Using Multiple Machines</a></li>
          <li data-nav-id="/appendix/vs/checkpointing/" title="Checkpointing" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/vs/checkpointing/"><b>A2.10. </b>Checkpointing</a></li></ul></li>
          <li data-nav-id="/appendix/style/" title="Programming Style Requirements" class="dd-item"><input type="checkbox" id="section-3c7d664b64b84c9f89fc48179979363e" class="toggle"/><label for="section-3c7d664b64b84c9f89fc48179979363e" ></label><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/"><b>A3. </b>Programming Style Requirements</a><ul>
          <li data-nav-id="/appendix/style/formatting/" title="General Formatting" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/formatting/"><b>A3.1. </b>General Formatting</a></li>
          <li data-nav-id="/appendix/style/access-modifiers/" title="Access Modifiers" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/access-modifiers/"><b>A3.2. </b>Access Modifiers</a></li>
          <li data-nav-id="/appendix/style/naming/" title="Naming Conventions" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/naming/"><b>A3.3. </b>Naming Conventions</a></li>
          <li data-nav-id="/appendix/style/comments/" title="Comments" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/comments/"><b>A3.4. </b>Comments</a></li>
          <li data-nav-id="/appendix/style/prohibited/" title="Prohibited Features" class="dd-item"><a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/prohibited/"><b>A3.5 </b>Prohibited Features</a></li></ul></li></ul></li>
        </ul>
        <div class="footermargin footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"></div>
        <hr class="default-animation footerLangSwitch footerVariantSwitch footerVisitedLinks footerFooter showVariantSwitch showFooter"/>
        <div id="prefooter" class="footerLangSwitch footerVariantSwitch footerVisitedLinks showVariantSwitch">
          <ul>
            <li id="select-language-container" class="footerLangSwitch">
              <a class="padding select-container">
                <i class="fas fa-language fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-language" onchange="location = baseUri + this.value;">
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
            </li>
            <li id="select-variant-container" class="footerVariantSwitch showVariantSwitch">
              <a class="padding select-container">
                <i class="fas fa-paint-brush fa-fw"></i>
                <span>&nbsp;</span>
                <div class="select-style">
                  <select id="select-variant" onchange="window.variants && variants.changeVariant( this.value );">
                    <option id="light-theme" value="light-theme" selected>Light Theme</option>
                    <option id="dark-theme" value="dark-theme">Dark Theme</option>
                  </select>
                </div>
                <div class="select-clear"></div>
              </a>
              <script>window.variants && variants.markSelectedVariant();</script>
            </li>
            <li class="footerVisitedLinks"><a class="padding" onclick="clearHistory();"><i class="fas fa-history fa-fw"></i> Clear History</a></li>
          </ul>
        </div>
        <div id="footer" class="footerFooter showFooter"><style>
  #footer {
    font-size: 13px;
    margin-left: auto;
    margin-right: auto;
    padding: 2rem 1rem;
    min-width: 230px;
    max-width: 300px;
  }
  #footer p {
    margin: 0;
  }
  </style>

<p>Built using <a href="http://gohugo.io/">Hugo</a> and <a href="https://github.com/ksu-cs-textbooks/hugo-theme-relearn">Hugo Relearn Theme</a> with assistance from Josh Weese and Russ Feldhausen.</p>
<br/>
<p>Microsoft and Visual Studio are either registered trademarks or trademarks of Microsoft Corporation in the United States and/or other countries. </p>
<br/>
<p><strong><i>© Copyright 2014-2023, <a href="http://people.cs.ksu.edu/~rhowell/" target="_">Rod Howell</a>. All rights reserved.</i></strong></p>

        </div>
      </div>
    </aside>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/clipboard.min.js?1686240615" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/perfect-scrollbar.min.js?1686240615" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/featherlight.min.js?1686240615" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://ksu-cs-textbooks.github.io/cis300/js/mathjax/tex-mml-chtml.js?1686240615"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/theme.js?1686240615" defer></script>
  </body>
</html>
