<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary Search Trees :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/trees/bst/</link><description>Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/trees/bst/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary Trees</title><link>https://textbooks.cs.ksu.edu/cis300/trees/bst/binary-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/bst/binary-trees/</guid><description>Binary Trees A binary tree is a tree in which each node has exactly two children, either of which may be empty. For example, the following is a binary tree:
Note that some of the nodes above are drawn with only one child or no children at all. In these cases, one or both children are empty. Note that we always draw one child to the left and one child to the right.</description></item><item><title>Introduction to Binary Search Trees</title><link>https://textbooks.cs.ksu.edu/cis300/trees/bst/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/bst/intro/</guid><description>Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases.</description></item><item><title>Removing from a Binary Search Tree</title><link>https://textbooks.cs.ksu.edu/cis300/trees/bst/remove/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/bst/remove/</guid><description>Removing from a Binary Search Tree Before we can discuss how to remove an element from a binary search tree, we must first define exactly how we want the method to behave. Consider first the case in which the tree is built from immutable nodes. We are given a key and a binary search tree, and we want to return the result of removing the element having the given key. However, we need to decide what we will do if there is no element having the given key.</description></item><item><title>Inorder Traversal</title><link>https://textbooks.cs.ksu.edu/cis300/trees/bst/inorder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/bst/inorder/</guid><description>Inorder Traversal When we store keys and values in an ordered dictionary, we typically want to be able to process the keys in increasing order. The “processing” that we do may be any of a number of things - for example, writing the keys and values to a file or adding them to the end of a list. Whatever processing we want to do, we want to do it increasing order of keys.</description></item></channel></rss>