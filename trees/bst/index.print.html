<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Binary Search Trees :: Data Structures in C#"><meta name=twitter:description content="Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/trees/bst/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Binary Search Trees :: Data Structures in C#"><meta property="og:description" content="Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Binary Search Trees :: Data Structures in C#"><meta itemprop=description content="Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="156"><title>Binary Search Trees :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723839635 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723839635 rel=stylesheet><link href=/cis300/css/fonts.css?1723839635 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723839635 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723839635 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723839635 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723839635 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723839635 rel=stylesheet><link href=/cis300/css/print.css?1723839635 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723839635 rel=stylesheet><script src=/cis300/js/variant.js?1723839635></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723839635 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/trees/bst/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/><span itemprop=name>Trees</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Binary Search Trees</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/intro/ title="Introduction to Trees (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/bst/binary-trees/ title="Binary Trees (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=binary-search-trees>Binary Search Trees</h1></div><h2 id=binary-search-trees>Binary Search Trees</h2><p>We motivated our discussion of trees by expressing a need for a linked
data structure that supports a binary search or something similar. We
will present such a data structure - a binary search tree - in this
section. While it will support efficient lookups, insertions, and
deletions for many applications, we will see that there are cases in
which it performs no better than a linked list. In <a href=/cis300/trees/avl/>the next
section</a>, we will add some
refinements that will guarantee good performance.</p><p>Before we can define a binary search tree, we need to define a more
primitive structure, a <em>binary tree</em>. We will then use binary trees to
define binary search trees, and show how to build them and search them.
We will then show how to remove elements from them. We conclude this
section by presenting the <em>inorder traversal</em> algorithm, which processes
all the elements in a binary search tree in order.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Binary Search Trees</h1><article class=default><header class=headline></header><div hidden><h1 id=binary-trees>Binary Trees</h1></div><h2 id=binary-trees>Binary Trees</h2><p>A <em>binary tree</em> is a tree in which each node has exactly two children,
either of which may be empty. For example, the following is a binary
tree:</p><p><a href=#R-image-e3edc6c312ab7a49ad6064f2b40df368 class=lightbox-link><img alt="A binary tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/bst/binary-trees/binary-tree.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e3edc6c312ab7a49ad6064f2b40df368><img alt="A binary tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/bst/binary-trees/binary-tree.jpg></a></p><p>Note that some of the nodes above are drawn with only one child or no
children at all. In these cases, one or both children are empty. Note
that we always draw one child to the left and one child to the right. As
a result, if one child is empty, we can always tell which child is empty
and which child is not. We call the two children the <em>left</em> child and
the <em>right</em> child.</p><p>We can implement a single node of a binary tree as a data structure and
use it to store data. The implementation is simple, like <a href=/cis300/linked-lists/intro/>the
implementation of a linked list
cell</a>. Let&rsquo;s call
this type <strong>BinaryTreeNode&lt;T></strong>, where <strong>T</strong> will be the type of data
we will store in it. We need three <strong>public</strong> properties:</p><ul><li>a <strong>Data</strong> property of type <strong>T</strong>;</li><li>a <strong>LeftChild</strong> property of type <strong>BinaryTreeNode&lt;T>?</strong>; and</li><li>a <strong>RightChild</strong> property of type <strong>BinaryTreeNode&lt;T>?</strong>.</li></ul><p>We can define both <strong>get</strong> and <strong>set</strong> accessors using the default
implementation for each of these properties. However, it is sometimes
advantageous to make this type immutable. In such a case, we would not
define any <strong>set</strong> accessors, but we would need to be sure to define a
constructor that takes three parameters to initialize these three
properties. While immutable nodes tend to degrade the performance
slightly, they also tend to be easier to work with. For example, with
immutable nodes it is impossible to build a structure with a cycle in
it.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=introduction-to-binary-search-trees>Introduction to Binary Search Trees</h1></div><h2 id=introduction-to-binary-search-trees>Introduction to Binary Search Trees</h2><p>In this section and <a href=/cis300/trees/bst/remove/>the
next</a>,
we will present a binary search tree as a data structure that can be
used to implement a
<a href=/cis300/dictionaries/>dictionary</a>
whose key type can be ordered. This implementation will provide
efficient lookups, insertions, and deletions in most cases; however,
there will be cases in which the performance is bad. In <a href=/cis300/trees/avl/>a later
section</a>,
we will show how to extend this good performance to all cases.</p><p>A <em>binary search tree</em> is a <a href=/cis300/trees/bst/binary-trees/>binary
tree</a> containing
key-value pairs whose keys can be ordered. Furthermore, the data items
are arranged such that the key in each node is:</p><ul><li>greater than all the keys in its left child; and</li><li>less than all the keys in its right child.</li></ul><p>Note that this implies that all keys must be unique. For example, the
following is a binary search tree storing integer keys (only the keys
are shown):</p><p><a href=#R-image-fbc5201ccb7a5bf3bcb9525d000650a0 class=lightbox-link><img alt="A binary search tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/bst/intro/binary-search-tree-ex.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-fbc5201ccb7a5bf3bcb9525d000650a0><img alt="A binary search tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/bst/intro/binary-search-tree-ex.jpg></a></p><p>The hierarchical nature of this structure allows us to do something like
a binary search to find a key. Suppose, for example, that we are looking
for 41 in the above tree. We first compare 41 with the key in the root.
Because 41 &lt; 54, we can safely ignore the right child, as all
keys there must be greater than 54. We therefore compare 41 to the key
in the root of the left child. Because 41 > 23, we look in the
right child, and compare 41 to 35. Because 41 > 35, we look in
the right child, where we find the key we are looking for.</p><p>Note the similarity of the search described above to a binary search. It
isn&rsquo;t exactly the same, because there is no guarantee that the root is
the middle element in the tree &mdash; in fact, it could be the first or the
last. In many applications, however, when we build a binary search tree
as we will describe below, the root of the tree tends to be roughly the
middle element. When this is the case, looking up a key is very
efficient. <a href=/cis300/trees/avl/>Later</a>, we will
show how we can build and maintain a binary search tree so that this is
always the case.</p><p>It isn&rsquo;t hard to implement the search strategy outlined above using a
loop. However, in order to reinforce the concept of recursion as a tree
processing technique, let&rsquo;s consider how we would implement the search
using recursion. The algorithm breaks into four cases:</p><ul><li>The tree is empty. In this case, the element we are looking for is
not present.</li><li>The key we are looking for is at the root - we have found what we
are looking for.</li><li>The key we are looking for is less than the key at the root. We then
need to look for the given key in the left child. Because this is a
smaller instance of our original problem, we can solve it using a
recursive call.</li><li>The key we are looking for is greater than the key at the root. We
then look in the right child using a recursive call.</li></ul><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>It is important to handle the case of an empty tree first, as the other
cases don&rsquo;t make sense if the tree is empty. In fact, if we are using
<strong>null</strong> to represent an empty binary search tree (as is fairly common),
we will get a compiler warning if we don&rsquo;t do this, and ultimately a <strong>NullReferenceException</strong> if we try to access the key
at an empty root.</p></div></div><p>If we need to compare
elements using a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-6.0#system-icomparable-1-compareto(-0)" rel=external target=_blank><strong>CompareTo</strong></a>
method, it would be more efficient to structure the code so that this
method is only called once; e.g.,</p><ul><li>If the tree is empty . . . .</li><li>Otherwise:<ul><li>Get the result of the comparison.</li><li>If the result is 0 . . . .</li><li>Otherwise, if the result is negative . . . .</li><li>Otherwise . . . .</li></ul></li></ul><p>This method would need to take two parameters &mdash; the key we are looking
for and the tree we are looking in. This second parameter will actually
be a reference to a node, which will either be the root of the tree or
<strong>null</strong> if the tree is empty. Because this method requires a parameter
that is not provided to the <strong>TryGetValue</strong> method, this method would be
a <strong>private</strong> method that the <strong>TryGetValue</strong> method can call. This
<strong>private</strong> method would then return the node containing the key, or
<strong>null</strong> if this key was not found. The <strong>TryGetValue</strong> method can be
implemented easily using this <strong>private</strong> method.</p><p>We also need to be able to implement the <strong>Add</strong> method. Let&rsquo;s first
consider how to do this assuming we are representing our binary search
tree with immutable nodes. The first thing to observe is that because we
can&rsquo;t modify an immutable node, we will need to build a binary search
tree containing the nodes in the current tree, plus a new node
containing the new key and value. In order to accomplish this, we will
describe a <strong>private</strong> recursive method that returns the result of
adding a given key and value to a given binary search tree. The <strong>Add</strong>
method will then need to call this <strong>private</strong> method and save the
resulting tree.</p><p>We therefore want to design a <strong>private</strong> method that will take three
parameters:</p><ul><li>a binary search tree (i.e., reference to a node);</li><li>the key we want to add; and</li><li>the value we want to add.</li></ul><p>It will return the binary search tree that results from adding the given
key and value to the given tree.</p><p>This method again has four cases:</p><ul><li>The tree is empty. In this case, we need to construct a node
containing the given key and value and two empty children, and
return this node as the resulting tree.</li><li>The root of the tree contains a key equal to the given key. In this
case, we can&rsquo;t add the item - we need to throw an exception.</li><li>The given key is less than the key at the root. We can then use a
recursive call to add the given key and value to the left child. The
tree returned by the recursive call needs to be the left child of
the result to be returned by the method. We therefore construct a
new node containing the data and right child from the given tree,
but having the result of the recursive call as its left child. We
return this new node.</li><li>The given key is greater than the key at the root. We use a
recursive call to add it to the right child, and construct a new
node with the result of the recursive call as its right child. We
return this new node.</li></ul><p>Note that the above algorithm only adds the given data item when it
reaches an empty tree. Not only is this the most straightforward way to
add items, but it also tends to keep paths in the tree short, as each
insertion is only lengthening one path. <a href=https://github.com/RodHowell-Algorithms/Tree-Viewer rel=external target=_blank>This
page</a> contains an
application that will
show the result of adding a key at a time to a binary search tree.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>The
keys in this application are treated as strings; hence, you can use
numbers if you want, but they will be compared as strings (e.g.,
&ldquo;10&rdquo; &lt; &ldquo;5&rdquo; because &lsquo;1&rsquo; &lt; &lsquo;5&rsquo;). For this reason, it is
usually better to use either letters, words, or integers that all have
the same number of digits.</p></div></div><p>The above algorithm can be implemented in the same way if mutable binary
tree nodes are used; however, we can improve its performance a bit by
avoiding the construction of new nodes when recursive calls are made.
Instead, we can change the child to refer to the tree returned. If we
make this optimization, the tree we return will be the same one that we
were given in the cases that make recursive calls. However, we still
need to construct a new node in the case in which the tree is empty. For
this reason, it is still necessary to return the resulting tree, and we
need to make sure that the <strong>Add</strong> method always uses the returned tree.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=removing-from-a-binary-search-tree>Removing from a Binary Search Tree</h1></div><h2 id=removing-from-a-binary-search-tree>Removing from a Binary Search Tree</h2><p>Before we can discuss how to remove an element from a binary search
tree, we must first define exactly how we want the method to behave.
Consider first the case in which the tree is built from immutable nodes.
We are given a key and a binary search tree, and we want to return the
result of removing the element having the given key. However, we need to
decide what we will do if there is no element having the given key. This
does not seem to be exceptional behavior, as we may have no way of
knowing in advance whether the key is in the tree (unless we waste time
looking for it). Still, we might want to know whether the key was found.
We therefore need two pieces of information from this method - the
resulting tree and a <strong>bool</strong> indicating whether the key was found. In
order to accommodate this second piece of information, we make the
<strong>bool</strong> an <a href=/cis300/appendix/syntax/out-ref/><strong>out</strong> parameter</a>.</p><p>We can again break the problem into cases and use recursion, as we did
for <a href=/cis300/trees/bst/intro/>adding an element</a>. However, removing an element is complicated by the fact that its node
might have two nonempty children. For example, suppose we want to remove
the element whose key is 54 in the following binary search tree:</p><p><a href=#R-image-b1c0a9129501d594065405d08aee1b9d class=lightbox-link><img alt="A binary search tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/bst/remove/binary-search-tree-ex.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b1c0a9129501d594065405d08aee1b9d><img alt="A binary search tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/bst/remove/binary-search-tree-ex.jpg></a></p><p>In order to preserve the correct ordering of the keys, we should replace
54 with either the next-smaller key (i.e., 41) or the next-larger key
(i.e., 64). By convention, we will replace it with the next-larger key,
which is the smallest key in its right child. We therefore have a
sub-problem to solve - removing the element with the smallest key from a
nonempty binary search tree. We will tackle this problem first.</p><p>Because we will not need to remove the smallest key from an empty tree,
we don&rsquo;t need to worry about whether the removal was successful - a
nonempty binary search tree always has a smallest key. However, we still
need two pieces of information from this method:</p><ul><li>the element removed (so that we can use it to replace the element to
be removed in the original problem); and</li><li>the resulting tree (so that we can use it as the new right child in
solving the original problem).</li></ul><p>We will therefore use an <strong>out</strong> parameter for the element removed, and
return the resulting tree.</p><p>Because we don&rsquo;t need to worry about empty trees, and because the
smallest key in a binary search tree is never larger than the key at the
root, we only have two cases:</p><ul><li>The left child is empty. In this case, there are no keys smaller
than the key at the root; i.e., the key at the root is the smallest.
We therefore assign the data at the root to the <strong>out</strong> parameter,
and return the right child, which is the result of removing the
root.</li><li>The left child is nonempty. In this case, there is a key smaller
than the key at the root; furthermore, it must be in the left child.
We therefore use a recursive call on the left child to obtain the
result of removing the element with the smallest key from that child. We
can pass as the <strong>out</strong> parameter to this recursive call the <strong>out</strong>
parameter that we were given - the recursive call will assign to it
the element removed. Because our nodes are immutable, we then need to construct a new node whose data
and right child are the same as in the given tree, but whose left
child is the tree returned by the recursive call. We return this
node.</li></ul><p>Having this sub-problem solved, we can now return to the original
problem. We again have four cases, but one of these cases breaks into
three sub-cases:</p><ul><li>The tree is empty. In this case the key we are looking for is not
present, so we set the <strong>out</strong> parameter to <strong>false</strong> and return an
empty tree.</li><li>The key we are looking for is at the root. In this case, we can set
the <strong>out</strong> parameter to <strong>true</strong>, but in order to remove the
element, we have three sub-cases:<ul><li>The left child is empty. We can then return the right child (the
result of removing the root).</li><li>The right child is empty. We can then return the left child.</li><li>Both children are nonempty. We must then obtain the result of
removing the smallest key from the right child. We then
construct a new node whose data is the element removed from the
right child, the left child is the left child of the given tree,
and the right child is the result of removing the smallest key
from that child. We return this node.</li></ul></li><li>The key we are looking for is less than the key at the root. We then
obtain the result of removing this key from the left child using a
recursive call. We can pass as the <strong>out</strong> parameter to this
recursive call the <strong>out</strong> parameter we were given and let the
recursive call set its value. We then construct a new node whose
data and right child are the same as in the given tree, but whose
left child is the tree returned by the recursive call. We return
this node.</li><li>The key we are looking for is greater than the key at the root. This
case is symmetric to the above case.</li></ul><p>As we did with adding elements, we can optimize the methods described
above for mutable nodes by modifying the contents of a node rather than
constructing new nodes.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=inorder-traversal>Inorder Traversal</h1></div><h2 id=inorder-traversal>Inorder Traversal</h2><p>When we store keys and values in an ordered dictionary, we typically
want to be able to process the keys in increasing order. The
&ldquo;processing&rdquo; that we do may be any of a number of things - for example,
writing the keys and values to a file or adding them to the end of a
list. Whatever processing we want to do, we want to do it increasing
order of keys.</p><p>If we are implementing the dictionary using a binary search tree, this
may at first seem to be a rather daunting task. Consider traversing the
keys in the following binary search tree in increasing order:</p><p><a href=#R-image-e18d1290959d061030d767d76da40c51 class=lightbox-link><img alt="A binary search tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/bst/inorder/binary-search-tree-ex.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e18d1290959d061030d767d76da40c51><img alt="A binary search tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/bst/inorder/binary-search-tree-ex.jpg></a></p><p>Processing these keys in order involves frequent jumps in the tree, such
as from 17 to 23 and from 41 to 54. It may not be immediately obvious
how to proceed. However, if we just think about it with the purpose of
writing a recursive method, it actually becomes rather straightforward.</p><p>As with most tree-processing algorithms, if the given tree is nonempty,
we start at the root (if it is empty, there are no nodes to process).
However, the root isn&rsquo;t necessarily the first node that we want to
process, as there may be keys that are smaller than the one at the root.
These key are all in the left child. We therefore want to process first
all the nodes in the left child, in increasing order of their keys. This
is a smaller instance of our original problem - a recursive call on the
left child solves it. At this point all of the keys less than the one at
the root have been processed. We therefore process the root next
(whatever the &ldquo;processing&rdquo; might be). This just leaves the nodes in the
right child, which we want to process in increasing order of their keys.
Again, a recursive call takes care of this, and we are finished.</p><p>The entire algorithm is therefore as follows:</p><ul><li>If the given tree is nonempty:<ul><li>Do a recursive call on the left child to process all the nodes
in it.</li><li>Process the root.</li><li>Do a recursive call on the right child to process all the nodes
in it.</li></ul></li></ul><p>This algorithm is known as an <em>inorder traversal</em> because it processes
the root between the processing of the two children. Unlike <a href=/cis300/trees/intro/>preorder
traversal</a>, this
algorithm only makes sense for binary trees, as there must be exactly
two children in order for &ldquo;between&rdquo; to make sense.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5>May 22, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723839635 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723839635 defer></script><script src=/cis300/js/theme.js?1723839635 defer></script></body></html>