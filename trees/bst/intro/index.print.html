<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to Binary Search Trees :: Data Structures in C#"><meta name=twitter:description content="Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/trees/bst/intro/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Introduction to Binary Search Trees :: Data Structures in C#"><meta property="og:description" content="Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Trees"><meta property="article:modified_time" content="2023-06-07T09:47:27-05:00"><meta itemprop=name content="Introduction to Binary Search Trees :: Data Structures in C#"><meta itemprop=description content="Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases."><meta itemprop=dateModified content="2023-06-07T09:47:27-05:00"><meta itemprop=wordCount content="1361"><title>Introduction to Binary Search Trees :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737740581 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737740581 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737740581 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737740581 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737740581 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737740581 rel=stylesheet><link href=/cis300/css/fonts.css?1737740581 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737740581 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737740581 rel=stylesheet><link href=/cis300/css/theme-auto.css?1737740581 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1737740581 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737740581 rel=stylesheet><link href=/cis300/css/print.css?1737740581 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1737740581 rel=stylesheet><script src=/cis300/js/variant.js?1737740581></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737740581 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/trees/bst/intro/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/><span itemprop=name>Trees</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/trees/bst/><span itemprop=name>Binary Search Trees</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Introduction to Binary Search Trees</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/bst/binary-trees/ title="Binary Trees (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/trees/bst/remove/ title="Removing from a Binary Search Tree (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=introduction-to-binary-search-trees>Introduction to Binary Search Trees</h1></div><h2 id=introduction-to-binary-search-trees>Introduction to Binary Search Trees</h2><p>In this section and <a href=/cis300/trees/bst/remove/>the
next</a>,
we will present a binary search tree as a data structure that can be
used to implement a
<a href=/cis300/dictionaries/>dictionary</a>
whose key type can be ordered. This implementation will provide
efficient lookups, insertions, and deletions in most cases; however,
there will be cases in which the performance is bad. In <a href=/cis300/trees/avl/>a later
section</a>,
we will show how to extend this good performance to all cases.</p><p>A <em>binary search tree</em> is a <a href=/cis300/trees/bst/binary-trees/>binary
tree</a> containing
key-value pairs whose keys can be ordered. Furthermore, the data items
are arranged such that the key in each node is:</p><ul><li>greater than all the keys in its left child; and</li><li>less than all the keys in its right child.</li></ul><p>Note that this implies that all keys must be unique. For example, the
following is a binary search tree storing integer keys (only the keys
are shown):</p><p><a href=#R-image-09e19280334b7e2acf9ee98f11f28575 class=lightbox-link><img alt="A binary search tree" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/trees/bst/intro/binary-search-tree-ex.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-09e19280334b7e2acf9ee98f11f28575><img alt="A binary search tree" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/trees/bst/intro/binary-search-tree-ex.jpg></a></p><p>The hierarchical nature of this structure allows us to do something like
a binary search to find a key. Suppose, for example, that we are looking
for 41 in the above tree. We first compare 41 with the key in the root.
Because 41 &lt; 54, we can safely ignore the right child, as all
keys there must be greater than 54. We therefore compare 41 to the key
in the root of the left child. Because 41 > 23, we look in the
right child, and compare 41 to 35. Because 41 > 35, we look in
the right child, where we find the key we are looking for.</p><p>Note the similarity of the search described above to a binary search. It
isn&rsquo;t exactly the same, because there is no guarantee that the root is
the middle element in the tree &mdash; in fact, it could be the first or the
last. In many applications, however, when we build a binary search tree
as we will describe below, the root of the tree tends to be roughly the
middle element. When this is the case, looking up a key is very
efficient. <a href=/cis300/trees/avl/>Later</a>, we will
show how we can build and maintain a binary search tree so that this is
always the case.</p><p>It isn&rsquo;t hard to implement the search strategy outlined above using a
loop. However, in order to reinforce the concept of recursion as a tree
processing technique, let&rsquo;s consider how we would implement the search
using recursion. The algorithm breaks into four cases:</p><ul><li>The tree is empty. In this case, the element we are looking for is
not present.</li><li>The key we are looking for is at the root - we have found what we
are looking for.</li><li>The key we are looking for is less than the key at the root. We then
need to look for the given key in the left child. Because this is a
smaller instance of our original problem, we can solve it using a
recursive call.</li><li>The key we are looking for is greater than the key at the root. We
then look in the right child using a recursive call.</li></ul><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>It is important to handle the case of an empty tree first, as the other
cases don&rsquo;t make sense if the tree is empty. In fact, if we are using
<strong>null</strong> to represent an empty binary search tree (as is fairly common),
we will get a compiler warning if we don&rsquo;t do this, and ultimately a <strong>NullReferenceException</strong> if we try to access the key
at an empty root.</p></div></div><p>If we need to compare
elements using a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-6.0#system-icomparable-1-compareto(-0)" rel=external target=_blank><strong>CompareTo</strong></a>
method, it would be more efficient to structure the code so that this
method is only called once; e.g.,</p><ul><li>If the tree is empty . . . .</li><li>Otherwise:<ul><li>Get the result of the comparison.</li><li>If the result is 0 . . . .</li><li>Otherwise, if the result is negative . . . .</li><li>Otherwise . . . .</li></ul></li></ul><p>This method would need to take two parameters &mdash; the key we are looking
for and the tree we are looking in. This second parameter will actually
be a reference to a node, which will either be the root of the tree or
<strong>null</strong> if the tree is empty. Because this method requires a parameter
that is not provided to the <strong>TryGetValue</strong> method, this method would be
a <strong>private</strong> method that the <strong>TryGetValue</strong> method can call. This
<strong>private</strong> method would then return the node containing the key, or
<strong>null</strong> if this key was not found. The <strong>TryGetValue</strong> method can be
implemented easily using this <strong>private</strong> method.</p><p>We also need to be able to implement the <strong>Add</strong> method. Let&rsquo;s first
consider how to do this assuming we are representing our binary search
tree with immutable nodes. The first thing to observe is that because we
can&rsquo;t modify an immutable node, we will need to build a binary search
tree containing the nodes in the current tree, plus a new node
containing the new key and value. In order to accomplish this, we will
describe a <strong>private</strong> recursive method that returns the result of
adding a given key and value to a given binary search tree. The <strong>Add</strong>
method will then need to call this <strong>private</strong> method and save the
resulting tree.</p><p>We therefore want to design a <strong>private</strong> method that will take three
parameters:</p><ul><li>a binary search tree (i.e., reference to a node);</li><li>the key we want to add; and</li><li>the value we want to add.</li></ul><p>It will return the binary search tree that results from adding the given
key and value to the given tree.</p><p>This method again has four cases:</p><ul><li>The tree is empty. In this case, we need to construct a node
containing the given key and value and two empty children, and
return this node as the resulting tree.</li><li>The root of the tree contains a key equal to the given key. In this
case, we can&rsquo;t add the item - we need to throw an exception.</li><li>The given key is less than the key at the root. We can then use a
recursive call to add the given key and value to the left child. The
tree returned by the recursive call needs to be the left child of
the result to be returned by the method. We therefore construct a
new node containing the data and right child from the given tree,
but having the result of the recursive call as its left child. We
return this new node.</li><li>The given key is greater than the key at the root. We use a
recursive call to add it to the right child, and construct a new
node with the result of the recursive call as its right child. We
return this new node.</li></ul><p>Note that the above algorithm only adds the given data item when it
reaches an empty tree. Not only is this the most straightforward way to
add items, but it also tends to keep paths in the tree short, as each
insertion is only lengthening one path. <a href=https://github.com/RodHowell-Algorithms/Tree-Viewer rel=external target=_blank>This
page</a> contains an
application that will
show the result of adding a key at a time to a binary search tree.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>The
keys in this application are treated as strings; hence, you can use
numbers if you want, but they will be compared as strings (e.g.,
&ldquo;10&rdquo; &lt; &ldquo;5&rdquo; because &lsquo;1&rsquo; &lt; &lsquo;5&rsquo;). For this reason, it is
usually better to use either letters, words, or integers that all have
the same number of digits.</p></div></div><p>The above algorithm can be implemented in the same way if mutable binary
tree nodes are used; however, we can improve its performance a bit by
avoiding the construction of new nodes when recursive calls are made.
Instead, we can change the child to refer to the tree returned. If we
make this optimization, the tree we return will be the same one that we
were given in the cases that make recursive calls. However, we still
need to construct a new node in the case in which the tree is empty. For
this reason, it is still necessary to return the resulting tree, and we
need to make sure that the <strong>Add</strong> method always uses the returned tree.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Rod Howell
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/3e0469bee25761d3b32ffe45d587c629a8118d82>Jun 7, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1737740581 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737740581 defer></script><script src=/cis300/js/theme.js?1737740581 defer></script></body></html>