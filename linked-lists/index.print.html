<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linked Lists :: Data Structures in C#"><meta name=twitter:description content="Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/linked-lists/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Linked Lists :: Data Structures in C#"><meta property="og:description" content="Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Linked Lists :: Data Structures in C#"><meta itemprop=description content="Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="107"><title>Linked Lists :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1756138920 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1756138920 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1756138920 rel=stylesheet><link href=/cis300/css/auto-complete.css?1756138920 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1756138920 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1756138920 rel=stylesheet><link href=/cis300/css/fonts.css?1756138920 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1756138920 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1756138920 rel=stylesheet><link href=/cis300/css/theme-auto.css?1756138920 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1756138920 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1756138920 rel=stylesheet><link href=/cis300/css/print.css?1756138920 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1756138920 rel=stylesheet><script src=/cis300/js/variant.js?1756138920></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1756138920 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/linked-lists/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Linked Lists</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/stacks-queues/queue-impl/ title="Implementing a Queue (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/linked-lists/intro/ title="Introduction to Linked Lists (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=linked-lists>Linked Lists</h1></div><h2 id=linked-lists>Linked Lists</h2><p>Using arrays to implement data structures has performance advantages in
some cases, but this technique has its limitations. With this chapter,
we begin a study of data structures that use <a href=/cis300/appendix/syntax/reference-value/>reference
types</a> in a powerful
way. Rather than forming sequences by placing data items in adjacent
cells of an array, we instead use references to chain data elements
together in a sequence. For some applications, this ends up being more
efficient than using an array. As we will see in <a href=/cis300/trees/>a later
chapter</a>, this chaining
technique can be further exploited to link data items in a hierarchical
way, providing even more flexible and efficient access.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Linked Lists</h1><article class=default><header class=headline></header><div hidden><h1 id=introduction-to-linked-lists>Introduction to Linked Lists</h1></div><h2 id=introduction-to-linked-lists>Introduction to Linked Lists</h2><p>To build a linked list, we first need to define a simple <strong>class</strong>,
which we will call <strong>LinkedListCell&lt;T></strong>. Instances of this class will
be the individual building blocks that we will chain together to form
linked lists. <strong>T</strong> will be the type of the data item we will store in
each cell - i.e., the type of the data items that we will store in the
linked list.</p><p>A <strong>LinkedListCell&lt;T></strong> will contain two <strong>public</strong>
properties, which can each be implemented using the default
implementation:</p><ul><li>The <strong>Data</strong> property gets or sets the data item (of type <strong>T</strong>)
stored in the cell.</li><li>The <strong>Next</strong> property gets or sets the next <strong>LinkedListCell&lt;T>?</strong>
in the linked list. If there is no next cell, it gets <strong>null</strong>.</li></ul><p>Because this is a <strong>class</strong>, it is a <a href=/cis300/appendix/syntax/reference-value/>reference
type</a>; hence, the
<strong>Next</strong> property will store a reference to another
<strong>LinkedListCell&lt;T></strong>.</p><p>The only other member of this class is a <strong>public</strong> constructor. Because we don&rsquo;t want to make <strong>Data</strong> nullable unless the user code specifies a nullable type for <strong>T</strong>, we need to make sure it is initialized to an appropriate value. For this purpose, we use a <strong>public</strong> constructor that takes the following parameters:</p><ul><li>The initial <strong>Data</strong> value (of type <strong>T</strong>).</li><li>The next cell in the list (of type <strong>LinkedListCell&lt;T>?</strong>).</li></ul><p>It simply sets the values of the two properties to the given parameters.</p><p>Although the <strong>LinkedListCell&lt;T></strong> class is simple, we can use its
<strong>Next</strong> property to chain together long sequences of its instances:</p><p><a href=#R-image-6b5e71890b2c3eb5158198445a943237 class=lightbox-link><img alt="A linked list" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-example.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6b5e71890b2c3eb5158198445a943237><img alt="A linked list" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-example.jpg></a></p><p>In the above figure, <code>p</code> is a <strong>LinkedListCell&lt;string></strong> variable.
Each box in the figure represents an instance of
<strong>LinkedListCell&lt;string></strong>. The boxes are each divided into two
regions to indicate the two <strong>public</strong> properties for each cell. Because
<strong>string</strong> is a reference type, we have shown each <strong>Data</strong> property as
a reference to a <strong>string</strong>. The rightmost arrow that is bent downward
is used to represent <strong>null</strong>. The entire sequence of
<strong>LinkedListCell&lt;string></strong>s is called a <em>linked list</em>. Given this
linked list:</p><ul><li><code>p.Data</code> is &ldquo;Now&rdquo;;</li><li><code>p.Next.Data</code> is &ldquo;is&rdquo;;</li><li><code>p.Next.Next.Data</code> is &ldquo;the&rdquo;;</li><li><code>p.Next.Next.Next.Data</code> is &ldquo;time&rdquo;; and</li><li><code>p.Next.Next.Next.Next</code> is <strong>null</strong> (if we try to get its <strong>Data</strong>
property, we will get a <strong>NullReferenceException</strong>).</li></ul><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p>When writing code for using and manipulating linked lists, it is helpful to draw pictures of the lists, as we do throughout this chapter.</p></div></div><p>Suppose we want to insert the <strong>string</strong> &ldquo;Notice:&rdquo; at the beginning of
this linked list. We use the <strong>LinkedListCell&lt;T></strong> constructor to initialize a new cell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>LinkedListCell</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>cell</span> <span class=p>=</span> <span class=k>new</span><span class=p>(</span><span class=s>&#34;Notice&#34;</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span></span></span></code></pre></div><p>This yields the following:</p><p><a href=#R-image-32960b27c046a34873e3fc948bbede70 class=lightbox-link><img alt="Linking in the cell" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-insert-2.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-32960b27c046a34873e3fc948bbede70><img alt="Linking in the cell" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-insert-2.jpg></a></p><p>This is what we want, unless we want <code>p</code> to refer to the beginning of
the linked list. We can take care of this by copying the value of <code>cell</code>
to <code>p</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>p</span> <span class=p>=</span> <span class=n>cell</span><span class=p>;</span></span></span></code></pre></div><p>This yields the following (we are not showing <code>cell</code> because we are no
longer interested in it, but it still refers to the same cell):</p><p><a href=#R-image-6f5c545113402096d9469e7187b593fa class=lightbox-link><img alt="Completing the insertion" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-insert-3.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6f5c545113402096d9469e7187b593fa><img alt="Completing the insertion" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-insert-3.jpg></a></p><p>We can also undo the above statement by copying into <code>p</code> the reference
in the <strong>Next</strong> property of the cell to which <code>p</code> refers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>p</span> <span class=p>=</span> <span class=n>p</span><span class=p>.</span><span class=n>Next</span><span class=p>;</span></span></span></code></pre></div><p>(If this statement occurs in a context in which the compiler cannot determine that <code>p</code> is not <strong>null</strong>, an <code>!</code> will need to be inserted prior to <code>.Next</code>.) This yields the following:</p><p><a href=#R-image-f8dcb0eedf98251588b5eca1b70c54d9 class=lightbox-link><img alt="Removing the first cell" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-remove-first.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-f8dcb0eedf98251588b5eca1b70c54d9><img alt="Removing the first cell" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-remove-first.jpg></a></p><p>This has the effect of removing &ldquo;Notice:&rdquo; from the linked list to which
<code>p</code> refers. Though we haven&rsquo;t shown it, <code>cell</code> still refers to the cell
containing &ldquo;Notice:&rdquo;; hence, we still have access to the linked list
beginning with this cell. However, if the program had no references
remaining to this cell, we would have no way to retrieve it, and it
would be available for garbage collection. This illustrates how we must
take care not to lose a part of a linked list (unless we are finished
with it) when we are manipulating it.</p><p>With a little more work, cells can be inserted into or removed from
arbitrary locations in a linked list. We will discuss how to do this in
subsequent sections. For now let us simply observe that linked lists do
not always continue until they reach a <strong>null</strong> - they can contain
cycles, as follows:</p><p><a href=#R-image-1d06fc10608898ab0b994161c044d37b class=lightbox-link><img alt="A linked list with a cycle" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-cycle.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-1d06fc10608898ab0b994161c044d37b><img alt="A linked list with a cycle" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/intro/linked-list-cycle.jpg></a></p><p>This is occasionally what we want, but more often, this is a programming
error that leads to an infinite loop.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-stacks-and-queues-with-linked-lists>Implementing Stacks and Queues with Linked Lists</h1></div><h2 id=implementing-stacks-and-queues-with-linked-lists>Implementing Stacks and Queues with Linked Lists</h2><p>Because linked lists store data elements in linear sequences, they can
be used to give alternative implementations of stacks and queues. One
advantage to using linked lists is that we don&rsquo;t have to worry about
filling up something like an array - we can just keep allocating cells
as long as we need to (unless we run out of memory).</p><p>Implementing a stack using a linked list is particularly easy because
all accesses to a stack are at the top. One end of a linked list, the
beginning, is always directly accessible. We should therefore arrange
the elements so that the top element of the stack is at the beginning of
the linked list, and the bottom element of the stack is at the end of
the linked list. We can represent an empty stack with <strong>null</strong>.</p><p>We therefore need a <strong>private LinkedListCell&lt;T>?</strong> field to implement a
generic stack <strong>Stack&lt;T></strong> using a linked list. This field will refer
to the cell containing the data item at the top of the stack. If the stack is empty, this field will be <strong>null</strong>; hence, this field should be <strong>null</strong> initially. A <strong>public
Count</strong> property will be used to keep track of the number of elements in
the stack.</p><p>The <strong>public</strong> methods <strong>Push</strong>, <strong>Peek</strong>, and <strong>Pop</strong> are then fairly
straightforward to implement. For <strong>Push</strong> we need to add the given
element to a new cell at the beginning of the linked list, as shown in
<a href=/cis300/linked-lists/intro/>the previous
section</a>, and
update the <strong>Count</strong>. To implement <strong>Peek</strong>, if the stack is nonempty,
we simply return the <strong>Data</strong> property of the cell at the beginning of
the linked list; otherwise, we throw an <strong>InvalidOperationException</strong>. Note that we can determine whether the stack is empty by examining either the <strong>LinkedListCell&lt;T>?</strong> field or the <strong>Count</strong> property; however, examining the <strong>LinkedListCell&lt;T>?</strong> field allows the compiler to determine that the <strong>Data</strong> property of the first cell can be accessed without throwing a <strong>NullReferenceException</strong>.</p><p>To implement <strong>Pop</strong>:</p><ol><li>Using <strong>Peek</strong>, obtain the element to be returned.</li><li>Remove the first element from the linked list as shown in <a href=/cis300/linked-lists/intro/>the
previous
section</a>.</li><li>Update the <strong>Count</strong>.</li><li>Return the retrieved value.</li></ol><p>Note that the call to <strong>Peek</strong> in step 1 ensures that the stack is nonempty before we remove the first element; however, the compiler won&rsquo;t be able to determine this.</p><p>Implementing a queue is a little more involved because we need to
operate at both ends of the linked list. For efficiency, we should keep
a reference to the last cell in the linked list, as this will allow us
to access both ends of the linked list directly. We will therefore have
the following:</p><p><a href=#R-image-3e87e19cb0d439ea3e981073682de687 class=lightbox-link><img alt="Implementing a queue with a linked list" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-3e87e19cb0d439ea3e981073682de687><img alt="Implementing a queue with a linked list" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-queue.jpg></a></p><p>We now need to decide which end to make the front of the queue. As we
saw in <a href=/cis300/linked-lists/intro/>the previous
section</a>, both
inserting and removing can be done efficiently at the beginning of a
linked list. Likewise, it is easy to insert an element at the end if we
have a reference to the last cell. Suppose, for example, that <code>last</code>
refers to the last cell in a linked list, and that <code>cell</code> refers to a
<strong>LinkedListCell&lt;T></strong> that we want to insert at the end. Suppose
further that the linked list is not empty (that will be a special case
that we&rsquo;ll need to handle). Thus, we have the following:</p><p><a href=#R-image-6100c87973cca9b6b27e168e509f5e4a class=lightbox-link><img alt="A cell to insert at the end of a linked\nlist" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-insert-end-1.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6100c87973cca9b6b27e168e509f5e4a><img alt="A cell to insert at the end of a linked\nlist" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-insert-end-1.jpg></a></p><p>To insert this cell at the end of the linked list, we just need to copy
the reference in <code>cell</code> to the <strong>Next</strong> property of the cell to which
<code>last</code> refers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>last</span><span class=p>.</span><span class=n>Next</span> <span class=p>=</span> <span class=n>cell</span><span class=p>;</span></span></span></code></pre></div><p>On the other hand, removing the last cell is problematic, even if we
have a reference to it. The problem is that in order to remove it from
the linked list, we need to change the <strong>Next</strong> property of the
preceding cell. Unfortunately, the only way to obtain that cell is to
start at the beginning of the list and work our way through it. If the
linked list is long, this could be quite inefficient.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>It doesn&rsquo;t help any to keep a reference to the next-to-last cell, as
we encounter the same problem when we need to update this reference
after removing the last cell &mdash; we don&rsquo;t have a reference to its
preceding cell.</p></div></div><p>Because we need to
remove elements from the front of a queue, but not from the back, we
conclude that it will work best to make the beginning of the linked list
the front of the queue. We therefore need the following <strong>private</strong>
fields to implement a generic queue <strong>Queue&lt;T></strong>:</p><ul><li>A <strong>LinkedListCell&lt;T>?</strong> giving the element at the front of the
queue. This will be the beginning of the linked list of queue
elements.</li><li>A <strong>LinkedListCell&lt;T>?</strong> giving the element at the back of the
queue. This will be the last cell in the linked list of queue
elements.</li></ul><p>As we mentioned earlier, adding an element to an empty queue is a
special case that we will need to handle separately. For this reason, it
doesn&rsquo;t matter what values the two <strong>LinkedListCell&lt;T>?</strong> fields
contain when the queue is empty - we can always detect when the queue is
empty by checking the <strong>Count</strong>. The initialization of the two
<strong>LinkedListCell&lt;T>?</strong> fields is therefore unimportant. It is easiest
to just leave them <strong>null</strong>.</p><p>Let us now consider the implementation of the <strong>Enqueue</strong> method. We
need to consider two cases. We&rsquo;ll first consider the case in which the
queue is empty. In this case, we need to build the following linked
list:</p><p><a href=#R-image-468a6a3d138c2373ef1ec962be8fc9dc class=lightbox-link><img alt="A queue containing a single linked list cell" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/one-cell-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-468a6a3d138c2373ef1ec962be8fc9dc><img alt="A queue containing a single linked list cell" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/one-cell-queue.jpg></a></p><p>We therefore need to:</p><ol><li>Construct a new <strong>LinkedListCell&lt;T></strong> containing the element we want to enqueue and no next cell.</li><li>Assign it to the field denoting the front of the queue.</li><li>Assign it to the field denoting the back of the queue.</li><li>Update the <strong>Count</strong>.</li></ol><p>If the queue is nonempty, the only step that changes is Step 2. Because
the queue is nonempty, we don&rsquo;t want to make the new cell the front of
the queue; instead, we need to insert it at the end of the linked list,
as outlined above.</p><p>The implementations of the <strong>Peek</strong> and <strong>Dequeue</strong> methods are
essentially the same as the implementations of the <strong>Peek</strong> and <strong>Pop</strong>
methods, respectively, for a stack.</p><p>The implementations described in this section are simpler than the
implementations using arrays, mainly due to the fact that we don&rsquo;t need
to rebuild the structure when we fill up the space available. While
these implementations are also pretty efficient, it turns out that the
array-based implementations tend to out-perform the linked-list-based
implementations. This might be counterintuitive at first because
rebuilding the structures when the array is filled is expensive.
However, due to the fact that we double the size of the array each time
we need a new one, this rebuilding is done so rarely in practice that it
ends up having minimal impact on performance. Due to hardware and
low-level software issues, the overhead involved in using arrays usually
ends up being less.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=finding-prime-numbers>Finding Prime Numbers</h1></div><h2 id=finding-prime-numbers>Finding Prime Numbers</h2><p>An integer greater than
<span class="math align-center">$ 1 $</span> is said to be <em>prime</em> if it is not divisible
by any positive integers other than itself and <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span> Thus, <span style=white-space:nowrap><span class="math align-center">$ 2 $</span>,</span> <span style=white-space:nowrap><span class="math align-center">$ 3 $</span>,</span> and
<span class="math align-center">$ 5 $</span> are
prime, but not
<span class="math align-center">$ 1 $</span> (it is not greater than <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>)</span> or
<span class="math align-center">$ 4 $</span> (it is divisible by <span style=white-space:nowrap><span class="math align-center">$ 2 $</span>).</span>
Because every integer is divisible by itself and <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>,</span> we will call any
other positive factors <em>nontrivial factors</em>; thus, a prime number is an
integer greater than
<span class="math align-center">$ 1 $</span> that has no nontrivial factors. The study of
prime numbers dates back to at least the third century BC. One of the
earliest known algorithms finds all prime numbers less than a given
integer <span style=white-space:nowrap><span class="math align-center">$ n $</span>.</span> This algorithm is known as the <em>Sieve of Eratosthenes</em>, and
is attributed to the Greek mathematician Eratosthenes of Cyrene (c. 276
BC - c. 194 BC).</p><p>The most basic version of this algorithm operates as follows:</p><ol><li>Place all integers greater than
<span class="math align-center">$ 1 $</span> and less than
<span class="math align-center">$ n $</span> in order in a
list.</li><li>For each element
<span class="math align-center">$ k $</span> in the list, remove all subsequent elements
that are divisible by <span style=white-space:nowrap><span class="math align-center">$ k $</span>.</span></li><li>The remaining values are the prime numbers less than <span style=white-space:nowrap><span class="math align-center">$ n $</span>.</span></li></ol><p>For example, suppose <span style=white-space:nowrap><span class="math align-center">$ n = 20 $</span>.</span> We then place the integers from
<span class="math align-center">$ 2 $</span>
to
<span class="math align-center">$ 19 $</span> in a list:
<span class="math align-left">$$
2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10\ 11\ 12\ 13\ 14\ 15\ 16\ 17\ 18\ 19
$$
</span>We then remove all numbers following
<span class="math align-center">$ 2 $</span> that are divisible by <span style=white-space:nowrap><span class="math align-center">$ 2 $</span>:</span>
<span class="math align-left">$$
\require{cancel}
2\ 3\ \cancel{4}\ 5\ \cancel{6}\ 7\ \cancel{8}\ 9\ \cancel{10}\ 11\
\cancel{12}\ 13\ \cancel{14}\ 15\ \cancel{16}\ 17\ \cancel{18}\ 19
$$
</span>We then remove all numbers following
<span class="math align-center">$ 3 $</span> that are divisible by <span style=white-space:nowrap><span class="math align-center">$ 3 $</span>:</span>
<span class="math align-left">$$
2\ 3\ \cancel{4}\ 5\ \cancel{6}\ 7\ \cancel{8}\ \cancel{9}\ \cancel{10}\ 11\
\cancel{12}\ 13\ \cancel{14}\ \cancel{15}\ \cancel{16}\ 17\ \cancel{18}\ 19
$$
</span>The algorithm continues, but none of the succeeding iterations finds any
values to remove. Therefore, <span style=white-space:nowrap><span class="math align-center">$ 2, 3, 5, 7, 11, 13, 17 $</span>,</span> and
<span class="math align-center">$ 19 $</span> are the
prime numbers less than <span style=white-space:nowrap><span class="math align-center">$ 20 $</span>.</span></p><p>To see why this algorithm gives us exactly the prime numbers less than
<span style=white-space:nowrap><span class="math align-center">$ n $</span>,</span> first note that because we only remove a number when we find a
nontrivial factor, we only remove non-primes from the list. What may be
a little less obvious is that we remove <em>all</em> non-primes from the list.
To see this, suppose
<span class="math align-center">$ m $</span> is a non-prime less than <span style=white-space:nowrap><span class="math align-center">$ n $</span>,</span> and let
<span class="math align-center">$ a $</span> be
its smallest nontrivial factor. Then
<span class="math align-center">$ a $</span> must be prime because any
nontrivial factor of
<span class="math align-center">$ a $</span> would be less than
<span class="math align-center">$ a $</span> and would also divide
<span style=white-space:nowrap><span class="math align-center">$ m $</span>.</span>
<span class="math align-center">$ a $</span> therefore will not be removed from the list. When
<span class="math align-center">$ k = a $</span> in Step 2,
<span class="math align-center">$ m $</span> will be removed.</p><p>There is actually a good reason why the first two iterations in the
above example removed all of the non-primes &mdash; once the algorithm reaches
a divisor
<span class="math align-center">$ k $</span> such that
<span class="math align-center">$ k^2 \geq n $</span> (in this
example, <span style=white-space:nowrap><span class="math align-center">$ 5^2 = 25 \geq 20 $</span>),</span> all of the
non-primes will have been removed. To see why this is true, let
<span class="math align-center">$ m $</span> and
<span class="math align-center">$ a $</span> be as above. We can then write
<span class="math align-left">$$
m = ab
$$
</span>where <span style=white-space:nowrap><span class="math align-center">$ a \leq b $</span>,</span> and
<span class="math align-center">$ m $</span> is removed from the list when
<span style=white-space:nowrap><span class="math align-center">$ k = a $</span>.</span> We can then multiply both sides of the above
equation by <span style=white-space:nowrap><span class="math align-center">$ a/b $</span>,</span> yielding:
<span class="math align-left">$$
\frac{am}{b} = a^2.
$$
</span>Finally, because <span style=white-space:nowrap><span class="math align-center">$ a \leq b $</span>,</span> <span style=white-space:nowrap><span class="math align-center">$ a/b \leq 1 $</span>.</span>
Therefore,
<span class="math align-left">$$
m \geq a^2.
$$
</span>We conclude that if
<span class="math align-center">$ m $</span> is a non-prime greater than <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>,</span> it is removed
when the algorithm reaches some value
<span class="math align-center">$ k $</span> with
<span style=white-space:nowrap><span class="math align-center">$ k^2 < n $</span>.</span> We can therefore optimize the
algorithm by stopping when <span style=white-space:nowrap><span class="math align-center">$ k^2 \geq n $</span>.</span></p><p>We can implement this algorithm using a linked list. A linked list is an
appropriate data structure for this algorithm because once the list is
built, all of the processing involves iterating through it from
beginning to end &mdash; the same direction the links go.</p><p>To implement Step 1, it is easier to build the list from back to front,
as we don&rsquo;t need to maintain a separate reference to the end of the
list. This step then consists of a loop that iterates from
<span class="math align-center">$ n - 1 $</span> down to <span style=white-space:nowrap><span class="math align-center">$ 2 $</span>,</span> with each iteration adding
to the front of the list a cell containing the loop index.</p><p>In order to be able to implement Step 2, we will need to know how to
remove a cell from a linked list. Suppose, for example, that we want to
remove the cell referring to &ldquo;the&rdquo; from the following linked list:</p><p><a href=#R-image-ef8ea143a2a25d901a73d936cbdd7ab2 class=lightbox-link><img alt="A linked list from which we want to remove x" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove1.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ef8ea143a2a25d901a73d936cbdd7ab2><img alt="A linked list from which we want to remove x" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove1.jpg></a></p><p>To remove it, we need the cell that precedes it to be followed by the
cell that follows it:</p><p><a href=#R-image-9311150731ddbb6f859c225ad6308d32 class=lightbox-link><img alt="What we need to change in order to remove the\ncell" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove2.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-9311150731ddbb6f859c225ad6308d32><img alt="What we need to change in order to remove the\ncell" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove2.jpg></a></p><p>In order to change that reference, we need a reference to the cell that
precedes the cell we want to remove:</p><p><a href=#R-image-6ce4ecbdf8fa7e963851ebb74162546c class=lightbox-link><img alt="The additional reference we need" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove3.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6ce4ecbdf8fa7e963851ebb74162546c><img alt="The additional reference we need" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/linked-list-remove3.jpg></a></p><p>We can then remove the cell following the cell referenced by <code>q</code> as
follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>q</span><span class=p>.</span><span class=n>Next</span> <span class=p>=</span> <span class=n>q</span><span class=p>.</span><span class=n>Next</span><span class=p>.</span><span class=n>Next</span><span class=p>;</span></span></span></code></pre></div><p>Now that we know how to remove a cell from a linked list, let&rsquo;s consider
Step 2 of the algorithm. For one value of <span style=white-space:nowrap><span class="math align-center">$ k $</span>,</span> we need to remove all
subsequent values that are divisible by <span style=white-space:nowrap><span class="math align-center">$ k $</span>.</span> In terms of the linked
list, we need to start this process with the cell containing <span style=white-space:nowrap><span class="math align-center">$ k $</span>.</span> For
example, consider the second iteration from the example above &mdash; i.e.,
when <span style=white-space:nowrap><span class="math align-center">$ k = 3 $</span>:</span></p><p><a href=#R-image-7b42cd148c27b84907c062ecc0198995 class=lightbox-link><img alt="The beginning of an iteration with k = 3" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/sieve-example1.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-7b42cd148c27b84907c062ecc0198995><img alt="The beginning of an iteration with k = 3" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/sieve-example1.jpg></a></p><p>We need to iterate <code>p</code> through the linked list, checking the <em>next</em> cell
on each iteration to see whether its contents are divisible by <span style=white-space:nowrap><span class="math align-center">$ k $</span>.</span> We
can check for divisibility by
<span class="math align-center">$ k $</span> using the <a href=/cis300/appendix/syntax/remainder/>remainder
operator</a> &mdash; i.e.,
<span class="math align-center">$ k $</span> divides
<span class="math align-center">$ m $</span> if
<span class="math align-center">$ m \mathbin{\texttt{%}} k $</span> is 0. Thus, the first iteration
would see if
<span class="math align-center">$ 3 $</span>
divides <span style=white-space:nowrap><span class="math align-center">$ 5 $</span>.</span> It doesn&rsquo;t, so we advance <code>p</code> to the next cell (containing
<span style=white-space:nowrap><span class="math align-center">$ 5 $</span>).</span> We then see if
<span class="math align-center">$ 3 $</span> divides <span style=white-space:nowrap><span class="math align-center">$ 7 $</span>.</span> Again it doesn&rsquo;t, so we advance <code>p</code> to
the next cell (containing <span style=white-space:nowrap><span class="math align-center">$ 7 $</span>).</span> At this point,
<span class="math align-center">$ 3 $</span> divides <span style=white-space:nowrap><span class="math align-center">$ 9 $</span>,</span> so we remove
the cell containing
<span class="math align-center">$ 9 $</span> as shown above. This gives us the following linked
list:</p><p><a href=#R-image-32fce2033c7238527612a2704a1d542c class=lightbox-link><img alt="After 9 has been removed" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/sieve-example2.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-32fce2033c7238527612a2704a1d542c><img alt="After 9 has been removed" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/linked-lists/sieve-eratosthenes/sieve-example2.jpg></a></p><p>Note that we have not yet advanced <code>p</code>, and indeed we don&rsquo;t want to, as
<span class="math align-center">$ 11 $</span> is the next value we want to check. Thus, on each iteration, if
<span class="math align-center">$ k $</span>
divides the value in the cell following <code>p</code>, we remove that cell;
otherwise, we advance <code>p</code> to that cell. We iterate this loop as long as
there is a cell following <code>p</code>.</p><p>The loop described above represents a single iteration of the loop
described for Step 2. Thus, for Step 2, we need to iterate a variable
through the list, performing the above on each iteration. We stop when
we either have run off the end of the list or have reached a value of
<span class="math align-center">$ k $</span> such that <span style=white-space:nowrap><span class="math align-center">$ k^2 \geq n $</span>.</span> Note that at the end of
each iteration, we want to advance to the next cell.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Make sure when iterating through a linked list that you keep a
reference to the beginning of the list. Otherwise, you will lose all
of your list.</p></div></div><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5>May 22, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1756138920 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1756138920 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1756138920></script><script src=/cis300/js/theme.js?1756138920 defer></script></body></html>