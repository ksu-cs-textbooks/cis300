




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="K-State CIS 300: Data Structures">
    <meta name="author" content="Rod Howell and Josh Weese">
    <title>Implementing Stacks and Queues with Linked Lists :: Data Structures in C#</title>
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1691596180" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1691596180" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/nucleus.css?1691596180" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1691596180" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1691596180" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/perfect-scrollbar.min.css?1691596180" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1691596180" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1691596180" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme.css?1691596180" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme-light-theme.css?1691596180" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/variant.css?1691596180" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/print.css?1691596180" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/ie.css?1691596180" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/url.js?1691596180"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/variant.js?1691596180"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72""
      window.index_json_url="https://ksu-cs-textbooks.github.io/cis300/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis300/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis300/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/custom.css?1691596180" rel="stylesheet">

  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis300/linked-lists/stacks-queues/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<div hidden><h1 id="implementing-stacks-and-queues-with-linked-lists">Implementing Stacks and Queues with Linked Lists</h1></div>

<h2 id="implementing-stacks-and-queues-with-linked-lists">Implementing Stacks and Queues with Linked Lists</h2>
<p>Because linked lists store data elements in linear sequences, they can
be used to give alternative implementations of stacks and queues. One
advantage to using linked lists is that we don&rsquo;t have to worry about
filling up something like an array - we can just keep allocating cells
as long as we need to (unless we run out of memory).</p>
<p>Implementing a stack using a linked list is particularly easy because
all accesses to a stack are at the top. One end of a linked list, the
beginning, is always directly accessible. We should therefore arrange
the elements so that the top element of the stack is at the beginning of
the linked list, and the bottom element of the stack is at the end of
the linked list. We can represent an empty stack with <strong>null</strong>.</p>
<p>We therefore need a <strong>private LinkedListCell&lt;T&gt;?</strong> field to implement a
generic stack <strong>Stack&lt;T&gt;</strong> using a linked list. This field will refer
to the cell containing the data item at the top of the stack. If the stack is empty, this field will be <strong>null</strong>; hence, this field should be <strong>null</strong> initially. A <strong>public
Count</strong> property will be used to keep track of the number of elements in
the stack.</p>
<p>The <strong>public</strong> methods <strong>Push</strong>, <strong>Peek</strong>, and <strong>Pop</strong> are then fairly
straightforward to implement. For <strong>Push</strong> we need to add the given
element to a new cell at the beginning of the linked list, as shown in
<a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro">the previous
section</a>
, and
update the <strong>Count</strong>. To implement <strong>Peek</strong>, if the stack is nonempty,
we simply return the <strong>Data</strong> property of the cell at the beginning of
the linked list; otherwise, we throw an <strong>InvalidOperationException</strong>. Note that we can determine whether the stack is empty by examining either the <strong>LinkedListCell&lt;T&gt;?</strong> field or the <strong>Count</strong> property; however, examining the <strong>LinkedListCell&lt;T&gt;?</strong> field allows the compiler to determine that the <strong>Data</strong> property of the first cell can be accessed without throwing a <strong>NullReferenceException</strong>.</p>
<p>To implement <strong>Pop</strong>:</p>
<ol>
<li>Using <strong>Peek</strong>, obtain the element to be returned.</li>
<li>Remove the first element from the linked list as shown in <a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro">the
previous
section</a>
.</li>
<li>Update the <strong>Count</strong>.</li>
<li>Return the retrieved value.</li>
</ol>
<p>Note that the call to <strong>Peek</strong> in step 1 ensures that the stack is nonempty before we remove the first element; however, the compiler won&rsquo;t be able to determine this.</p>
<p>Implementing a queue is a little more involved because we need to
operate at both ends of the linked list. For efficiency, we should keep
a reference to the last cell in the linked list, as this will allow us
to access both ends of the linked list directly. We will therefore have
the following:</p>
<p>
<a href="#image-e3c033862cd19c24459be5a93e47c69c" class="lightbox-link">
<img src="linked-list-queue.jpg" alt="Implementing a queue with a linked list" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-e3c033862cd19c24459be5a93e47c69c">
<img src="linked-list-queue.jpg" alt="Implementing a queue with a linked list" class="lightbox-image" loading="lazy">
</a></p>
<p>We now need to decide which end to make the front of the queue. As we
saw in <a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro">the previous
section</a>
, both
inserting and removing can be done efficiently at the beginning of a
linked list. Likewise, it is easy to insert an element at the end if we
have a reference to the last cell. Suppose, for example, that <code>last</code>
refers to the last cell in a linked list, and that <code>cell</code> refers to a
<strong>LinkedListCell&lt;T&gt;</strong> that we want to insert at the end. Suppose
further that the linked list is not empty (that will be a special case
that we&rsquo;ll need to handle). Thus, we have the following:</p>
<p>
<a href="#image-b7ebfa89a5e390f0dccaca0dd70cb25c" class="lightbox-link">
<img src="linked-list-insert-end-1.jpg" alt="A cell to insert at the end of a linked
list" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-b7ebfa89a5e390f0dccaca0dd70cb25c">
<img src="linked-list-insert-end-1.jpg" alt="A cell to insert at the end of a linked
list" class="lightbox-image" loading="lazy">
</a></p>
<p>To insert this cell at the end of the linked list, we just need to copy
the reference in <code>cell</code> to the <strong>Next</strong> property of the cell to which
<code>last</code> refers:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>last.Next = cell;</span></span></code></pre></div><p>On the other hand, removing the last cell is problematic, even if we
have a reference to it. The problem is that in order to remove it from
the linked list, we need to change the <strong>Next</strong> property of the
preceding cell. Unfortunately, the only way to obtain that cell is to
start at the beginning of the list and work our way through it. If the
linked list is long, this could be quite inefficient.</p>

  
  
<div class="box notices cstyle note">
  <div class="box-label"><i class="fa-fw fas fa-exclamation-circle"></i> Note</div>
  <div class="box-content">

<p>It doesn&rsquo;t help any to keep a reference to the next-to-last cell, as
we encounter the same problem when we need to update this reference
after removing the last cell &mdash; we don&rsquo;t have a reference to its
preceding cell.</p>
</div>
</div>
<p>Because we need to
remove elements from the front of a queue, but not from the back, we
conclude that it will work best to make the beginning of the linked list
the front of the queue. We therefore need the following <strong>private</strong>
fields to implement a generic queue <strong>Queue&lt;T&gt;</strong>:</p>
<ul>
<li>A <strong>LinkedListCell&lt;T&gt;?</strong> giving the element at the front of the
queue. This will be the beginning of the linked list of queue
elements.</li>
<li>A <strong>LinkedListCell&lt;T&gt;?</strong> giving the element at the back of the
queue. This will be the last cell in the linked list of queue
elements.</li>
</ul>
<p>As we mentioned earlier, adding an element to an empty queue is a
special case that we will need to handle separately. For this reason, it
doesn&rsquo;t matter what values the two <strong>LinkedListCell&lt;T&gt;?</strong> fields
contain when the queue is empty - we can always detect when the queue is
empty by checking the <strong>Count</strong>. The initialization of the two
<strong>LinkedListCell&lt;T&gt;?</strong> fields is therefore unimportant. It is easiest
to just leave them <strong>null</strong>.</p>
<p>Let us now consider the implementation of the <strong>Enqueue</strong> method. We
need to consider two cases. We&rsquo;ll first consider the case in which the
queue is empty. In this case, we need to build the following linked
list:</p>
<p>
<a href="#image-00d17311e87e8fa1481ae1aeb4f03d21" class="lightbox-link">
<img src="one-cell-queue.jpg" alt="A queue containing a single linked list cell" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-00d17311e87e8fa1481ae1aeb4f03d21">
<img src="one-cell-queue.jpg" alt="A queue containing a single linked list cell" class="lightbox-image" loading="lazy">
</a></p>
<p>We therefore need to:</p>
<ol>
<li>Construct a new <strong>LinkedListCell&lt;T&gt;</strong> containing the element we want to enqueue and no next cell.</li>
<li>Assign it to the field denoting the front of the queue.</li>
<li>Assign it to the field denoting the back of the queue.</li>
<li>Update the <strong>Count</strong>.</li>
</ol>
<p>If the queue is nonempty, the only step that changes is Step 2. Because
the queue is nonempty, we don&rsquo;t want to make the new cell the front of
the queue; instead, we need to insert it at the end of the linked list,
as outlined above.</p>
<p>The implementations of the <strong>Peek</strong> and <strong>Dequeue</strong> methods are
essentially the same as the implementations of the <strong>Peek</strong> and <strong>Pop</strong>
methods, respectively, for a stack.</p>
<p>The implementations described in this section are simpler than the
implementations using arrays, mainly due to the fact that we don&rsquo;t need
to rebuild the structure when we fill up the space available. While
these implementations are also pretty efficient, it turns out that the
array-based implementations tend to out-perform the linked-list-based
implementations. This might be counterintuitive at first because
rebuilding the structures when the array is filled is expensive.
However, due to the fact that we double the size of the array each time
we need a new one, this rebuilding is done so rarely in practice that it
ends up having minimal impact on performance. Due to hardware and
low-level software issues, the overhead involved in using arrays usually
ends up being less.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    </div>
    
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/clipboard.min.js?1691596180" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/perfect-scrollbar.min.js?1691596180" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/theme.js?1691596180" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/tele-scroll.js?1691596180 defer"></script>
    
  </body>
</html>
