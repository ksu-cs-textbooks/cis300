<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Implementing Stacks and Queues with Linked Lists Because linked lists store data elements in linear sequences, they can be used to give alternative implementations of stacks and queues. One advantage to using linked lists is that we don’t have to worry about filling up something like an array - we can just keep allocating cells as long as we need to (unless we run out of memory).
Implementing a stack using a linked list is particularly easy because all accesses to a stack are at the top. One end of a linked list, the beginning, is always directly accessible. We should therefore arrange the elements so that the top element of the stack is at the beginning of the linked list, and the bottom element of the stack is at the end of the linked list. We can represent an empty stack with null."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><meta name=twitter:description content="Implementing Stacks and Queues with Linked Lists Because linked lists store data elements in linear sequences, they can be used to give alternative implementations of stacks and queues. One advantage to using linked lists is that we don’t have to worry about filling up something like an array - we can just keep allocating cells as long as we need to (unless we run out of memory).
Implementing a stack using a linked list is particularly easy because all accesses to a stack are at the top. One end of a linked list, the beginning, is always directly accessible. We should therefore arrange the elements so that the top element of the stack is at the beginning of the linked list, and the bottom element of the stack is at the end of the linked list. We can represent an empty stack with null."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/linked-lists/stacks-queues/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><meta property="og:description" content="Implementing Stacks and Queues with Linked Lists Because linked lists store data elements in linear sequences, they can be used to give alternative implementations of stacks and queues. One advantage to using linked lists is that we don’t have to worry about filling up something like an array - we can just keep allocating cells as long as we need to (unless we run out of memory).
Implementing a stack using a linked list is particularly easy because all accesses to a stack are at the top. One end of a linked list, the beginning, is always directly accessible. We should therefore arrange the elements so that the top element of the stack is at the beginning of the linked list, and the bottom element of the stack is at the end of the linked list. We can represent an empty stack with null."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Linked Lists"><meta property="article:modified_time" content="2023-06-01T16:44:08-05:00"><meta itemprop=name content="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><meta itemprop=description content="Implementing Stacks and Queues with Linked Lists Because linked lists store data elements in linear sequences, they can be used to give alternative implementations of stacks and queues. One advantage to using linked lists is that we don’t have to worry about filling up something like an array - we can just keep allocating cells as long as we need to (unless we run out of memory).
Implementing a stack using a linked list is particularly easy because all accesses to a stack are at the top. One end of a linked list, the beginning, is always directly accessible. We should therefore arrange the elements so that the top element of the stack is at the beginning of the linked list, and the bottom element of the stack is at the end of the linked list. We can represent an empty stack with null."><meta itemprop=dateModified content="2023-06-01T16:44:08-05:00"><meta itemprop=wordCount content="1156"><title>Implementing Stacks and Queues with Linked Lists :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/linked-lists/stacks-queues/ rel=canonical type=text/html title="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><link href=/cis300/linked-lists/stacks-queues/index.xml rel=alternate type=application/rss+xml title="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><link href=/cis300/linked-lists/stacks-queues/tele.html rel=alternate type=text/html title="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><link href=/cis300/linked-lists/stacks-queues/embed.html rel=alternate type=text/html title="Implementing Stacks and Queues with Linked Lists :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1769099586 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1769099586 defer></script><script src=/cis300/js/search-lunr.min.js?1769099586 defer></script><script src=/cis300/js/search.min.js?1769099586 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1769099586"</script><script src=/cis300/js/lunr/lunr.min.js?1769099586 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1769099586 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1769099586 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1769099586 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1769099586 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1769099586 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1769099586 rel=stylesheet><link href=/cis300/css/theme.min.css?1769099586 rel=stylesheet><link href=/cis300/css/format-print.min.css?1769099586 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/linked-lists/stacks-queues/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1769099586 rel=stylesheet></head><body class="mobile-support print" data-url=/cis300/linked-lists/stacks-queues/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable linked-lists" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=implementing-stacks-and-queues-with-linked-lists>Implementing Stacks and Queues with Linked Lists</h1></div><h2 id=implementing-stacks-and-queues-with-linked-lists>Implementing Stacks and Queues with Linked Lists</h2><p>Because linked lists store data elements in linear sequences, they can
be used to give alternative implementations of stacks and queues. One
advantage to using linked lists is that we don&rsquo;t have to worry about
filling up something like an array - we can just keep allocating cells
as long as we need to (unless we run out of memory).</p><p>Implementing a stack using a linked list is particularly easy because
all accesses to a stack are at the top. One end of a linked list, the
beginning, is always directly accessible. We should therefore arrange
the elements so that the top element of the stack is at the beginning of
the linked list, and the bottom element of the stack is at the end of
the linked list. We can represent an empty stack with <strong>null</strong>.</p><p>We therefore need a <strong>private LinkedListCell&lt;T>?</strong> field to implement a
generic stack <strong>Stack&lt;T></strong> using a linked list. This field will refer
to the cell containing the data item at the top of the stack. If the stack is empty, this field will be <strong>null</strong>; hence, this field should be <strong>null</strong> initially. A <strong>public
Count</strong> property will be used to keep track of the number of elements in
the stack.</p><p>The <strong>public</strong> methods <strong>Push</strong>, <strong>Peek</strong>, and <strong>Pop</strong> are then fairly
straightforward to implement. For <strong>Push</strong> we need to add the given
element to a new cell at the beginning of the linked list, as shown in
<a href=/cis300/linked-lists/intro/>the previous
section</a>, and
update the <strong>Count</strong>. To implement <strong>Peek</strong>, if the stack is nonempty,
we simply return the <strong>Data</strong> property of the cell at the beginning of
the linked list; otherwise, we throw an <strong>InvalidOperationException</strong>. Note that we can determine whether the stack is empty by examining either the <strong>LinkedListCell&lt;T>?</strong> field or the <strong>Count</strong> property; however, examining the <strong>LinkedListCell&lt;T>?</strong> field allows the compiler to determine that the <strong>Data</strong> property of the first cell can be accessed without throwing a <strong>NullReferenceException</strong>.</p><p>To implement <strong>Pop</strong>:</p><ol><li>Using <strong>Peek</strong>, obtain the element to be returned.</li><li>Remove the first element from the linked list as shown in <a href=/cis300/linked-lists/intro/>the
previous
section</a>.</li><li>Update the <strong>Count</strong>.</li><li>Return the retrieved value.</li></ol><p>Note that the call to <strong>Peek</strong> in step 1 ensures that the stack is nonempty before we remove the first element; however, the compiler won&rsquo;t be able to determine this.</p><p>Implementing a queue is a little more involved because we need to
operate at both ends of the linked list. For efficiency, we should keep
a reference to the last cell in the linked list, as this will allow us
to access both ends of the linked list directly. We will therefore have
the following:</p><p><a href=#R-image-47ca98e1188bbb444db11aa38370c667 class=lightbox-link><img alt="Implementing a queue with a linked list" class="border lazy lightbox figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-47ca98e1188bbb444db11aa38370c667><img alt="Implementing a queue with a linked list" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-queue.jpg></a></p><p>We now need to decide which end to make the front of the queue. As we
saw in <a href=/cis300/linked-lists/intro/>the previous
section</a>, both
inserting and removing can be done efficiently at the beginning of a
linked list. Likewise, it is easy to insert an element at the end if we
have a reference to the last cell. Suppose, for example, that <code>last</code>
refers to the last cell in a linked list, and that <code>cell</code> refers to a
<strong>LinkedListCell&lt;T></strong> that we want to insert at the end. Suppose
further that the linked list is not empty (that will be a special case
that we&rsquo;ll need to handle). Thus, we have the following:</p><p><a href=#R-image-19727319215f90064a58f5158ff49495 class=lightbox-link><img alt="A cell to insert at the end of a linked\nlist" class="border lazy lightbox figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-insert-end-1.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-19727319215f90064a58f5158ff49495><img alt="A cell to insert at the end of a linked\nlist" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/linked-list-insert-end-1.jpg></a></p><p>To insert this cell at the end of the linked list, we just need to copy
the reference in <code>cell</code> to the <strong>Next</strong> property of the cell to which
<code>last</code> refers:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>last</span><span class=p>.</span><span class=n>Next</span> <span class=p>=</span> <span class=n>cell</span><span class=p>;</span></span></span></code></pre></div><p>On the other hand, removing the last cell is problematic, even if we
have a reference to it. The problem is that in order to remove it from
the linked list, we need to change the <strong>Next</strong> property of the
preceding cell. Unfortunately, the only way to obtain that cell is to
start at the beginning of the list and work our way through it. If the
linked list is long, this could be quite inefficient.</p><details open class="box cstyle notices note"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-exclamation-circle"></i>
Note</summary><div class=box-content><p>It doesn&rsquo;t help any to keep a reference to the next-to-last cell, as
we encounter the same problem when we need to update this reference
after removing the last cell &mdash; we don&rsquo;t have a reference to its
preceding cell.</p></div></details><p>Because we need to
remove elements from the front of a queue, but not from the back, we
conclude that it will work best to make the beginning of the linked list
the front of the queue. We therefore need the following <strong>private</strong>
fields to implement a generic queue <strong>Queue&lt;T></strong>:</p><ul><li>A <strong>LinkedListCell&lt;T>?</strong> giving the element at the front of the
queue. This will be the beginning of the linked list of queue
elements.</li><li>A <strong>LinkedListCell&lt;T>?</strong> giving the element at the back of the
queue. This will be the last cell in the linked list of queue
elements.</li></ul><p>As we mentioned earlier, adding an element to an empty queue is a
special case that we will need to handle separately. For this reason, it
doesn&rsquo;t matter what values the two <strong>LinkedListCell&lt;T>?</strong> fields
contain when the queue is empty - we can always detect when the queue is
empty by checking the <strong>Count</strong>. The initialization of the two
<strong>LinkedListCell&lt;T>?</strong> fields is therefore unimportant. It is easiest
to just leave them <strong>null</strong>.</p><p>Let us now consider the implementation of the <strong>Enqueue</strong> method. We
need to consider two cases. We&rsquo;ll first consider the case in which the
queue is empty. In this case, we need to build the following linked
list:</p><p><a href=#R-image-6e947bb96ea5f4a82017870645d3c533 class=lightbox-link><img alt="A queue containing a single linked list cell" class="border lazy lightbox figure-image" loading=lazy src=/cis300/linked-lists/stacks-queues/one-cell-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-6e947bb96ea5f4a82017870645d3c533><img alt="A queue containing a single linked list cell" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/linked-lists/stacks-queues/one-cell-queue.jpg></a></p><p>We therefore need to:</p><ol><li>Construct a new <strong>LinkedListCell&lt;T></strong> containing the element we want to enqueue and no next cell.</li><li>Assign it to the field denoting the front of the queue.</li><li>Assign it to the field denoting the back of the queue.</li><li>Update the <strong>Count</strong>.</li></ol><p>If the queue is nonempty, the only step that changes is Step 2. Because
the queue is nonempty, we don&rsquo;t want to make the new cell the front of
the queue; instead, we need to insert it at the end of the linked list,
as outlined above.</p><p>The implementations of the <strong>Peek</strong> and <strong>Dequeue</strong> methods are
essentially the same as the implementations of the <strong>Peek</strong> and <strong>Pop</strong>
methods, respectively, for a stack.</p><p>The implementations described in this section are simpler than the
implementations using arrays, mainly due to the fact that we don&rsquo;t need
to rebuild the structure when we fill up the space available. While
these implementations are also pretty efficient, it turns out that the
array-based implementations tend to out-perform the linked-list-based
implementations. This might be counterintuitive at first because
rebuilding the structures when the array is filled is expensive.
However, due to the fact that we double the size of the array each time
we need a new one, this rebuilding is done so rarely in practice that it
ends up having minimal impact on performance. Due to hardware and
low-level software issues, the overhead involved in using arrays usually
ends up being less.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1769099586></script><script src=/cis300/js/clipboard/clipboard.min.js?1769099586 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1769099586 defer></script><script src=/cis300/js/theme.min.js?1769099586 defer></script></div><script src=/cis300/js/tele-scroll.min.js?1769099586 defer></script></body></html>