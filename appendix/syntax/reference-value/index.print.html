<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters)."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reference Types and Value Types :: Data Structures in C#"><meta name=twitter:description content="Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters)."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/appendix/syntax/reference-value/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Reference Types and Value Types :: Data Structures in C#"><meta property="og:description" content="Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters)."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Appendices"><meta property="article:modified_time" content="2024-06-27T13:42:56-05:00"><meta itemprop=name content="Reference Types and Value Types :: Data Structures in C#"><meta itemprop=description content="Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters)."><meta itemprop=dateModified content="2024-06-27T13:42:56-05:00"><meta itemprop=wordCount content="1856"><title>Reference Types and Value Types :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723840625 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723840625 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723840625 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723840625 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723840625 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723840625 rel=stylesheet><link href=/cis300/css/fonts.css?1723840625 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723840625 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723840625 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723840625 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723840625 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723840625 rel=stylesheet><link href=/cis300/css/print.css?1723840625 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723840625 rel=stylesheet><script src=/cis300/js/variant.js?1723840625></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723840625 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/appendix/syntax/reference-value/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/appendix/><span itemprop=name>Appendices</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/appendix/syntax/><span itemprop=name>C# Syntax</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Reference Types and Value Types</span><meta itemprop=position content="3"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/appendix/syntax/ title="C# Syntax (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/appendix/syntax/enumerations/ title="Enumerations (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=reference-types-and-value-types>Reference Types and Value Types</h1></div><h2 id=reference-types-and-value-types>Reference Types and Value Types</h2><p>Data types in C# come in two distinct flavors: <em>value types</em> and <em>reference types</em>. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the <em>call stack</em>. The space for a method includes its local variables, including its parameters (except for <a href=/cis300/appendix/syntax/out-ref/><strong>out</strong> or <strong>ref</strong> parameters</a>). The organization of the call stack is shown in the following figure:</p><p><a href=#R-image-46909fc65f019cfdfe3d7bed148cafd3 class=lightbox-link><img alt="A picture of the call stack should appear here" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/images/call-stack.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-46909fc65f019cfdfe3d7bed148cafd3><img alt="A picture of the call stack should appear here" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/images/call-stack.jpg></a></p><p>When the currently-running method makes a method call, space for that method is taken from the beginning of the unused stack space. When the currently-running method returns, its space is returned to the unused space. Thus, the call stack works like <a href=/cis300/stacks-queues/stack-impl/>the array-based implementation of a stack</a>, and this storage allocation is quite efficient.</p><p>What is stored in the space allocated for a variable depends on whether the variable is for a value type or a reference type. For a value type, the value of the variable is stored directly in the space allocated for it. There are two kinds of value types: <a href=/cis300/appendix/syntax/structs/>structures</a> and <a href=/cis300/appendix/syntax/enumerations/>enumerations</a>. Examples of structures include numeric types such as <strong>int</strong>, <strong>double</strong>, and <strong>char</strong>. An example of an enumeration is <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.dialogresult?view=windowsdesktop-6.0" rel=external target=_blank><strong>DialogResult</strong></a> (see <a href=/cis300/io/dialogs/message-boxes/>"<strong>MessageBox</strong>es"</a> and <a href=/cis300/io/dialogs/file-dialogs/>&ldquo;File Dialogs&rdquo;</a>).</p><p>Because value types are stored directly in variables, whenever a value is assigned to a variable of a value type, the entire value must be written to the variable. For performance reasons, value types therefore should be fairly small.</p><p>For reference types, the values are not stored directly into the space allocated for the variable. Instead, the variable stores a <em>reference</em>, which is like an address where the value of the variable can actually be found. When a reference type is constructed with a <strong>new</strong> expression, space for that instance is allocated from a large data structure called the <em>heap</em> (which is unrelated to a <a href=/cis300/trees/priority-queues/heaps/>heap used to implement a priority queue</a>). Essentially, the heap is a large pool of available memory from which space of different sizes may be allocated at any time. We will not go into detail about how the heap is implemented, but suffice it to say that it is more complicated and less efficient than the stack. When space for a reference type is allocated from the heap, a reference to that space is stored in the variable. Larger data types are more efficiently implemented as reference types because an assignment to a variable of a reference type only needs to write a reference, not the entire data value.</p><p>There are three kinds of reference types: classes, <a href=/cis300/trees/tries/multiple-impl/>interfaces</a>, <a href=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record rel=external target=_blank>records</a>, and <a href=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type rel=external target=_blank>delegates</a>. Records and delegates are beyond the scope of this course.</p><p>Variables of a reference type do not need to refer to any data value. In this case, they store a value of <strong>null</strong> (variables of a value type cannot store <strong>null</strong>). Any attempt to access a method, property, or other member of a <strong>null</strong> or to apply an index to it will result in a <strong>NullReferenceException</strong>.</p><p>The fields of classes or structures are stored in a similar way, depending on whether the field is a value type or a reference type. If it is a value type, the value is stored directly in the field, regardless of whether that field belongs to an object allocated from the stack or the heap. If it is a reference type, it stores either <strong>null</strong> or a reference to an object allocated from the heap.</p><p>The difference between value types and reference types can be illustrated with the following code example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>DoSomething</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span> <span class=n>a</span> <span class=p>=</span> <span class=k>new</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Point</span> <span class=n>b</span> <span class=p>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>.</span><span class=n>X</span> <span class=p>=</span> <span class=n>i</span> <span class=p>+</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=p>[]</span> <span class=n>c</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=p>[]</span> <span class=n>d</span> <span class=p>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=n>b</span><span class=p>.</span><span class=n>X</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Suppose this method is called as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl>    <span class=kt>int</span><span class=p>[]</span> <span class=n>values</span> <span class=p>=</span> <span class=n>DoSomething</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>);</span></span></span></code></pre></div><p>The method contains six local variables: <code>i</code>, <code>j</code>, <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>. <strong>int</strong> is a structure, and hence a value type. <a href="https://learn.microsoft.com/en-us/dotnet/api/system.drawing.point?view=net-6.0" rel=external target=_blank><strong>Point</strong></a> is a structure (and hence a value type) containing <strong>public int</strong> properties <strong>X</strong> and <strong>Y</strong>, each of which can be read or modified. <strong>int[ ]</strong>, however, is a reference type. Space for all six of these variables is allocated from the stack, and the space for the two <strong>Point</strong>s includes space to store two <strong>int</strong> fields for each. The values 1 and 2 passed for <code>i</code> and <code>j</code>, respectively, are stored directly in these variables.</p><p>The constructor in the first line of the method above sets the <strong>X</strong> property of <code>a</code> to 1 and the <strong>Y</strong> property of <code>a</code> to 2. The next statement simply copies the value of <code>a</code> - i.e., the point (1, 2) - to <code>b</code>. Thus, when the <strong>X</strong> property of <code>a</code> is then changed to 3, <code>b</code> is unchanged - it still contains the point (1, 2).</p><p>On the other hand, consider what happens when something similar is done with array variables. When <code>c</code> is constructed, it is assigned a new array allocated from the heap and containing 10 locations. These 10 locations are automatically initialized to 0. However, because an array is a reference type, the variable <code>c</code> contains a reference to the actual array object, not the array itself. Thus, when <code>c</code> is copied to <code>d</code>, the array itself is not copied - the reference to the array is copied. Consequently, <code>d</code> and <code>c</code> now refer to the same array object, not two different arrays that look the same. Hence, after we assign <code>c[0]</code> a value of 1, <code>d[0]</code> will also contain a value of 1 because <code>c</code> and <code>d</code> refer to the same array object. (If we want <code>c</code> and <code>d</code> to refer to different array objects, we need to construct a new array for each variable and make sure each location of each array contains the value we want.) The array returned therefore resides on the heap, and contains 1 at index 0, and 0 at each of its other nine locations. The six local variables are returned to unused stack space; however, because the array was allocated from the heap, the calling code may continue to use it.</p><p><span id=nullable-types></span>It is sometimes convenient to be able to store a <strong>null</strong> in a variable of a value type. For example, we may want to indicate that an <strong>int</strong> variable contains no meaningful value. In some cases, we can reserve a specific <strong>int</strong> value for this purpose, but in other cases, there may be no <strong>int</strong> value that does not have some other meaning within the context. In such cases, we can use the <code>?</code> operator to define a <em>nullable</em> version of a value type; e.g.,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int?</span> <span class=n>i</span> <span class=p>=</span> <span class=kc>null</span><span class=p>;</span></span></span></code></pre></div><p>We can do this with any value type. Nullable value types such as <strong>int?</strong> are the only value types that can store <strong>null</strong>.</p><p>Beginning with C# version 8.0, similar annotations using the <code>?</code> operator are allowed for reference types. In contrast to its use with value types, this operator has no effect on the code execution when it is used with a reference type. Instead, such annotations are used to help programmers to avoid <strong>NullReferenceException</strong>s. For example, the type <strong>string</strong> is used for variables that should never be <strong>null</strong>, but <strong>string?</strong> is used for variables that might be <strong>null</strong>. Assigning <strong>null</strong> to a <strong>string</strong> variable will not throw an exception (though it might lead to a <strong>NullReferenceException</strong> later); however, starting with .NET 6, the compiler will generate a warning whenever it cannot determine that a value assigned to a non-nullable variable is not <strong>null</strong>. One way to avoid this warning is to use the nullable version of the type; e.g.,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kt>string?</span> <span class=n>s</span> <span class=p>=</span> <span class=kc>null</span><span class=p>;</span></span></span></code></pre></div><p>The compiler uses a technique called <em>static analysis</em> to try to determine whether a value assigned to a variable of a non-nullable reference type is non-<strong>null</strong>. This technique is limited, resulting in many cases in which the value assigned cannot be <strong>null</strong>, but the compiler gives a warning anyway. (This technique is especially limited in its ability to analyze arrays.) In such cases, the <strong>null</strong>-forgiving operator <code>!</code> can be used to remove the warning. Whenever you use this operator, the CIS 300 style requirements specify that you must include a comment explaining why the value assigned cannot be <strong>null</strong> (see <a href=/cis300/appendix/style/comments/>&ldquo;Comments&rdquo;</a>).</p><p>For example, a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader?view=net-6.0" rel=external target=_blank><strong>StreamReader</strong></a>&rsquo;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.readline?view=net-6.0" rel=external target=_blank><strong>ReadLine</strong></a> method returns <strong>null</strong> when there are no more lines left in the stream, but otherwise returns a non-<strong>null</strong> <strong>string</strong> (see <a href=/cis300/io/advanced-text-file/>&ldquo;Advanced Text File I/O&rdquo;</a>). We can use the <strong>StreamReader</strong>&rsquo;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.endofstream?view=net-6.0" rel=external target=_blank><strong>EndOfStream</strong></a> property to determine whether all lines have been read; for example, if <code>input</code> is a <strong>StreamReader</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>while</span> <span class=p>(!</span><span class=n>input</span><span class=p>.</span><span class=n>EndOfStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>line</span> <span class=p>=</span> <span class=n>input</span><span class=p>.</span><span class=n>ReadLine</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Process the line</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>However, because <strong>ReadLine</strong> has a return type of <strong>string?</strong> and the type of <code>line</code> is <strong>string</strong>, the compiler generates a warning - even though <strong>ReadLine</strong> will never return <strong>null</strong> in this context. We can eliminate the warning as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=k>while</span> <span class=p>(!</span><span class=n>input</span><span class=p>.</span><span class=n>EndOfStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Because input is not at the end of the stream, ReadLine won&#39;t return null.</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>line</span> <span class=p>=</span> <span class=n>input</span><span class=p>.</span><span class=n>ReadLine</span><span class=p>()!;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Process the line</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Because classes are reference types, it is possible for the definition of a class <strong>C</strong> to contain one or more fields of type <strong>C</strong> or, more typically, type <strong>C?</strong>; for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>C</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>C</span><span class=p>?</span> <span class=n>_nextC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Such circularity would be impossible for a value type because there would not be room for anything else if we tried to include a value of type <strong>C?</strong> within a value of type <strong>C</strong>. However, because <strong>C</strong> is a class, and hence a reference type, <code>_nextC</code> simply contains either <strong>null</strong> or a reference to some object of type <strong>C</strong>. When the runtime system constructs an instance of type <strong>C</strong>, it just needs to make it large enough to hold a reference, along with any other fields defined within <strong>C</strong>. Such recursive definitions are a powerful way to link together many instances of a type. See &ldquo;<a href=/cis300/linked-lists/>Linked Lists</a>&rdquo; and &ldquo;<a href=/cis300/trees/>Trees</a>&rdquo; for more information.</p><p>Because all types in C# are subtypes of <strong>object</strong>, which is a reference type, every value type is a subtype of at least one reference type (however, value types cannot themselves have subtypes). It is therefore possible to assign an instance of a value type to a variable of a reference type; for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kt>object</span> <span class=n>x</span> <span class=p>=</span> <span class=m>3</span><span class=p>;</span></span></span></code></pre></div><p>When this is done, a <em>boxed</em> version of the value type is constructed,
and the value copied to it. The boxed version of the value type is
just like the original value type, except that it is allocated from
the heap and accessed by reference, not by value. A reference to this boxed version is then assigned to the variable of the reference type. Note that multiple variables of the reference type may refer to the same boxed instance of the value type.
Note also that boxing may also occur when passing parameters. For example, suppose we have a method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>private</span> <span class=kt>object</span> <span class=n>F</span><span class=p>(</span><span class=kt>object</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If we call <strong>F</strong> with a parameter of 3, then 3 will need to be copied to a boxed <strong>int</strong>, and a reference to this boxed <strong>int</strong> will be assigned to <code>x</code> within <strong>F</strong>.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/fb0a1544d17b50aad3b244e7506660bfe8178a72>Jun 27, 2024</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723840625 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723840625 defer></script><script src=/cis300/js/theme.js?1723840625 defer></script></body></html>