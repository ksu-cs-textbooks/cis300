




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.2.0+tip">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="K-State CIS 300: Data Structures">
    <meta name="author" content="Rod Howell and Josh Weese">
    <title>Reference Types and Value Types :: Data Structures in C#</title>
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1685655901" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1685655901" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1685655901" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1685655901" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1685655901" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1685655901" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/perfect-scrollbar.min.css?1685655901" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/nucleus.css?1685655901" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1685655901" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1685655901" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme.css?1685655901" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme-light-theme.css?1685655901" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/ie.css?1685655901" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/variant.css?1685655901" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/print.css?1685655901" rel="stylesheet" media="print">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/variant.js?1685655901"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis300/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis300/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis300/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/custom.css?1685655901" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/jquery.min.js?1685655901" defer></script>

  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/reference-value/">
    
    <div id="tele" class="tele mirror">
    
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <div id="head-tags">
          </div>
          <article class="default">
<div hidden><h1>Reference Types and Value Types</h1></div>
<h2 id="reference-types-and-value-types">Reference Types and Value Types</h2>
<p>Data types in C# come in two distinct flavors: <em>value types</em> and <em>reference types</em>. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the <em>call stack</em>. The space for a method includes its local variables, including its parameters (except for 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/out-ref"><strong>out</strong> or <strong>ref</strong> parameters</a>). The organization of the call stack is shown in the following figure:</p>
<p><img src="../img/call-stack.jpg" alt="A picture of the call stack should appear here"></p>
<p>When the currently-running method makes a method call, space for that method is taken from the beginning of the unused stack space. When the currently-running method returns, its space is returned to the unused space. Thus, the call stack works like 

<a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl">the array-based implementation of a stack</a>, and this storage allocation is quite efficient.</p>
<p>What is stored in the space allocated for a variable depends on whether the variable is for a value type or a reference type. For a value type, the value of the variable is stored directly in the space allocated for it. There are two kinds of value types: 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/structs">structures</a> and 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/enumerations">enumerations</a>. Examples of structures include numeric types such as <strong>int</strong>, <strong>double</strong>, and <strong>char</strong>. An example of an enumeration is 

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.dialogresult?view=windowsdesktop-6.0" target="_blank" rel="noopener"><strong>DialogResult</strong></a> (see 

<a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/message-boxes">&quot;<strong>MessageBox</strong>es&quot;</a> and 

<a href="https://ksu-cs-textbooks.github.io/cis300/io/dialogs/file-dialogs">&ldquo;File Dialogs&rdquo;</a>).</p>
<p>Because value types are stored directly in variables, whenever a value is assigned to a variable of a value type, the entire value must be written to the variable. For performance reasons, value types therefore should be fairly small.</p>
<p>For reference types, the values are not stored directly into the space allocated for the variable. Instead, the variable stores a <em>reference</em>, which is like an address where the value of the variable can actually be found. When a reference type is constructed with a <strong>new</strong> expression, space for that instance is allocated from a large data structure called the <em>heap</em> (which is unrelated to a 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps">heap used to implement a priority queue</a>). Essentially, the heap is a large pool of available memory from which space of different sizes may be allocated at any time. We will not go into detail about how the heap is implemented, but suffice it to say that it is more complicated and less efficient than the stack. When space for a reference type is allocated from the heap, a reference to that space is stored in the variable. Larger data types are more efficiently implemented as reference types because an assignment to a variable of a reference type only needs to write a reference, not the entire data value.</p>
<p>There are three kinds of reference types: classes, 

<a href="https://ksu-cs-textbooks.github.io/cis300/trees/tries/multiple-impl">interfaces</a>, 

<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record" target="_blank" rel="noopener">records</a>, and 

<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-delegate-type" target="_blank" rel="noopener">delegates</a>. Records and delegates are beyond the scope of this course.</p>
<p>Variables of a reference type do not need to refer to any data value. In this case, they store a value of <strong>null</strong> (variables of a value type cannot store <strong>null</strong>). Any attempt to access a method, property, or other member of a <strong>null</strong> or to apply an index to it will result in a <strong>NullReferenceException</strong>.</p>
<p>The fields of classes or structures are stored in a similar way, depending on whether the field is a value type or a reference type. If it is a value type, the value is stored directly in the field, regardless of whether that field belongs to an object allocated from the stack or the heap. If it is a reference type, it stores either <strong>null</strong> or a reference to an object allocated from the heap.</p>
<p>The difference between value types and reference types can be illustrated with the following code example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span>[] DoSomething(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">int</span> j)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Point a = <span style="color:#66d9ef">new</span>(i, j);
</span></span><span style="display:flex;"><span>    Point b = a;
</span></span><span style="display:flex;"><span>    a.X = i + j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>[] c = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>[] d = c;
</span></span><span style="display:flex;"><span>    c[<span style="color:#ae81ff">0</span>] = b.X;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Suppose this method is called as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>[] values = DoSomething(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>The method contains six local variables: <code>i</code>, <code>j</code>, <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>. <strong>int</strong> is a structure, and hence a value type. 

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.drawing.point?view=net-6.0" target="_blank" rel="noopener"><strong>Point</strong></a> is a structure (and hence a value type) containing <strong>public int</strong> properties <strong>X</strong> and <strong>Y</strong>, each of which can be read or modified. <strong>int[ ]</strong>, however, is a reference type. Space for all six of these variables is allocated from the stack, and the space for the two <strong>Point</strong>s includes space to store two <strong>int</strong> fields for each. The values 1 and 2 passed for <code>i</code> and <code>j</code>, respectively, are stored directly in these variables.</p>
<p>The constructor in the first line of the method above sets the <strong>X</strong> property of <code>a</code> to 1 and the <strong>Y</strong> property of <code>a</code> to 2. The next statement simply copies the value of <code>a</code> - i.e., the point (1, 2) - to <code>b</code>. Thus, when the <strong>X</strong> property of <code>a</code> is then changed to 3, <code>b</code> is unchanged - it still contains the point (1, 2).</p>
<p>On the other hand, consider what happens when something similar is done with array variables. When <code>c</code> is constructed, it is assigned a new array allocated from the heap and containing 10 locations. These 10 locations are automatically initialized to 0. However, because an array is a reference type, the variable <code>c</code> contains a reference to the actual array object, not the array itself. Thus, when <code>c</code> is copied to <code>d</code>, the array itself is not copied - the reference to the array is copied. Consequently, <code>d</code> and <code>c</code> now refer to the same array object, not two different arrays that look the same. Hence, after we assign <code>c[0]</code> a value of 1, <code>d[0]</code> will also contain a value of 1 because <code>c</code> and <code>d</code> refer to the same array object. (If we want <code>c</code> and <code>d</code> to refer to different array objects, we need to construct a new array for each variable and make sure each location of each array contains the value we want.) The array returned therefore resides on the heap, and contains 1 at index 0, and 0 at each of its other nine locations. The six local variables are returned to unused stack space; however, because the array was allocated from the heap, the calling code may continue to use it.</p>
<p><span id="nullable-types"></span>It is sometimes convenient to be able to store a <strong>null</strong> in a variable of a value type. For example, we may want to indicate that an <strong>int</strong> variable contains no meaningful value. In some cases, we can reserve a specific <strong>int</strong> value for this purpose, but in other cases, there may be no <strong>int</strong> value that does not have some other meaning within the context. In such cases, we can use the <code>?</code> operator to define a <em>nullable</em> version of a value type; e.g.,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">int?</span> i = <span style="color:#66d9ef">null</span>;
</span></span></code></pre></div><p>We can do this with any value type. Nullable value types such as <strong>int?</strong> are the only value types that can store <strong>null</strong>.</p>
<p>Beginning with C# version 8.0, similar annotations using the <code>?</code> operator are allowed for reference types. In contrast to its use with value types, this operator has no effect on the code execution when it is used with a reference type. Instead, such annotations are used to help programmers to avoid <strong>NullReferenceException</strong>s. For example, the type <strong>string</strong> is used for variables that should never be <strong>null</strong>, but <strong>string?</strong> is used for variables that might be <strong>null</strong>. Assigning <strong>null</strong> to a <strong>string</strong> variable will not throw an exception (though it might lead to a <strong>NullReferenceException</strong> later); however, starting with .NET 6, the compiler will generate a warning whenever it cannot determine that a value assigned to a non-nullable variable is not <strong>null</strong>. One way to avoid this warning is to use the nullable version of the type; e.g.,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">string?</span> s = <span style="color:#66d9ef">null</span>;
</span></span></code></pre></div><p>The compiler uses a technique called <em>static analysis</em> to try to determine whether a value assigned to a variable of a non-nullable reference type is non-<strong>null</strong>. This technique is limited, resulting in many cases in which the value assigned cannot be <strong>null</strong>, but the compiler gives a warning anyway. (This technique is especially limited in its ability to analyze arrays.) In such cases, the <strong>null</strong>-forgiving operator <code>!</code> can be used to remove the warning. Whenever you use this operator, the CIS 300 style requirements specify that you must include a comment explaining why the value assigned cannot be <strong>null</strong> (see 

<a href="https://ksu-cs-textbooks.github.io/cis300/appendix/style/comments/">&ldquo;Comments&rdquo;</a>).</p>
<p>For example, a 

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader?view=net-6.0" target="_blank" rel="noopener"><strong>StreamReader</strong></a>&rsquo;s 

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.readline?view=net-6.0" target="_blank" rel="noopener"><strong>ReadLine</strong></a> method returns <strong>null</strong> when there are no more lines left in the stream, but otherwise returns a non-<strong>null</strong> <strong>string</strong> (see 

<a href="https://ksu-cs-textbooks.github.io/cis300/io/advanced-text-file/">&ldquo;Advanced Text File I/O&rdquo;</a>). We can use the <strong>StreamReader</strong>&rsquo;s 

<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.endofstream?view=net-6.0" target="_blank" rel="noopener"><strong>EndOfStream</strong></a> property to determine whether all lines have been read; for example, if <code>input</code> is a <strong>StreamReader</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (!input.EndOfStream)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> line = input.ReadLine();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process the line</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, because <strong>ReadLine</strong> has a return type of <strong>string?</strong> and the type of <code>line</code> is <strong>string</strong>, the compiler generates a warning - even though <strong>ReadLine</strong> will never return <strong>null</strong> in this context. We can eliminate the warning as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (!input.EndOfStream)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Because input is not at the end of the stream, ReadLine won&#39;t return null.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> line = input.ReadLine()!;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Process the line</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because classes are reference types, it is possible for the definition of a class <strong>C</strong> to contain one or more fields of type <strong>C</strong> or, more typically, type <strong>C?</strong>; for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> C? _nextC;
</span></span><span style="display:flex;"><span>    . . .
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Such circularity would be impossible for a value type because there would not be room for anything else if we tried to include a value of type <strong>C?</strong> within a value of type <strong>C</strong>. However, because <strong>C</strong> is a class, and hence a reference type, <code>_nextC</code> simply contains either <strong>null</strong> or a reference to some object of type <strong>C</strong>. When the runtime system constructs an instance of type <strong>C</strong>, it just needs to make it large enough to hold a reference, along with any other fields defined within <strong>C</strong>. Such recursive definitions are a powerful way to link together many instances of a type. See &ldquo;

<a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists">Linked Lists</a>&rdquo; and &ldquo;

<a href="https://ksu-cs-textbooks.github.io/cis300/trees">Trees</a>&rdquo; for more information.</p>
<p>Because all types in C# are subtypes of <strong>object</strong>, which is a reference type, every value type is a subtype of at least one reference type (however, value types cannot themselves have subtypes). It is therefore possible to assign an instance of a value type to a variable of a reference type; for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">object</span> x = <span style="color:#ae81ff">3</span>;
</span></span></code></pre></div><p>When this is done, a <em>boxed</em> version of the value type is constructed,
and the value copied to it. The boxed version of the value type is
just like the original value type, except that it is allocated from
the heap and accessed by reference, not by value. A reference to this boxed version is then assigned to the variable of the reference type. Note that multiple variables of the reference type may refer to the same boxed instance of the value type.
Note also that boxing may also occur when passing parameters. For example, suppose we have a method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">object</span> F(<span style="color:#66d9ef">object</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we call <strong>F</strong> with a parameter of 3, then 3 will need to be copied to a boxed <strong>int</strong>, and a reference to this boxed <strong>int</strong> will be assigned to <code>x</code> within <strong>F</strong>.</p>

            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    
  </div>
    
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/clipboard.min.js?1685655901" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/perfect-scrollbar.min.js?1685655901" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/featherlight.min.js?1685655901" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/theme.js?1685655901" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/tele-scroll.js?1685655901 defer"></script>
    
  </body>
</html>
