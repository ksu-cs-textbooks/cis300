<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:
private void DoSomething(int k) { }We can call this method with a statement like:
DoSomething(n);provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="out and ref Parameters :: Data Structures in C#"><meta name=twitter:description content="out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:
private void DoSomething(int k) { }We can call this method with a statement like:
DoSomething(n);provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/appendix/syntax/out-ref/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="out and ref Parameters :: Data Structures in C#"><meta property="og:description" content="out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:
private void DoSomething(int k) { }We can call this method with a statement like:
DoSomething(n);provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Appendices"><meta property="article:modified_time" content="2023-05-22T14:36:43-05:00"><meta itemprop=name content="out and ref Parameters :: Data Structures in C#"><meta itemprop=description content="out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:
private void DoSomething(int k) { }We can call this method with a statement like:
DoSomething(n);provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="992"><title>out and ref Parameters :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737740580 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737740580 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737740580 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737740580 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737740580 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737740580 rel=stylesheet><link href=/cis300/css/fonts.css?1737740580 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737740580 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737740580 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1737740580 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1737740580 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737740580 rel=stylesheet><link href=/cis300/css/print.css?1737740580 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737740580 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/appendix/syntax/out-ref/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=out-and-ref-parameters><strong>out</strong> and <strong>ref</strong> Parameters</h2><p>Normally, when a method is called, the <em>call-by-value</em> mechanism is used. Suppose, for example, we have a method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>DoSomething</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We can call this method with a statement like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>DoSomething</span><span class=p>(</span><span class=n>n</span><span class=p>);</span></span></span></code></pre></div><p>provided <code>n</code> is an initialized variable consistent with the <strong>int</strong> type. For example, suppose <code>n</code> is an <strong>int</strong> variable containing a value of 28. The call-by-value mechanism works by copying the value of <code>n</code> (i.e., 28) to <code>k</code>. Whatever the <strong>DoSomething</strong> method may do to <code>k</code> has no effect on <code>n</code> &mdash; they are different variables. The same can be said if we had instead passed a variable <code>k</code> &mdash; the <code>k</code> in the calling code is still a different variable from the <code>k</code> in the <strong>DoSomething</strong> method. Finally, if we call <strong>DoSomething</strong> with an expression like <code>9 + n</code>, the mechanism is the same.</p><p>If a parameter is of a <a href=/cis300/appendix/syntax/reference-value/>reference type</a>, the same mechanism is used, but it is worth considering that case separately to see exactly what happens. Suppose, for example, that we have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>DoSomethingElse</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>=</span> <span class=m>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Further suppose that we call this method with</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>b</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>DoSomethingElse</span><span class=p>(</span><span class=n>b</span><span class=p>);</span></span></span></code></pre></div><p>The initialization of <code>b</code> above assigns to <code>b</code> a reference to an array containing five 0s. The call to <strong>DoSomethingElse</strong> copies the value of <code>b</code> to <code>a</code>. Note, however, that the value of <code>b</code> is a reference; hence, after this value is copied, <code>a</code> and <code>b</code> refer to the same five-element array. Therefore, when <code>a[0]</code> is assigned <code>1</code>, <code>b[0]</code> also becomes <code>1</code>. When <code>a</code> is assigned a new array, however, this does not affect <code>b</code>, as <code>b</code> is a different variable &mdash; <code>b</code> still refers to the same five-element array. Furthermore, when <code>a[1]</code> is assigned a value of 2, because <code>a</code> and <code>b</code> now refer to different arrays, the contents of <code>b</code> are unchanged. Thus, when <strong>DoSomethingElse</strong> completes, <code>b</code> will refer to a five-element array whose element at location 0 is 1, and whose other elements are 0.</p><p>While the call-by-value mechanism is used by default, another mechanism, known as the <em>call-by-reference</em> mechanism, can be specified. When call-by-reference is used, the parameter passed in the calling code must be a variable, not a property or expression. Instead of copying the value of this variable into the corresponding parameter within the method, this mechanism causes the variable within the method to be an <em>alias</em> for the variable being passed. In other words, the two variables are simply different names for the same underlying variable (consequently, the types of the two variables must be identical). Thus, whatever changes are made to the parameter within the method are reflected in the variable passed to the method in the calling code as well.</p><p>One case in which this mechanism is useful is when we would like to have a method return more than one value. Suppose, for example, that we would like to find both the maximum and minimum values in a given <strong>int[ ]</strong>. A <strong>return</strong> statement can return only one value. Although there are ways of packaging more than one value together in one object, a cleaner way is to use two parameters that use the call-by-reference mechanism. The method can then change the values of these variables to the maximum and minimum values, and these values would be available to the calling code.</p><p>Specifically, we can define the method using <strong>out</strong> parameters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>MinimumAndMaximum</span><span class=p>(</span><span class=kt>int</span><span class=p>[]</span> <span class=n>array</span><span class=p>,</span> <span class=k>out</span> <span class=kt>int</span> <span class=n>min</span><span class=p>,</span> <span class=k>out</span> <span class=kt>int</span> <span class=n>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>min</span> <span class=p>=</span> <span class=n>array</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>max</span> <span class=p>=</span> <span class=n>array</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>array</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>min</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>min</span> <span class=p>=</span> <span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>max</span> <span class=p>=</span> <span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The <strong>out</strong> keyword in the first line above specifies the call-by-reference mechanism for <code>min</code> and <code>max</code>. We could then call this code as follows, assuming <code>a</code> is an <strong>int[ ]</strong> containing at least one element:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span> <span class=n>minimum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>maximum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>MinimumAndMaximum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=k>out</span> <span class=n>minimum</span><span class=p>,</span> <span class=k>out</span> <span class=n>maximum</span><span class=p>);</span></span></span></code></pre></div><p>When this code completes, <code>minimum</code> will contain the minimum element in <code>a</code> and <code>maximum</code> will contain the maximum element in <code>a</code>.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>When using <strong>out</strong> parameters, it is important that the keyword
<strong>out</strong> is placed prior to the variable name in both the method call
and the method definition. If you omit this keyword in one of these
places, then the parameter lists won&rsquo;t match, and you&rsquo;ll get a syntax
error to this effect.</p></div></div><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p>As a shorthand, you can declare an <strong>out</strong> parameter in the parameter
list of the method call. Thus, the above example could be shortened
to the following single line of code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>MinimumAndMaximum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=k>out</span> <span class=kt>int</span> <span class=n>minimum</span><span class=p>,</span> <span class=k>out</span> <span class=kt>int</span> <span class=n>maximum</span><span class=p>);</span></span></span></code></pre></div></div></div><p>Note that <strong>out</strong> parameters do not need to be initialized prior to the method call in which they are used. However, they need to be assigned a value within the method to which they are passed. Another way of using the call-by-reference mechanism places a slightly different requirement on where the variables need to be initialized. This other way is to use <strong>ref</strong> parameters. The only difference between <strong>ref</strong> parameters and <strong>out</strong> parameters is that <strong>ref</strong> parameters must be initialized prior to being passed to the method. Thus, we would typically use an <strong>out</strong> parameter when we expect the method to assign it its first value, but we would use a <strong>ref</strong> parameter when we expect the method to change a value that the variable already has (the method may, in fact, use this value prior to changing it).</p><p>For example, suppose we want to define a method to swap the contents of two <strong>int</strong> variables. We use <strong>ref</strong> parameters to accomplish this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>Swap</span><span class=p>(</span><span class=k>ref</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=k>ref</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=p>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=p>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>j</span> <span class=p>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We could then call this method as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span> <span class=n>m</span> <span class=p>=</span> <span class=m>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=m>12</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Swap</span><span class=p>(</span><span class=k>ref</span> <span class=n>m</span><span class=p>,</span> <span class=k>ref</span> <span class=n>n</span><span class=p>);</span></span></span></code></pre></div><p>After this code is executed, <code>m</code> will contain 12 and <code>n</code> will contain 10.</p><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1737740580 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737740580 defer></script><script src=/cis300/js/theme.js?1737740580 defer></script><script src=/cis300/js/embed-iframe.js?1737740580 defer></script></body></html>