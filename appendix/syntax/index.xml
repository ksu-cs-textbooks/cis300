<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# Syntax :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/</link><description>C# Syntax This chapter discusses various C# features that are either unavailable in Java or are unlikely to have been covered in an introductory Java programming class. No attempt has been made to be exhaustive. Instead, we focus mainly on those features that are likely to be needed in CIS 300. In addition, the following topics are covered in the main text, rather than in this appendix:
Generic Types Interfaces Overriding virtual Methods Operator Overloading The using Statement Equality Type Casting For more information on C#, see the C# Reference manual and the C# Programming Guide.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/appendix/syntax/index.xml" rel="self" type="application/rss+xml"/><item><title>Reference Types and Value Types</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/reference-value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/reference-value/</guid><description>Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters).</description></item><item><title>Enumerations</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/enumerations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/enumerations/</guid><description>Enumerations An enumeration is a value type containing a set of named constants. An example of an enumeration is DialogResult (see "MessageBoxes" and “File Dialogs”). The DialogResult type contains the following members:
DialogResult.Abort DialogResult.Cancel DialogResult.Ignore DialogResult.No DialogResult.None DialogResult.OK DialogResult.Retry DialogResult.Yes Each of the above members has a different constant value. In many cases, we are not interested in the specific value of a given member. Instead, we are often only interested in whether two expressions of this type have the same value.</description></item><item><title>Structures</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/structs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/structs/</guid><description>Structures A structure is similar to a class, except that it is a value type, whereas a class is a reference type. A structure definition looks a lot like a class definition; for example, the following defines a structure for storing information associated with a name:
/// &lt;summary> /// Stores a frequency and a rank. /// &lt;/summary> public readonly struct FrequencyAndRank { /// &lt;summary> /// Gets the Frequency. /// &lt;/summary> public float Frequency { get; } /// &lt;summary> /// Gets the Rank.</description></item><item><title>The decimal Type</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/decimals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/decimals/</guid><description>The decimal Type A decimal is a structure representing a floating-point decimal number. The main difference between a decimal and a float or a double is that a decimal can store any value that can be written using no more than 28 decimal digits, a decimal point, and optionally a ‘-’, without rounding. For example, the value 0.1 cannot be stored exactly in either a float or a double because its binary representation is infinite (0.</description></item><item><title>Read-Only and Constant Fields</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/const/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/const/</guid><description>Read-Only and Constant Fields Field declarations may contain one of the the keywords readonly or const to indicate that these fields will always contain the same values. Such declarations are useful for defining a value that is to be used throughout a class or structure definition, or throughout an entire program. For example, we might define:
public class ConstantsExample { public readonly int VerticalPadding = 12; private const string _humanPlayer = "X"; .</description></item><item><title>Properties</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/properties/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/properties/</guid><description>Properties A property is used syntactically like a field of a class or structure, but provides greater flexibility in implementation. For example, the string class contains a public property called Length. This property is accessed in code much as if it were a public int field; i.e., if s is a string variable, we can access its Length property with the expression s.Length, which evaluates to an int. If Length were a public int field, we would access it in just the same way.</description></item><item><title>Indexers</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/indexers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/indexers/</guid><description>Indexers Recall that the System.Collections.Generic.Dictionary&lt;TKey, TValue> class (see “The Dictionary&lt;TKey, TValue> Class”) allows keys to be used as indices for the purpose of adding new keys and values, changing the value associated with a key, and retrieving the value associated with a key in the table. In this section, we will discuss how to implement this functionality.
An indexer in C# is defined using the following syntax:
public TValue this[TKey k] { get { // Code to retrieve the value with key k } set { // Code to associate the given value with key k } }Note the resemblance of the above code to the definition of a property.</description></item><item><title>The Keywords static and this</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/static-this/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/static-this/</guid><description>The Keywords static and this Object-oriented programming languages such as C# are centered on the concept of an object. Class and structure definitions give instructions for constructing individual objects of various types, normally by using the new keyword. When an object is constructed, it has its own fields in which values may be stored. Specifically, if type T has an int field called _length, then each object of type T will have have such a field, and each of these fields may store a different int.</description></item><item><title>out and ref Parameters</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/out-ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/out-ref/</guid><description>out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:
private void DoSomething(int k) { }We can call this method with a statement like:
DoSomething(n);provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i.</description></item><item><title>The foreach Statement</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/foreach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/foreach/</guid><description>The foreach Statement C# provides a foreach statement that is often useful for iterating through the elements of certain data structures. A foreach can be used when all of the following conditions hold:
The data structure is a subtype of either IEnumerable or IEnumerable&lt;T> for some type T. You do not need to know the locations in the data structure of the individual elements. You do not need to modify the data structure with this loop.</description></item><item><title>Enumerators</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/enumerators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/enumerators/</guid><description>Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable&lt;T>, where T is the type of the elements in the data structure. Thus, because Dictionary&lt;TKey, TValue> is a subtype of IEnumerable&lt;KeyValuePair&lt;TKey, TValue>>, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable&lt;TKey> and IEnumerable&lt;TValue>, respectively, foreach loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary.</description></item><item><title>The switch Statement</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/switch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/switch/</guid><description>The switch Statement The switch statement provides an alternative to the if statement for certain contexts. It is used when different cases must be handled based on the value of an expression that can have only a few possible results.
For example, suppose we want to display a MessageBox containing “Abort”, “Retry”, and “Ignore” buttons. The user can respond in only three ways, and we need different code in each case.</description></item><item><title>The Remainder Operator</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/remainder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/syntax/remainder/</guid><description>The Remainder Operator The remainder operator % computes the remainder that results when one number is divided by another. Specifically, suppose m and n are of some numeric type, where n ≠ 0. We can then define a quotient q and a remainder r as the unique values such that:
qn + r = m; q is an integer; |qn| ≤ |m|; and |r| &lt; |n|. Then m % n gives r, and we can compute q by:</description></item></channel></rss>