<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable<T>, where T is the type of the elements in the data structure. Thus, because Dictionary<TKey, TValue> is a subtype of IEnumerable<KeyValuePair<TKey, TValue>>, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable<TKey> and IEnumerable<TValue>, respectively, foreach loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Enumerators :: Data Structures in C#"><meta name=twitter:description content="Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable<T>, where T is the type of the elements in the data structure. Thus, because Dictionary<TKey, TValue> is a subtype of IEnumerable<KeyValuePair<TKey, TValue>>, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable<TKey> and IEnumerable<TValue>, respectively, foreach loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/appendix/syntax/enumerators/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Enumerators :: Data Structures in C#"><meta property="og:description" content="Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable<T>, where T is the type of the elements in the data structure. Thus, because Dictionary<TKey, TValue> is a subtype of IEnumerable<KeyValuePair<TKey, TValue>>, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable<TKey> and IEnumerable<TValue>, respectively, foreach loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Appendices"><meta property="article:modified_time" content="2023-05-29T14:01:30-05:00"><meta itemprop=name content="Enumerators :: Data Structures in C#"><meta itemprop=description content="Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable<T>, where T is the type of the elements in the data structure. Thus, because Dictionary<TKey, TValue> is a subtype of IEnumerable<KeyValuePair<TKey, TValue>>, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable<TKey> and IEnumerable<TValue>, respectively, foreach loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary."><meta itemprop=dateModified content="2023-05-29T14:01:30-05:00"><meta itemprop=wordCount content="1013"><title>Enumerators :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737489328 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737489328 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737489328 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737489328 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737489328 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737489328 rel=stylesheet><link href=/cis300/css/fonts.css?1737489328 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737489328 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737489328 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1737489328 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1737489328 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737489328 rel=stylesheet><link href=/cis300/css/print.css?1737489328 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737489328 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/appendix/syntax/enumerators/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=enumerators>Enumerators</h2><p>As we saw in <a href=/cis300/appendix/syntax/foreach/>the previous section</a>, in order for a data structure to support a <strong>foreach</strong> loop, it must be a subtype of either <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-6.0" rel=external target=_blank><strong>IEnumerable</strong></a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-6.0" rel=external target=_blank><strong>IEnumerable&lt;T></strong></a>, where <strong>T</strong> is the type of the elements in the data structure. Thus, because <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0" rel=external target=_blank><strong>Dictionary&lt;TKey, TValue></strong></a> is a subtype of <strong>IEnumerable&lt;KeyValuePair&lt;TKey, TValue>></strong>, we can use a <strong>foreach</strong> loop to iterate through the key-value pairs that it stores. Likewise, because its <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.keys?view=net-6.0#system-collections-generic-dictionary-2-keys" rel=external target=_blank><strong>Keys</strong></a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.values?view=net-6.0#system-collections-generic-dictionary-2-values" rel=external target=_blank><strong>Values</strong></a> properties get objects that are subtypes of <strong>IEnumerable&lt;TKey></strong> and <strong>IEnumerable&lt;TValue></strong>, respectively, <strong>foreach</strong> loops may be used to iterate through these objects as well, in order to process all the keys or all the values stored in the dictionary. <strong>IEnumerable</strong> and <strong>IEnumerable&lt;T></strong> are <a href=/cis300/trees/tries/multiple-impl/>interfaces</a>; hence, we must define any subtypes so that they implement these interfaces. In this section, we will show how to implement the <strong>IEnumerable&lt;T></strong> interface to support a <strong>foreach</strong> loop.</p><p>The <strong>IEnumerable&lt;T></strong> interface requires two methods:</p><ul><li><strong>public IEnumerator&lt;T> GetEnumerator()</strong></li><li><strong>IEnumerator IEnumerable.GetEnumerator()</strong></li></ul><p>The latter method is required only because <strong>IEnumerable&lt;T></strong> is a subtype of <strong>IEnumerable</strong>, and that interface requires a <strong>GetEnumerator</strong> method that returns a non-generic <strong>IEnumerator</strong>. Both of these methods should return the same object; hence, because <strong>IEnumerator&lt;T></strong> is also a subtype of <strong>IEnumerator</strong>, this method can simply call the first method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>IEnumerator</span> <span class=n>IEnumerable</span><span class=p>.</span><span class=n>GetEnumerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GetEnumerator</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The <strong>public GetEnumerator</strong> method returns an <strong>IEnumerator&lt;T></strong>. In order to get instances of this interface, we could define a class that implements it; however, C# provides a simpler way to define a subtype of this interface, or, when needed, the <strong>IEnumerable&lt;T></strong> interface.</p><p>Defining such an enumerator is as simple as writing code to iterate through the elements of the data structure. As each element is reached, it is enumerated via a <strong>yield return</strong> statement. For example, suppose a dictionary implementation uses a <strong>List&lt;KeyValuePair&lt;TKey, TValue>></strong> called <code>_elements</code> to store its key-value pairs. We can then define its <strong>GetEnumerator</strong> method as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerator</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;</span> <span class=n>GetEnumerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;</span> <span class=n>p</span> <span class=k>in</span> <span class=n>_elements</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Suppose user code contains a <strong>Dictionary&lt;string, int></strong> called <code>d</code> and a <strong>foreach</strong> loop structured as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=kt>int</span><span class=p>&gt;</span> <span class=n>x</span> <span class=k>in</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Then the <strong>GetEnumerator</strong> method is executed until the <strong>yield return</strong> is reached. The state of this method is then saved, and the value <code>p</code> is used as the value for <code>x</code> in the first iteration of the <strong>foreach</strong> in the user code. When this loop reaches its second iteration, the <strong>GetEnumerator</strong> method resumes its execution until it reaches the <strong>yield return</strong> a second time, and again, the current value of <code>p</code> is used as the value of <code>x</code> in the second iteration of the loop in user code. This continues until the <strong>GetEnumerator</strong> method finishes; at this point, the loop in user code terminates.</p><p>Before continuing, we should mention that there is a simpler way of implementing the <strong>public GetEnumerator</strong> method in the above example. Because <strong>List&lt;T></strong> implements <strong>IEnumerable&lt;T></strong>, we can simply use its enumerator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerator</span><span class=p>&gt;</span> <span class=n>GetEnumerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_elements</span><span class=p>.</span><span class=n>GetEnumerator</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>However, the first solution illustrates a more general technique that can be used when we don&rsquo;t have the desired enumerator already available. For instance, continuing the above example, suppose we wish to define a <strong>Keys</strong> property to get an <strong>IEnumerable&lt;TKey></strong> that iterates through the keys in the dictionary. Because the dictionary now supports a <strong>foreach</strong> loop, we can define this code to iterate through the key-value pairs in the dictionary, rather than the key-value pairs stored in the <strong>List&lt;KeyVauePair&lt;TKey, TValue>></strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>&gt;</span> <span class=n>Keys</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>get</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>foreach</span> <span class=p>(</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;</span> <span class=n>p</span> <span class=k>in</span> <span class=k>this</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=k>return</span> <span class=n>p</span><span class=p>.</span><span class=n>Key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The above code is more maintainable than iterating through the <strong>List&lt;KeyValuePair&lt;TKey, TValue>></strong> as it doesn&rsquo;t depend on the specific implementation of the dictionary.</p><p>While this technique usually works best with iterative code, it can also be used with recursion, although the translation usually ends up being less direct and less efficient. Suppose, for example, our dictionary were implemented as in <a href=/cis300/trees/bst/>&ldquo;Binary Search Trees&rdquo;</a>, where a binary search tree is used. The idea is to adapt the <a href=/cis300/trees/bst/inorder/>inorder traversal</a> algorithm. However, we can&rsquo;t use this directly to implement a recursive version of the <strong>GetEnumerator</strong> method because this method does not take any parameters; hence, we can&rsquo;t apply it to arbitrary subtrees. Instead, we need a separate recursive method that takes a <strong>BinaryTreeNode&lt;KeyValuePair&lt;TKey, TValue>></strong> as its parameter and returns the enumerator we need. Another problem, though, is that the recursive calls will no longer do the processing that needs to be done on the children - they will simply return enumerators. We therefore need to iterate through each of these enumerators to include their elements in the enumerator we are returning:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>private</span> <span class=kd>static</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>GetEnumerable</span><span class=p>(</span><span class=n>BinaryTreeNode</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;?</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=p>!=</span> <span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>foreach</span> <span class=p>(</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;</span> <span class=n>p</span> <span class=k>in</span> <span class=n>GetEnumerable</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>LeftChild</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=k>return</span> <span class=n>t</span><span class=p>.</span><span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>foreach</span> <span class=p>(</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;</span> <span class=n>p</span> <span class=k>in</span> <span class=n>GetEnumerable</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>RightChild</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>yield</span> <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that we&rsquo;ve made the return type of this method <strong>IEnumerable&lt;KeyValuePair&lt;TKey, TValue>></strong> because we need to use a <strong>foreach</strong> loop on the result of the recursive calls. Then because any instance of this type must have a <strong>GetEnumerator</strong> method, we can implement the <strong>GetEnumerator</strong> method for the dictionary as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerator</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;</span> <span class=n>GetEnumerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>GetEnumerable</span><span class=p>(</span><span class=n>_elements</span><span class=p>).</span><span class=n>GetEnumerator</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>In transforming the inorder traversal into the above code, we have introduced some extra loops. These loops lead to less efficient code. Specifically, if the binary search tree is an AVL tree or other balanced binary tree, the time to iterate through this enumerator is in <span style=white-space:nowrap><span class="math align-center">$ O(n \lg n) $</span>,</span> where
<span class="math align-center">$ n $</span> is the number of nodes in the tree. The inorder traversal, by contrast, runs in
<span class="math align-center">$ O(n) $</span> time. In order to achieve this running time with an enumerator, we need to translate the inorder traversal to iterative code using a stack. However, this code isn&rsquo;t easy to understand:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerator</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;</span> <span class=n>GetEnumerator</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span><span class=p>&lt;</span><span class=n>BinaryTreeNode</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;&gt;</span> <span class=n>s</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTreeNode</span><span class=p>&lt;</span><span class=n>KeyValuePair</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;&gt;?</span> <span class=n>t</span> <span class=p>=</span> <span class=n>_elements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>t</span> <span class=p>!=</span> <span class=kc>null</span> <span class=p>||</span> <span class=n>s</span><span class=p>.</span><span class=n>Count</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>t</span> <span class=p>!=</span> <span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>t</span> <span class=p>=</span> <span class=n>t</span><span class=p>.</span><span class=n>LeftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=p>=</span> <span class=n>s</span><span class=p>.</span><span class=n>Pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>yield</span> <span class=k>return</span> <span class=n>t</span><span class=p>.</span><span class=n>Data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=p>=</span> <span class=n>t</span><span class=p>.</span><span class=n>RightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1737489328 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737489328 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1737489328></script><script src=/cis300/js/theme.js?1737489328 defer></script><script src=/cis300/js/embed-iframe.js?1737489328 defer></script></body></html>