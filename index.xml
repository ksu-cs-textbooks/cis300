<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/</link><description>Data Structures in C# Rod Howell
Dept. of Computer Science
Kansas State University
Manhattan, KS 66506
USA
Email: rhowell@ksu.edu
This text is supplemental material for CIS 300 at Kansas State University. Its purpose is to provide a written summary of the material covered, with additional explanation and code examples beyond what are presented in class. A background of programming in Java is assumed, and an appendix summarizing some of the syntax of C# is provided. Because CIS 300 is a lab class, no attempt is made here to provide examples for all of the topics covered; instead, students are expected to provide many of their own examples through the lab exercises (in most cases, solutions to these exercises will be provided to enrolled students following the lab).</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/index.xml" rel="self" type="application/rss+xml"/><item><title>Input/Output</title><link>https://textbooks.cs.ksu.edu/cis300/io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/io/</guid><description>Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event. A method in the program then responds to that event by reading information that the user has typed into various controls on the GUI, and processes that information. It may then provide output to the user by writing results to various controls on the GUI.</description></item><item><title>strings and StringBuilders</title><link>https://textbooks.cs.ksu.edu/cis300/strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/strings/</guid><description>strings and StringBuilders C# and .NET provide two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other.</description></item><item><title>Stacks and Queues</title><link>https://textbooks.cs.ksu.edu/cis300/stacks-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/stacks-queues/</guid><description>Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an “Undo” operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations. However, we don’t want to undo just any operation in this sequence - we need to undo the most recent one that hasn’t yet been undone. We therefore need to access the operations in last-in-first-out, or LIFO, order. Other applications might need to access data items in first-in-first-out, or FIFO, order. In this chapter, we will examine data structures that support these kinds of access.</description></item><item><title>Linked Lists</title><link>https://textbooks.cs.ksu.edu/cis300/linked-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/linked-lists/</guid><description>Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array. As we will see in a later chapter, this chaining technique can be further exploited to link data items in a hierarchical way, providing even more flexible and efficient access.</description></item><item><title>Dictionaries</title><link>https://textbooks.cs.ksu.edu/cis300/dictionaries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/dictionaries/</guid><description>Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by .NET. We will then consider two ways of implementing dictionaries. Later chapters will examine improvements over these implementations.</description></item><item><title>Trees</title><link>https://textbooks.cs.ksu.edu/cis300/trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/trees/</guid><description>Trees Binary search provides an efficient way to find elements in a sorted array-like structure. However, inserting or removing from an array-like structure can be expensive because all subsequent data elements must be moved to accommodate the change. On the other hand, linked lists can be modified efficiently, provided we have a reference to the cell preceding the insertion or deletion point. However, finding a cell can be expensive because the only way to search a linked list is to start at the front and work through it a cell at a time. We would like a data structure that provides both efficient lookups and efficient insertions and deletions.</description></item><item><title>Hash Tables</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/</guid><description>Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .NET’s Dictionary&lt;TKey, TValue> class.</description></item><item><title>Graphs</title><link>https://textbooks.cs.ksu.edu/cis300/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/graphs/</guid><description>Graphs In this chapter, we examine a data structure known as a graph, which can be used to represent a wide variety of data sets in which pairs of data items are related in a certain way. Examples of such data sets include road maps, data flows or control flows in programs, and representations of communication networks. Because graphs are so widely used, numerous algorithms on graphs have been devised. As a result, the same algorithm can often be applied to a variety of applications because the underlying data structure for each application is a graph.</description></item><item><title>Sorting</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/</guid><description>Sorting We conclude this text with a look at a common activity in computing, namely, sorting data. While .NET provides several methods for sorting data, it is instructive to examine the implementation details of different techniques. While there is one sorting algorithm that is used more commonly than the others, none is best for all situations. An understanding of which algorithms perform better in different situations can help us to make better choices and thereby achieve better performance for the software we build. Furthermore, because there are so many different approaches to sorting, studying the various techniques can help us to see how different approaches can be used for the same problem in order to obtain different algorithms.</description></item><item><title>Appendices</title><link>https://textbooks.cs.ksu.edu/cis300/appendix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/appendix/</guid><description>Appendices The appendices contain material that does not fit well into the flow of the main text. They may be used for reference as needed.</description></item></channel></rss>