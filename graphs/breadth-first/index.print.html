<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Unweighted Shortest Paths In some shortest path problems, all edges have the same length. For example, we may be trying to find the shortest path out of a maze. Each cell in the maze is a node, and an edge connects two nodes if we can move between them in a single step. In this problem, we simply want to minimize the number of edges in a path to an exit."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unweighted Shortest Paths :: Data Structures in C#"><meta name=twitter:description content="Unweighted Shortest Paths In some shortest path problems, all edges have the same length. For example, we may be trying to find the shortest path out of a maze. Each cell in the maze is a node, and an edge connects two nodes if we can move between them in a single step. In this problem, we simply want to minimize the number of edges in a path to an exit."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/graphs/breadth-first/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Unweighted Shortest Paths :: Data Structures in C#"><meta property="og:description" content="Unweighted Shortest Paths In some shortest path problems, all edges have the same length. For example, we may be trying to find the shortest path out of a maze. Each cell in the maze is a node, and an edge connects two nodes if we can move between them in a single step. In this problem, we simply want to minimize the number of edges in a path to an exit."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Graphs"><meta property="article:modified_time" content="2023-06-08T11:09:26-05:00"><meta itemprop=name content="Unweighted Shortest Paths :: Data Structures in C#"><meta itemprop=description content="Unweighted Shortest Paths In some shortest path problems, all edges have the same length. For example, we may be trying to find the shortest path out of a maze. Each cell in the maze is a node, and an edge connects two nodes if we can move between them in a single step. In this problem, we simply want to minimize the number of edges in a path to an exit."><meta itemprop=dateModified content="2023-06-08T11:09:26-05:00"><meta itemprop=wordCount content="548"><title>Unweighted Shortest Paths :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1719513823 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1719513823 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1719513823 rel=stylesheet><link href=/cis300/css/auto-complete.css?1719513823 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1719513823 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1719513823 rel=stylesheet><link href=/cis300/css/fonts.css?1719513823 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1719513823 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1719513823 rel=stylesheet><link href=/cis300/css/theme-auto.css?1719513823 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1719513823 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1719513823 rel=stylesheet><link href=/cis300/css/print.css?1719513823 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1719513823 rel=stylesheet><script src=/cis300/js/variant.js?1719513823></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1719513823 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/graphs/breadth-first/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/cis300/graphs/><span itemprop=name>Graphs</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Unweighted Shortest Paths</span><meta itemprop=position content="2"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/graphs/dijkstra/ title="Shortest Paths (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/graphs/impl/ title="Implementing a Graph (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=unweighted-shortest-paths>Unweighted Shortest Paths</h1></div><h2 id=unweighted-shortest-paths>Unweighted Shortest Paths</h2><p>In some shortest path problems, all edges have the same length. For
example, we may be trying to find the shortest path out of a maze. Each
cell in the maze is a node, and an edge connects two nodes if we can
move between them in a single step. In this problem, we simply want to
minimize the number of edges in a path to an exit. We therefore say that
the edges are <em>unweighted</em> &mdash; they contain no explicit length
information, and the length of each edge is considered to be <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span></p><p>We could of course apply <a href=/cis300/graphs/dijkstra/>Dijkstra&rsquo;s
algorithm</a> to this
problem, using
<span class="math align-center">$ 1 $</span> as the length of each edge. However, if analyze what
this algorithm does in this case, we find that we can optimize it to
achieve significantly better performance.</p><p>The optimization revolves around the use of the min-priority queue. Note
that Dijkstra&rsquo;s algorithm first adds all outgoing edges from the start
node <em>u</em> to the min-priority queue, using their lengths as their
priorities. For unweighted edges, each of these priorities will be <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span> As
the algorithm progresses it retrieves the minimum priority and removes
an edge having this priority. If it adds any new edges before removing
the next edge, they will all have a priority
<span class="math align-center">$ 1 $</span> greater than the priority
of the edge just removed.</p><p>We claim that this behavior causes the priorities in the min-priority
queue to differ by no more than
<span class="math align-center">$ 1 $</span>. To see this, we will show that we can
never reach a point where we change the maximum difference in priorities
from at most
<span class="math align-center">$ 1 $</span> to more than <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span> First observe that when the outgoing
edges from <em>u</em> are added, the priorities all differ by
<span style=white-space:nowrap><span class="math align-center">$ 0 \leq 1 $</span>.</span> Removing an edge can&rsquo;t increase the
difference in the priorities stored. Suppose the edge we remove has
priority <span style=white-space:nowrap><span class="math align-center">$ p $</span>.</span> Assuming we have not yet achieved a priority difference
greater than <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>,</span> any priorities remaining in the min-priority queue must
be either
<span class="math align-center">$ p $</span> or <span style=white-space:nowrap><span class="math align-center">$ p + 1 $</span>.</span> Any edges we add before removing the
next edge have priority <span style=white-space:nowrap><span class="math align-center">$ p + 1 $</span>.</span> Hence, the priority difference
remains no more than <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span> Because we have covered all changes to the
priority queue, we can never cause the priority difference to exceed <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span></p><p>Based on the above claim, we can now claim that whenever an edge is
added, its priority is the largest of any in the min-priority queue.
This is certainly true when we add the outgoing edges from <em>u</em>, as all
these edges have the same priority. Furthermore, whenever we remove an
edge with priority <span style=white-space:nowrap><span class="math align-center">$ p $</span>,</span> any edges we subsequently add have priority
<span style=white-space:nowrap><span class="math align-center">$ p + 1 $</span>,</span> which must be the maximum priority in the min-priority
queue.</p><p>As a result of this behavior, we can replace the min-priority queue with
an ordinary <a href=/cis300/stacks-queues/queues/>FIFO queue</a>, ignoring any priorities. For a graph with unweighted edges, the behavior of the algorithm will be the same.
Because accessing a FIFO queue is more efficient than accessing a
min-priority queue, the resulting algorithm, known as <em>breadth-first
search</em>, is also more efficient.</p><footer class=footline></footer></article></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Rod Howell
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/e03f84f5af25e9ecbeb351ca00f76eb9d0cb57da>Jun 8, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1719513823 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1719513823 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1719513823></script><script src=/cis300/js/theme.js?1719513823 defer></script></body></html>