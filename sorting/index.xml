<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sorting :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/</link><description>Sorting We conclude this text with a look at a common activity in computing, namely, sorting data. While .NET provides several methods for sorting data, it is instructive to examine the implementation details of different techniques. While there is one sorting algorithm that is used more commonly than the others, none is best for all situations. An understanding of which algorithms perform better in different situations can help us to make better choices and thereby achieve better performance for the software we build.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/sorting/index.xml" rel="self" type="application/rss+xml"/><item><title>Select Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/select/</guid><description>Select Sorts A select sort operates by repeatedly selecting the smallest data element of an unsorted portion of the array and moving it to the end of a sorted portion. Thus, at each step, the data items will be arranged into two parts:
A sorted part; and An unsorted part in which each element is at least as large as all elements in the sorted part. The following figure illustrates this arrangement.</description></item><item><title>Insert Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/insert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/insert/</guid><description>Insert Sorts An insert sort operates by repeatedly inserting an element into a sorted portion of the array. Thus, as for select sorts, at each step the data items will be arranged into a sorted part, followed by an unsorted part; however, for insert sorts, there is no restriction on how elements in the unsorted part compare to elements in the sorted part. The following figure illustrates this arrangement.
Initially, the sorted part will contain the first element, as a single element is always sorted.</description></item><item><title>Merge Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/merge/</guid><description>Merge Sorts A merge sort works by merging together two sorted parts of an array. Thus, we should focus our attention on an array that is partitioned into two sorted parts, as shown in the following figure.
The different ways of implementing a merge sort depend both on how the above arrangement is achieved, and also on how the two parts are merged together. The simplest implementation is an algorithm simply called merge sort.</description></item><item><title>Split Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/split/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/split/</guid><description>Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.
To complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress.</description></item><item><title>Hybrid Sorting Algorithms</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/hybrid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/hybrid/</guid><description>Hybrid Sorting Algorithms The best versions of quick sort are competitive with both heap sort and merge sort on the vast majority of inputs. However, quick sort has a very bad worst case — $ O(n^2) $ running time and $ O(n) $ stack usage. By comparison, both heap sort and merge sort have $ O(n \lg n) $ worst-case running time, together with a stack usage of $ O(1) $ for heap sort or $ O(\lg n) $ for merge sort.</description></item><item><title>Sorting Strings</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/strings/</guid><description>Sorting Strings We conclude our discussion of sorting with a look at a sorting algorithm designed specifically for sorting multi-keyed data. In such data there is a primary key, a secondary key, and so on. We want to sort the data so that element a precedes element b if:
the primary key of a is less than the primary key of b; or their primary keys are equal, but the secondary key of a is less than the secondary key of b; etc.</description></item></channel></rss>