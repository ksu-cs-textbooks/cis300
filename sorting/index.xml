<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sorting :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/</link><description>Sorting We conclude this text with a look at a common activity in computing, namely, sorting data. While .NET provides several methods for sorting data, it is instructive to examine the implementation details of different techniques. While there is one sorting algorithm that is used more commonly than the others, none is best for all situations. An understanding of which algorithms perform better in different situations can help us to make better choices and thereby achieve better performance for the software we build. Furthermore, because there are so many different approaches to sorting, studying the various techniques can help us to see how different approaches can be used for the same problem in order to obtain different algorithms.</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/sorting/index.xml" rel="self" type="application/rss+xml"/><item><title>Select Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/select/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/select/</guid><description>Select Sorts A select sort operates by repeatedly selecting the smallest data element of an unsorted portion of the array and moving it to the end of a sorted portion. Thus, at each step, the data items will be arranged into two parts:
A sorted part; and An unsorted part in which each element is at least as large as all elements in the sorted part. The following figure illustrates this arrangement.</description></item><item><title>Insert Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/insert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/insert/</guid><description>Insert Sorts An insert sort operates by repeatedly inserting an element into a sorted portion of the array. Thus, as for select sorts, at each step the data items will be arranged into a sorted part, followed by an unsorted part; however, for insert sorts, there is no restriction on how elements in the unsorted part compare to elements in the sorted part. The following figure illustrates this arrangement.</description></item><item><title>Merge Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/merge/</guid><description>Merge Sorts A merge sort works by merging together two sorted parts of an array. Thus, we should focus our attention on an array that is partitioned into two sorted parts, as shown in the following figure.
The different ways of implementing a merge sort depend both on how the above arrangement is achieved, and also on how the two parts are merged together. The simplest implementation is an algorithm simply called merge sort.</description></item><item><title>Split Sorts</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/split/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/split/</guid><description>Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.</description></item><item><title>Hybrid Sorting Algorithms</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/hybrid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/hybrid/</guid><description>Hybrid Sorting Algorithms The best versions of quick sort are competitive with both heap sort and merge sort on the vast majority of inputs. However, quick sort has a very bad worst case — $ O(n^2) $ running time and $ O(n) $ stack usage. By comparison, both heap sort and merge sort have $ O(n \lg n) $ worst-case running time, together with a stack usage of $ O(1) $ for heap sort or $ O(\lg n) $ for merge sort. Furthermore, insertion sort performs better than any of these algorithms on small data sets. In this section, we look at ways to combine some of these algorithms to obtain a sorting algorithm that has the advantages of each of them.</description></item><item><title>Sorting Strings</title><link>https://textbooks.cs.ksu.edu/cis300/sorting/strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/sorting/strings/</guid><description>Sorting Strings We conclude our discussion of sorting with a look at a sorting algorithm designed specifically for sorting multi-keyed data. In such data there is a primary key, a secondary key, and so on. We want to sort the data so that element a precedes element b if:
the primary key of a is less than the primary key of b; or their primary keys are equal, but the secondary key of a is less than the secondary key of b; etc. An example of multi-keyed data is strings. The first character of a string is its primary key, its second character is its secondary key, and so on. The only caveat is that the strings may not all have the same length; hence, they may not all have the same number of keys. We therefore stipulate that a string that does not have a particular key must precede all strings that have that key.</description></item></channel></rss>