<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.
To complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Split Sorts :: Data Structures in C#"><meta name=twitter:description content="Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.
To complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/sorting/split/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Split Sorts :: Data Structures in C#"><meta property="og:description" content="Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.
To complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Sorting"><meta property="article:modified_time" content="2023-05-22T14:36:43-05:00"><meta itemprop=name content="Split Sorts :: Data Structures in C#"><meta itemprop=description content="Split Sorts A split sort operates by splitting the array into three parts:
An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p. This arrangement is illustrated in the following figure.
To complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="1428"><title>Split Sorts :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1756127992 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1756127992 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1756127992 rel=stylesheet><link href=/cis300/css/auto-complete.css?1756127992 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1756127992 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1756127992 rel=stylesheet><link href=/cis300/css/fonts.css?1756127992 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1756127992 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1756127992 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1756127992 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1756127992 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1756127992 rel=stylesheet><link href=/cis300/css/print.css?1756127992 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1756127992 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/sorting/split/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=split-sorts>Split Sorts</h2><p>A <em>split sort</em> operates by splitting the array into three parts:</p><ul><li>An unsorted part containing elements less than or equal to some
<em>pivot element p</em>.</li><li>A nonempty part containing elements equal to <em>p</em>.</li><li>An unsorted part containing elements greater than or equal to <em>p</em>.</li></ul><p>This arrangement is illustrated in the following figure.</p><p><a href=#R-image-c3926bb3b6b52bb1d8593a7173e2071c class=lightbox-link><img alt="The arrangement attained by a split sort." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/sorting/split/split-sorts.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c3926bb3b6b52bb1d8593a7173e2071c><img alt="The arrangement attained by a split sort." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/sorting/split/split-sorts.jpg></a></p><p>To complete the sort, it then sorts the two unsorted parts. Note that
because the second part is nonempty, each of the two unsorted parts is
smaller than the original data set; hence, the algorithm will always
make progress.</p><p>The various implementations of a split sort are collectively known as
<em>quick sort</em>. They differ in how many elements are placed in the middle
part (only one element or all elements equal to the pivot), how the
pivot is chosen, how the elements are partitioned into three parts, and
how the two sub-problems are sorted. We will examine only two
variations, which differ in how the pivot element is chosen.</p><p>Let&rsquo;s start with how we do the partitioning. Let <em>p</em> denote the pivot
element. Because most of the split sort implementations use recursion to
complete the sort, we&rsquo;ll assume that we are sorting a portion of an
array. At each stage of the partitioning, the array portion we are
sorting will be arranged into the following four segments:</p><ol><li><strong>Segment L:</strong> Elements less than <em>p</em>.</li><li><strong>Segment U:</strong> Elements we haven&rsquo;t yet examined (i.e., unknown
elements).</li><li><strong>Segment E:</strong> Elements equal to <em>p</em>.</li><li><strong>Segment G:</strong> Elements greater than <em>p</em>.</li></ol><p>Initially, segments L, E, and G will be empty, and each iteration will
reduce the size of segment U. The partitioning will be finished when
segment U is empty. We will need three local variables to keep track of
where one segment ends and another segment begins, as shown in the
following figure:</p><p><a href=#R-image-a4fcdd9ecc707d3d47d6a70cb00cbf43 class=lightbox-link><img alt="The arrangement for partitioning in quick\nsort." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/sorting/split/quick-sort-partitioning.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a4fcdd9ecc707d3d47d6a70cb00cbf43><img alt="The arrangement for partitioning in quick\nsort." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/sorting/split/quick-sort-partitioning.jpg></a></p><p>We have worded the descriptions of the three local variables so that
they make sense even if some of the segments are empty. Thus, because
all segments except U are initially empty, the location following
segment L will initially be the first location in the array portion that
we are sorting, and the other two variables will initially be the last
location in this portion. We then need a loop that iterates as long as
segment U is nonempty &mdash; i.e., as long as the location following segment
L is no greater than the location preceding segment E. Each iteration of
this loop will compare the last element in segment U (i.e., the element
at the location preceding segment E) with <em>p</em>. We will swap this element
with another depending on how it compares with <em>p</em>:</p><ul><li>If it is less than <em>p</em>, we swap it with the element following
segment L, and adjust the end of segment L to include it.</li><li>If it is equal to <em>p</em>, we leave it where it is, and adjust the
beginning of segment E to include it.</li><li>If it is greater than <em>p</em>, we swap it with the element preceding
segment G, adjust the beginning of segment G to include it, and
adjust the beginning of segment E to account for the fact that we
are shifting this segment to the left by 1.</li></ul><p>Once this loop completes, the partitioning will be done. Furthermore, we
can determine the two parts that need to be sorted from the final values
of the local variables.</p><p>The first split sort implementation we will consider is fairly
straightforward, given the above partitioning scheme. If we are sorting
more than one element (otherwise, there is nothing to do), we will use
as the pivot element the first element of the array portion to be
sorted. After partitioning, we then sort the elements less than the
pivot using a recursive call, and sort the elements greater than the
pivot with another.</p><p>Though we won&rsquo;t give an analysis here, the above algorithm runs in
<span class="math align-center">$ O(n^2) $</span> time in the worst case, where
<span class="math align-center">$ n $</span> is the number of
elements being sorted. However, as we saw with <a href=/cis300/sorting/insert/>insertion
sort</a>, the worst-case
running time doesn&rsquo;t always tell the whole story. Specifically, the
expected running time of quick sort (this implementation and others) on
random arrays is in <span style=white-space:nowrap><span class="math align-center">$ O(n \lg n) $</span>.</span></p><p>However, we don&rsquo;t often need to sort random data. Let&rsquo;s therefore take a
closer look at what makes the worst case bad. In some ways this
algorithm is like merge sort &mdash; it does two recursive calls, and the
additional work is proportional to the number of elements being sorted.
The difference is that the recursive calls in merge sort are both on
array portions that are about half the size of the portion being sorted.
With this quick sort implementation, on the other hand, the sizes of the
recursive calls depend on how the first element (i.e., the pivot
element) compares to the other elements. The more elements that end up
in one recursive call, the slower the algorithm becomes. Consequently,
the worst case occurs when the array is already sorted, and is still bad
if the array is nearly sorted. For this reason, this is a particularly
bad implementation.</p><p>Before we look at how we can improve the performance, we need to
consider one other aspect of this implementation&rsquo;s performance. For a
recursive method, the amount of data pushed on the runtime stack is
proportional to the depth of the recursion. In the worst cases (i.e., on
a sorted array), the recursion depth is <span style=white-space:nowrap><span class="math align-center">$ n $</span>.</span> Thus, for large <span style=white-space:nowrap><span class="math align-center">$ n $</span>,</span> if the
array is sorted or nearly sorted, a <strong>StackOverflowException</strong> is
likely. <span id=median-of-3></span></p><p>The most important thing we can do to improve the performance, in terms
of both running time and stack usage, is to be more careful about how we
choose the pivot element. We want to choose an element that partitions
the data elements roughly in half. The median element (i.e., the element
that belongs in the middle after the array is sorted) will therefore
give us the optimal split. It is possible to design an
<span class="math align-center">$ O(n \lg n) $</span> algorithm that uses the median as the
pivot; however, the time it takes to find the median makes this
algorithm slower than merge sort in practice. It works much better to
find a quick approximation for the median.</p><p>The main technique for obtaining such an approximation is to examine
only a few of the elements. For example, we can use <em>median-of-three
partitioning</em>, which uses as its pivot element the median of the first,
middle, and last elements of the array portion we are sorting. An easy
way to implement this strategy is to place these three elements in an
array of size 3, then sort this array using <a href=/cis300/sorting/insert/>insertion
sort</a>. The element that
ends up at location 1 is then the used as the pivot.</p><p>We can improve on the above strategy by doing a case analysis of the
three values. If we do this, we don&rsquo;t need a separate array &mdash; we just
find the median of three values, <span style=white-space:nowrap><span class="math align-center">$ a $</span>,</span> <span style=white-space:nowrap><span class="math align-center">$ b $</span>,</span> and <span style=white-space:nowrap><span class="math align-center">$ c $</span>,</span> as follows:</p><ul><li>If <span style=white-space:nowrap><span class="math align-center">$ a \lt b $</span>:</span><ul><li>If <span style=white-space:nowrap><span class="math align-center">$ b \lt c $</span>,</span> then
<span class="math align-center">$ b $</span> is the median.</li><li>Otherwise, because
<span class="math align-center">$ b $</span> is the largest:<ul><li>If <span style=white-space:nowrap><span class="math align-center">$ a \lt c $</span>,</span> then
<span class="math align-center">$ c $</span> is the median.</li><li>Otherwise,
<span class="math align-center">$ a $</span> is the median.</li></ul></li></ul></li><li>Otherwise, because <span style=white-space:nowrap><span class="math align-center">$ b \leq a $</span>:</span><ul><li>If <span style=white-space:nowrap><span class="math align-center">$ a \lt c $</span>,</span> then
<span class="math align-center">$ a $</span> is the median.</li><li>Otherwise, because
<span class="math align-center">$ a $</span> is the largest:<ul><li>If <span style=white-space:nowrap><span class="math align-center">$ b \lt c $</span>,</span> then
<span class="math align-center">$ c $</span> is the median.</li><li>Otherwise,
<span class="math align-center">$ b $</span> is the median.</li></ul></li></ul></li></ul><p>The above algorithm is quite efficient, using at most three comparisons
and requiring no values to be copied other than the result if we
implement it in-line, rather than as a separate method (normally an
optimizing compiler can do this method inlining for us). It also
improves the sorting algorithm by tending to make the bad cases less
likely.</p><p>This version of quick sort gives good performance most of the time,
typically outperforming either <a href=/cis300/sorting/select/#heap-sort>heap
sort</a> or <a href=/cis300/sorting/merge/>merge
sort</a>. However, it still
has a worst-case running time in
<span class="math align-center">$ O(n^2) $</span> and a worst-case
stack usage in <span style=white-space:nowrap><span class="math align-center">$ O(n) $</span>.</span> Furthermore, it is unstable and does not
perform as well as <a href=/cis300/sorting/insert/>insertion
sort</a> on small or nearly
sorted data sets. In <a href=/cis300/sorting/hybrid/>the next
section</a>, we will show
how quick sort can be combined with some of the other sorting algorithms
to address some of these issues, including the bad worst-case
performance.</p><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1756127992 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1756127992 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1756127992></script><script src=/cis300/js/theme.js?1756127992 defer></script><script src=/cis300/js/embed-iframe.js?1756127992 defer></script></body></html>