<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality. We will then show how the comparison can be defined so that all of these mechanisms behave in a consistent way."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Equality in C# :: Data Structures in C#"><meta name=twitter:description content="Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality. We will then show how the comparison can be defined so that all of these mechanisms behave in a consistent way."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/hashing/equality/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Equality in C# :: Data Structures in C#"><meta property="og:description" content="Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality. We will then show how the comparison can be defined so that all of these mechanisms behave in a consistent way."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Hash Tables"><meta property="article:modified_time" content="2023-06-07T11:36:57-05:00"><meta itemprop=name content="Equality in C# :: Data Structures in C#"><meta itemprop=description content="Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality. We will then show how the comparison can be defined so that all of these mechanisms behave in a consistent way."><meta itemprop=dateModified content="2023-06-07T11:36:57-05:00"><meta itemprop=wordCount content="2253"><title>Equality in C# :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/hashing/equality/ rel=canonical type=text/html title="Equality in C# :: Data Structures in C#"><link href=/cis300/hashing/equality/index.xml rel=alternate type=application/rss+xml title="Equality in C# :: Data Structures in C#"><link href=/cis300/hashing/equality/tele.html rel=alternate type=text/html title="Equality in C# :: Data Structures in C#"><link href=/cis300/hashing/equality/embed.html rel=alternate type=text/html title="Equality in C# :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1768892168 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1768892168 defer></script><script src=/cis300/js/search-lunr.min.js?1768892168 defer></script><script src=/cis300/js/search.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1768892168"</script><script src=/cis300/js/lunr/lunr.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1768892168 rel=stylesheet><link href=/cis300/css/theme.min.css?1768892168 rel=stylesheet><link href=/cis300/css/format-print.min.css?1768892168 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/hashing/equality/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1768892168 rel=stylesheet></head><body class="mobile-support print" data-url=/cis300/hashing/equality/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable hashing" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=equality-in-c>Equality in C#</h1></div><h2 id=equality-in-c>Equality in C#</h2><p>Continuing our discussion from <a href=/cis300/hashing/memoization/>the previous
section</a>, we want to
define a type that represents a Nim board. Furthermore, we need to be
able to compare instances of this type for equality. Before we can
address how this can be done, we first need to take a careful look at
how C# handles equality. In what follows, we will discuss how C#
handles the <code>==</code> operator, the non-<strong>static</strong> <strong>Equals</strong> method, and two
<strong>static</strong> methods for determining equality. We will then show how the
comparison can be defined so that all of these mechanisms behave in a
consistent way.</p><p>We first consider the <code>==</code> operator. The behavior of this operator is
determined by the <em>compile-time</em> types of its operands. This is
determined by the declared types of variables, the declared return types
of methods or properties, and the rules for evaluating expressions.
Thus, for example, if we have a statement</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>object</span> <span class=n>x</span> <span class=p>=</span> <span class=s>&#34;abc&#34;</span><span class=p>;</span></span></span></code></pre></div><p>the compile-time type of <code>x</code> is <strong>object</strong>, even though it actually
refers to a <strong>string</strong>.</p><p>For pre-defined <a href=/cis300/appendix/syntax/reference-value/>value
types</a>, <code>==</code> evaluates
to <strong>true</strong> if its operands contain the same values. Because
<a href=/cis300/appendix/syntax/enumerations/>enumerations</a> are
represented as numeric types such as <strong>int</strong> or <strong>byte</strong>, this rule
applies to them as well. For user-defined structures, <code>==</code> is undefined
unless the structure definition explicitly defines the <code>==</code> and <code>!=</code>
operators. We will show how this can be done below.</p><p>By default, when <code>==</code> is applied to reference types, it evaluates to
<strong>true</strong> when the two operands refer to the same object (i.e., they
refer to the same memory location). A class may override this behavior
by explicitly defining the <code>==</code> and <code>!=</code> operators. For example, the
<strong>string</strong> class defines the <code>==</code> operator to evaluate to <strong>true</strong> if the
given <strong>string</strong>s are the same length and contain the same sequence of
characters.</p><p>Let&rsquo;s consider an example that illustrates the rules for reference
types:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kt>string</span> <span class=n>a</span> <span class=p>=</span> <span class=s>&#34;abc&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=n>b</span> <span class=p>=</span> <span class=s>&#34;0abc&#34;</span><span class=p>.</span><span class=n>Substring</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>object</span> <span class=n>x</span> <span class=p>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>object</span> <span class=n>y</span> <span class=p>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp1</span> <span class=p>=</span> <span class=n>a</span> <span class=p>==</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp2</span> <span class=p>=</span> <span class=n>x</span> <span class=p>==</span> <span class=n>y</span><span class=p>;</span></span></span></code></pre></div><p>The first two lines assign to <code>a</code> and <code>b</code> the same sequence of
characters; however, because the <strong>string</strong>s are computed differently,
they are different objects. The next two lines copy the reference in <code>a</code>
to <code>x</code> and the reference in <code>b</code> to <code>y</code>. Thus, at this point, all four
variables refer to a <strong>string</strong> &ldquo;abc&rdquo;; however, <code>a</code> and <code>x</code> refer to a
different object than do <code>b</code> and <code>y</code>. The fifth line compares <code>a</code> and
<code>b</code> for equality using <code>==</code>. The compile-time types of <code>a</code> and <code>b</code> are
both <strong>string</strong>; hence, these variables are compared using the rules for
comparing <strong>string</strong>s. Because they refer to <strong>string</strong>s of the same
length and containing the same sequence of characters, <code>comp1</code> is
assigned <strong>true</strong>. The behavior of the last line is determined by the
compile-time types of <code>x</code> and <code>y</code>. These types are both <strong>object</strong>,
which defines the default behavior of this operator for reference types.
Thus, the comparison determines whether the two variables refer to the
same object. Because they do not, <code>comp2</code> is assigned <strong>false</strong>.</p><p>Now let&rsquo;s consider the non-<strong>static</strong> <strong>Equals</strong> method. The biggest
difference between this method and the <code>==</code> operator is that the behavior
of <code>x.Equals(y)</code> is determined by the <em>run-time</em> type of <code>x</code>. This is
determined by the actual type of the object, independent of how any
variables or return types are declared.</p><p>By default, if <code>x</code> is a value type and <code>y</code> can be treated as having the
same type, then <code>x.Equals(y)</code> returns <strong>true</strong> if <code>x</code> and <code>y</code> have the
same value (if <code>y</code> can&rsquo;t be treated as having the same type as <code>x</code>, then
this method returns <strong>false</strong>). Thus, for pre-defined value types, the
behavior is the same as for <code>==</code> once the types are determined (provided
the types are consistent). However, the <strong>Equals</strong> method is always
defined, whereas the <code>==</code> operator may not be. Furthermore, structures may
<em>override</em> this method to change this behavior &mdash; we will show how to do
this below.</p><p>By default, if <code>x</code> is a reference type, <code>x.Equals(y)</code> returns <strong>true</strong>
if <code>x</code> and <code>y</code> refer to the same object. Hence, this behavior is the
same as for <code>==</code> once the types are determined (except that if <code>x</code> is
<strong>null</strong>, <code>x.Equals(y)</code> will throw a <strong>NullReferenceException</strong>,
whereas <code>x == y</code> will not). However, classes may override this
method to change this behavior. For example, the <strong>string</strong> class
overrides this method to return <strong>true</strong> if <code>y</code> is a <strong>string</strong> of the
same length and contains the same sequence of characters as <code>x</code>.</p><p>Let&rsquo;s now continue the above example by adding the following lines:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp3</span> <span class=p>=</span> <span class=n>a</span><span class=p>.</span><span class=n>Equals</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp4</span> <span class=p>=</span> <span class=n>a</span><span class=p>.</span><span class=n>Equals</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp5</span> <span class=p>=</span> <span class=n>x</span><span class=p>.</span><span class=n>Equals</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>comp6</span> <span class=p>=</span> <span class=n>x</span><span class=p>.</span><span class=n>Equals</span><span class=p>(</span><span class=n>y</span><span class=p>);</span></span></span></code></pre></div><p>These all evaluate to <strong>true</strong> for one simple reason &mdash; the behavior is
determined by the run-time type of <code>a</code> in the case of the first two
lines, or of <code>x</code> in the case of the last two lines. Because these types
are both <strong>string</strong>, the objects are compared as <strong>string</strong>s.</p><details open class="box cstyle notices note"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-exclamation-circle"></i>
Note</summary><div class=box-content><p>It&rsquo;s actually a bit more complicated in the case of <code>comp3</code>, but we&rsquo;ll explain
this later.</p></div></details><p>The <strong>object</strong> class defines, in addition to the <strong>Equals</strong> method
described above, two <strong>public static</strong> methods, which are in turn
inherited by every type in C#:</p><ul><li><strong>bool Equals(object x, object y)</strong>: The main purpose of this method
is to avoid the <strong>NullReferenceException</strong> that is thrown by
<code>x.Equals(y)</code> when <code>x</code> is <strong>null</strong>. If neither <code>x</code> nor <code>y</code> is
<strong>null</strong>, this method simply returns the value of <code>x.Equals(y)</code>.
Otherwise, it will return <strong>true</strong> if both <code>x</code> and <code>y</code> are <strong>null</strong>, or <strong>false</strong> if only one is <strong>null</strong>.
User-defined types cannot override this method, but because it calls
the non-<strong>static Equals</strong> method, which they can override, they can
affect its behavior indirectly.</li><li><strong>bool ReferenceEquals(object x, object y)</strong>: This method returns
<strong>true</strong> if <code>x</code> and <code>y</code> refer to the same object or are both
<strong>null</strong>. If either <code>x</code> or <code>y</code> is a value type, it will return
<strong>false</strong>. User-defined types cannot override this method.</li></ul><p>Finally, there is nothing to prevent user-defined types from including
their own <strong>Equals</strong> methods with different parameter lists. In fact,
the <strong>string</strong> class includes definitions of the following <strong>public</strong>
methods:</p><ul><li><strong>bool Equals(string s)</strong>: This method actually does the same thing
as the non-<strong>static</strong> <strong>Equals</strong> method defined in the <strong>object</strong>
class, but is slightly more efficient because less run-time type
checking needs to be done. This is the method that is called in the
computation of <code>comp3</code> in the above example.</li><li><strong>static bool Equals(string x, string y)</strong>: This method does the
same thing as the <strong>static Equals</strong> method defined in the <strong>object</strong>
class, but again is slightly more efficient because less run-time
type checking needs to be done.</li></ul><p>All of this can be rather daunting at first. Fortunately, in most cases
these comparisons end up working the way we expect them to. The main
thing we want to focus on here is how to define equality properly in a
user-defined type.</p><p><span id=operator-overloading></span> Let&rsquo;s start with the <code>==</code>
operator. This is one of several operators that may be defined within
class and structure definitions. If we are defining a class
called <strong>SomeType</strong>, we can include a definition of the <code>==</code> operator as
follows:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>bool</span> <span class=kd>operator</span> <span class=p>==(</span><span class=n>SomeType</span><span class=p>?</span> <span class=n>x</span><span class=p>,</span> <span class=n>SomeType</span><span class=p>?</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Definition of the behavior of ==</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If <strong>SomeType</strong> is a structure, the definition is similar, but we wouldn&rsquo;t define the parameters to be nullable. Note the resemblance to the definition of a <strong>static</strong> method. Even
though we define it using the syntax for a method definition, we still
use it as we typically use the <code>==</code> operator; e.g.,</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=p>==</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If <strong>SomeType</strong> is a class and <code>a</code> and <code>b</code> are both of either type <strong>SomeType</strong> or type <strong>SomeType?</strong>, the above definition will
be called using <code>a</code> as the parameter <code>x</code> and <code>b</code> as the parameter <code>y</code>.</p><p>Within the operator definition, if it is within a class definition, the
first thing we need to do is to handle the cases in which one or both
parameters are <strong>null</strong>. We don&rsquo;t need to do this for a structure
definition because value types can&rsquo;t be <strong>null</strong>, but if we omit this
part for a reference type, comparing a variable or expression of this
type to <strong>null</strong> will most likely result in a
<strong>NullReferenceException</strong>. We need to be a bit careful here, because if
we use <code>==</code> to compare one of the parameters to <strong>null</strong> it will be a
recursive call &mdash; infinite recursion, in fact. Furthermore, using
<code>x.Equals(null)</code> is always a bad idea, as if <code>x</code> does, in fact, equal
<strong>null</strong>, this will throw a <strong>NullReferenceException</strong>. We therefore
need to use one of the <strong>static</strong> methods, <strong>Equals</strong> or
<strong>ReferenceEquals</strong>:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>bool</span> <span class=kd>operator</span> <span class=p>==(</span><span class=n>SomeType</span><span class=p>?</span> <span class=n>x</span><span class=p>,</span> <span class=n>SomeType</span><span class=p>?</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>Equals</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=kc>null</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=p>(</span><span class=n>Equals</span><span class=p>(</span><span class=n>y</span><span class=p>,</span> <span class=kc>null</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>Equals</span><span class=p>(</span><span class=n>y</span><span class=p>,</span> <span class=kc>null</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Code to determine if x == y</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that because all three calls to <strong>Equals</strong> have <strong>null</strong> as a
parameter, these calls won&rsquo;t result in calling the <strong>Equals</strong> method
that we will override below.</p><p>Whenever we define the <code>==</code> operator, C# requires that we also define the
<code>!=</code> operator. In virtually all cases, what we want this operator to do
is to return the negation of what the <code>==</code> operator does; thus, if <strong>SomeType</strong> is a class, we define:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kt>bool</span> <span class=kd>operator</span> <span class=p>!=(</span><span class=n>SomeType</span><span class=p>?</span> <span class=n>x</span><span class=p>,</span> <span class=n>SomeType</span><span class=p>?</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>!(</span><span class=n>x</span> <span class=p>==</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If <strong>SomeType</strong> is a structure, we use the same definition, without making the parameters nullable.</p><p>We now turn to the (non-<strong>static</strong>) <strong>Equals</strong> method. This is defined
in the <strong>object</strong> class to be a <strong>virtual</strong> method, meaning that
sub-types are allowed to
<a href=/cis300/strings/stringbuilder-impl/#overriding>override</a> its
behavior. Because every type in C# is a subtype of <strong>object</strong>, this
method is present in every type, and it can be overridden by any class
or structure.</p><p>We override this method as follows:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>override</span> <span class=kt>bool</span> <span class=n>Equals</span><span class=p>(</span><span class=kt>object?</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Definition of the behavior of Equals</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>For the body of the method, we first need to take care of the fact that
the parameter is of type <strong>object</strong>; hence, it may not even have the
same type as what we want to compare it to. If this is the case, we need to return <strong>false</strong>. Otherwise, in order to ensure consistency
between this method and the <code>==</code> operator, we can do the actual comparison
using the <code>==</code> operator. If we are defining a class <strong>SomeType</strong>, we can accomplish all of this as follows:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>override</span> <span class=kt>bool</span> <span class=n>Equals</span><span class=p>(</span><span class=kt>object?</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>obj</span> <span class=k>as</span> <span class=n>SomeType</span> <span class=p>==</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The <code>as</code> keyword casts <code>obj</code> to <strong>SomeType</strong> if possible; however, if <code>obj</code> cannot be cast to <strong>SomeType</strong>, the <code>as</code> expression evaluates to <strong>null</strong> (or in general, the <a href=/cis300/stacks-queues/stack-impl/#default-value>default value</a> for <strong>SomeType</strong>). Because <strong>this</strong> cannot be <strong>null</strong>, <strong>false</strong> will always be returned if <code>obj</code> cannot be cast to <strong>SomeType</strong>.</p><p>If <strong>SomeType</strong> is a structure, the above won&rsquo;t work because <code>this</code> may be the default value for <strong>SomeType</strong>. In this case, we need somewhat more complicated code:</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>public</span> <span class=kd>override</span> <span class=kt>bool</span> <span class=n>Equals</span><span class=p>(</span><span class=kt>object?</span> <span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span> <span class=k>is</span> <span class=n>SomeType</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span> <span class=p>==</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This code uses the <code>is</code> keyword, which is similar to <code>as</code> in that it tries to cast <code>obj</code> to <strong>SomeType</strong>. However, if the cast is allowed, it places the result in the <strong>SomeType</strong> variable <code>x</code> and evaluates to <strong>true</strong>; otherwise, it assigns to <code>x</code> the default value of <strong>SomeType</strong> and evaluates to <strong>false</strong>.</p><p>The above definitions give a template for defining the <code>==</code> and <code>!=</code>
operators and the non-<strong>static Equals</strong> method for most types that we
would want to compare for equality. All we need to do to complete the definitions is to replace
the name <strong>SomeType</strong>, wherever it occurs, with the name of the type we
are defining, and to fill in the hole left in the definition of the <code>==</code>
operator. It is here where we actually define how the comparison is to
be made.</p><p>Suppose, for example, that we want to define a class to represent a Nim
board position (see the <a href=/cis300/hashing/memoization/>previous
section</a>). This class
will need to have two <strong>private</strong> fields: an <strong>int[ ]</strong> storing the
number of stones on each pile and an <strong>int[ ]</strong> storing the limit
for each pile. These two arrays should be non-<strong>null</strong> and have the same
length, but this should be enforced by the constructor. By default, two
instances of a class are considered to be equal (by either the <code>==</code>
operator or the non-<strong>static Equals</strong> method) if they are the same
object. This is too strong for our purposes; instead, two instances <code>x</code>
and <code>y</code> of the board position class should be considered equal if</p><ul><li>Their arrays giving the number of stones on each pile have the same
length; and</li><li>For each index <code>i</code> into the arrays giving the number of stones on
each pile, the elements at location <code>i</code> of these arrays have the
same value, and the elements at location <code>i</code> of the arrays giving
the limit for each pile have the same value.</li></ul><p>Code to make this determination and return the result can be inserted
into the above template defining of the <code>==</code> operator, and the other two
templates can be customized to refer to this type.</p><p>Any class that redefines equality should also redefine the hash code
computation to be consistent with the equality definition. We will show
how to do this in the next section.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1768892168></script><script src=/cis300/js/clipboard/clipboard.min.js?1768892168 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1768892168 defer></script><script src=/cis300/js/theme.min.js?1768892168 defer></script></div><script src=/cis300/js/tele-scroll.min.js?1768892168 defer></script></body></html>