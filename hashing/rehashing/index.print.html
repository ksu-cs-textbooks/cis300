<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let’s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rehashing :: Data Structures in C#"><meta name=twitter:description content="Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let’s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/hashing/rehashing/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Rehashing :: Data Structures in C#"><meta property="og:description" content="Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let’s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Hash Tables"><meta property="article:modified_time" content="2023-06-07T11:36:57-05:00"><meta itemprop=name content="Rehashing :: Data Structures in C#"><meta itemprop=description content="Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let’s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k."><meta itemprop=dateModified content="2023-06-07T11:36:57-05:00"><meta itemprop=wordCount content="1393"><title>Rehashing :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/hashing/rehashing/ rel=canonical type=text/html title="Rehashing :: Data Structures in C#"><link href=/cis300/hashing/rehashing/index.xml rel=alternate type=application/rss+xml title="Rehashing :: Data Structures in C#"><link href=/cis300/hashing/rehashing/tele.html rel=alternate type=text/html title="Rehashing :: Data Structures in C#"><link href=/cis300/hashing/rehashing/embed.html rel=alternate type=text/html title="Rehashing :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1759520014 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1759520014 defer></script><script src=/cis300/js/search-lunr.min.js?1759520014 defer></script><script src=/cis300/js/search.min.js?1759520014 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1759520014"</script><script src=/cis300/js/lunr/lunr.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1759520014 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1759520014 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1759520014 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1759520014 rel=stylesheet><link href=/cis300/css/theme.min.css?1759520014 rel=stylesheet><link href=/cis300/css/format-print.min.css?1759520014 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/hashing/rehashing/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1759520014 rel=stylesheet></head><body class="mobile-support embed print" data-url=/cis300/hashing/rehashing/><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable hashing" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=rehashing>Rehashing</h1></div><h2 id=rehashing>Rehashing</h2><p>In this section, we will show how to improve the performance of a hash
table by adjusting the size of the array. In order to see how the array
size impacts the performance, let&rsquo;s suppose we are using an array with
<span class="math align-center">$ m $</span> locations, and that we are storing <span class="math align-center">$ n $</span> keys in the hash table. In
what follows, we will analyze the number of keys we will need to examine
while searching for a particular key, <code>k</code>.</p><p>In the worst case, no matter how large the array is, it is possible that
all of the keys map to the same array location, and therefore all end up
in one long linked list. In such a case, we will need to examine all of
the keys whenever we are looking for the last one in this list. However,
the worst case is too pessimistic &mdash; if the hash function is implemented
properly, it is reasonable to expect that something approaching a
uniform random distribution will occur. We will therefore consider the
number of keys we would expect to examine, assuming a uniform random
distribution of keys throughout the table.</p><p>We&rsquo;ll first consider the case in which <code>k</code> is not in the hash table. In
this case, we will need to examine all of the keys in the linked list at
the array location where <code>k</code> belongs. Because each of the <span class="math align-center">$ n $</span> keys is
equally likely to map to each of the <span class="math align-center">$ m $</span> array locations, we would
expect, on average, <span class="math align-center">$ n / m $</span> keys to be mapped to the location
where <code>k</code> belongs. Hence, in this case, we would expect to examine
<span class="math align-center">$ n / m $</span> keys, on average.</p><p>Now let&rsquo;s consider the case in which <code>k</code> is in the hash table. In this
case, we will examine the key <code>k</code>, plus all the keys that precede <code>k</code> in
its linked list. The number of keys preceding <code>k</code> cannot be more than
the total number of keys other than <code>k</code> in that linked list. Again,
because each of the <span class="math align-center">$ n - 1 $</span> keys other than <code>k</code> is equally likely
to map to each of the <span class="math align-center">$ m $</span> array locations, we would expect, on average,
<span class="math align-center">$ (n - 1) / m $</span> keys other than <code>k</code> to be in the same linked
list as <code>k</code>. Thus, we can expect, on average, to examine no more than
<span class="math align-center">$ 1 +  (n - 1) / m $</span> keys when looking for a key
that is present.</p><p>Notice that both of the values derived above decrease as <span class="math align-center">$ m $</span> increases.
Specifically, if <span class="math align-center">$ m \geq n $</span>, the expected number of examined
keys on a failed lookup is no more than <span class="math align-center">$ 1 $</span>, and the expected number of
examined keys on a successful lookup is less than <span class="math align-center">$ 2 $</span>. We can therefore
expect to achieve very good performance if we keep the number of array
locations at least as large as the number of keys.</p><p>We have already seen (e.g., in &ldquo;<a href=/cis300/strings/stringbuilder-impl/>Implementation of
<strong>StringBuilder</strong>s</a>&rdquo;)
how we can keep an array large enough by doubling its size whenever we
need to. However, a hash table presents two unique challenges for this
technique. First, as we observed in <a href=/cis300/hashing/simple/>the previous
section</a>, we
are most likely to get good performance from a hash table if the number
of array locations is a prime number. However, doubling a prime number
will never give us a prime number. The other challenge is due to the
fact that when we change the size of the array, we consequently change
the hash function, as the hash function uses the array size. As a
result, the keys will need to go to different array locations in the new
array.</p><p>In order to tackle the first challenge, recall that we presented an
algorithm for finding all prime numbers less than a given <code>n</code> in
&ldquo;<a href=/cis300/linked-lists/sieve-eratosthenes/>Finding Prime
Numbers</a>&rdquo;;
however, this is a rather expensive way to find a prime number of an
appropriate size. While there are more efficient algorithms, we really
don&rsquo;t need one. Suppose we start with an array size of <span class="math align-center">$ 5 $</span> (there may be
applications using many small hash tables &mdash; the .NET implementation
starts with an array size of <span style=white-space:nowrap><span class="math align-center">$ 3 $</span>).</span> <span class="math align-center">$ 5 $</span> is larger than
<span style=white-space:nowrap><span class="math align-center">$ 2^2 = 4 $</span>.</span> If we double this value <span class="math align-center">$ 28 $</span> times, we
reach a value larger than <span style=white-space:nowrap><span class="math align-center">$ 2^{30} $</span>,</span> which is larger than <span class="math align-center">$ 1 $</span>
billion. More importantly, this value is large enough that we can&rsquo;t
double it again, as an array in C# must contain fewer than
<span class="math align-center">$ 2^{31} $</span> locations. Hence, we need no more than <span class="math align-center">$ 29 $</span> different array
sizes. We can pre-compute these and hard-code them into our
implementation; for example,</p><div class=highlight dir=auto><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>_tableSizes</span> <span class=p>=</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=m>5</span><span class=p>,</span> <span class=m>11</span><span class=p>,</span> <span class=m>23</span><span class=p>,</span> <span class=m>47</span><span class=p>,</span> <span class=m>97</span><span class=p>,</span> <span class=m>197</span><span class=p>,</span> <span class=m>397</span><span class=p>,</span> <span class=m>797</span><span class=p>,</span> <span class=m>1597</span><span class=p>,</span> <span class=m>3203</span><span class=p>,</span> <span class=m>6421</span><span class=p>,</span> <span class=m>12853</span><span class=p>,</span> <span class=m>25717</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=m>51437</span><span class=p>,</span> <span class=m>102877</span><span class=p>,</span> <span class=m>205759</span><span class=p>,</span> <span class=m>411527</span><span class=p>,</span> <span class=m>823117</span><span class=p>,</span> <span class=m>1646237</span><span class=p>,</span> <span class=m>3292489</span><span class=p>,</span> <span class=m>6584983</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=m>13169977</span><span class=p>,</span> <span class=m>26339969</span><span class=p>,</span> <span class=m>52679969</span><span class=p>,</span> <span class=m>105359939</span><span class=p>,</span> <span class=m>210719881</span><span class=p>,</span> <span class=m>421439783</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=m>842879579</span><span class=p>,</span> <span class=m>1685759167</span> 
</span></span><span class=line><span class=cl><span class=p>};</span> </span></span></code></pre></div><p>Each of the values in the above array is a prime number, and each one
after the first is slightly more than twice its predecessor. In order to
make use of these values, we need a <strong>private</strong> field to store the index
at which the current table size is stored in this array. We also need to
keep track of the number of keys currently stored. As this information
is useful to the user, a <strong>public int Count</strong> property would be
appropriate. It can use the default implementation with a <strong>get</strong>
accessor and a <strong>private set</strong> accessor.</p><p>One important difference between the reason for rehashing and the reason
for creating a larger array for an implementation of a
<a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong></a>,
<a href=/cis300/stacks-queues/stack-impl/>stack</a>, or
<a href=/cis300/stacks-queues/queue-impl/>queue</a> is that rehashing
is done simply for performance reasons - there is always room to put a
new key and value into a hash table unless we have run out of memory.
For this reason, it makes sense to handle rehashing <em>after</em> we have
added the new key and value. This results in one extra linked-list
insertion (i.e., updating two references) each time we rehash, but it
simplifies the coding somewhat. Because rehashing is rarely done, this
overhead is minimal, and seems to be a reasonable price to pay for
simpler code.</p><p>Once a new key and value have been added, we first need to update the
<strong>Count</strong>. We then need to check to see whether this number exceeds the
current array size. As we do this, we should also make sure that the
array size we are using is not the last array size in <code>_tableSizes</code>,
because if it is, we can&rsquo;t rehash. If both of these conditions hold, we
need to rehash.</p><p>To begin rehashing, we copy the reference to the table into a local
variable and increment the field giving our current index into
<code>_tableSizes</code>. We then construct for the table field a new array whose
size is given by the value at the new current index into <code>_tableSizes</code>.
Note that it is important that the local variable is used to refer to
the old table, and that the field is used to refer to the new table, as
the hash function uses the field to obtain the array size.</p><p>We then need to move all keys and values from the old table to the new
one. As we do this, we will need to re-compute the hash function for each
key, as the hash function has now changed. We therefore need two nested
loops. The outer loop iterates through the locations in the old table,
and the inner loop iterates through the linked list at that location. On each iteration of the inner loop:</p><ol><li>Use a local variable to save another reference to the current cell in the
linked list at the current table location.</li><li>Advance to the next cell in the list.</li><li>Using the hash function, compute the new array location of the key
in the cell that was saved in step 1.</li><li>Insert this cell into the beginning of the linked list at the new
array location in the new table.</li></ol><details open class="box cstyle notices warning"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-exclamation-triangle"></i>
Warning</summary><div class=box-content><p>It is important to do step 2 above prior to step 4, as inserting a cell into a new list will lose the reference to the next cell in the old list.</p></div></details><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1759520014></script><script src=/cis300/js/clipboard/clipboard.min.js?1759520014 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1759520014 defer></script><script src=/cis300/js/theme.min.js?1759520014 defer></script><script src=/cis300/js/embed-iframe.min.js?1759520014 defer></script></body></html>