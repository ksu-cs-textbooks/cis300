




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.101.0">
    <meta name="generator" content="Relearn 5.2.0+tip">
    <meta name="robots" content="noindex, nofollow, noarchive, noimageindex">
    <meta name="description" content="K-State CIS 300: Data Structures">
    <meta name="author" content="Rod Howell and Josh Weese">
    <title>Rehashing :: Data Structures in C#</title>
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1685652312" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fontawesome-all.min.css?1685652312" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1685652312" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/featherlight.min.css?1685652312" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1685652312" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/auto-complete.css?1685652312" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/perfect-scrollbar.min.css?1685652312" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/nucleus.css?1685652312" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1685652312" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis300/css/fonts.css?1685652312" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme.css?1685652312" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/theme-light-theme.css?1685652312" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/ie.css?1685652312" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/variant.css?1685652312" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/print.css?1685652312" rel="stylesheet" media="print">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/variant.js?1685652312"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      var index_url="https://ksu-cs-textbooks.github.io/cis300/index.json";
      var root_url="https://ksu-cs-textbooks.github.io/cis300/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis300/';
      window.variants && variants.init( [ 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis300/css/custom.css?1685652312" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/jquery.min.js?1685652312" defer></script>

  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis300/hashing/rehashing/embed.html">
    <div id="body" class="default-animation" data-iframe-height="yes">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1" data-iframe-height="yes" style="padding-bottom: 0px">
        <div class="flex-block-wrapper" data-iframe-height="yes">
          <div id="head-tags">
          </div>
          <article class="default">
    
    
    
<h2 id="rehashing">Rehashing</h2>
<p>In this section, we will show how to improve the performance of a hash
table by adjusting the size of the array. In order to see how the array
size impacts the performance, let&rsquo;s suppose we are using an array with

<span class="math align-center">$ m $</span> locations, and that we are storing 
<span class="math align-center">$ n $</span> keys in the hash table. In
what follows, we will analyze the number of keys we will need to examine
while searching for a particular key, <code>k</code>.</p>
<p>In the worst case, no matter how large the array is, it is possible that
all of the keys map to the same array location, and therefore all end up
in one long linked list. In such a case, we will need to examine all of
the keys whenever we are looking for the last one in this list. However,
the worst case is too pessimistic &mdash; if the hash function is implemented
properly, it is reasonable to expect that something approaching a
uniform random distribution will occur. We will therefore consider the
number of keys we would expect to examine, assuming a uniform random
distribution of keys throughout the table.</p>
<p>We&rsquo;ll first consider the case in which <code>k</code> is not in the hash table. In
this case, we will need to examine all of the keys in the linked list at
the array location where <code>k</code> belongs. Because each of the 
<span class="math align-center">$ n $</span> keys is
equally likely to map to each of the 
<span class="math align-center">$ m $</span> array locations, we would
expect, on average, 
<span class="math align-center">$ n / m $</span> keys to be mapped to the location
where <code>k</code> belongs. Hence, in this case, we would expect to examine

<span class="math align-center">$ n / m $</span> keys, on average.</p>
<p>Now let&rsquo;s consider the case in which <code>k</code> is in the hash table. In this
case, we will examine the key <code>k</code>, plus all the keys that precede <code>k</code> in
its linked list. The number of keys preceding <code>k</code> cannot be more than
the total number of keys other than <code>k</code> in that linked list. Again,
because each of the 
<span class="math align-center">$ n - 1 $</span> keys other than <code>k</code> is equally likely
to map to each of the 
<span class="math align-center">$ m $</span> array locations, we would expect, on average,

<span class="math align-center">$ (n - 1) / m $</span> keys other than <code>k</code> to be in the same linked
list as <code>k</code>. Thus, we can expect, on average, to examine no more than

<span class="math align-center">$ 1 +  (n - 1) / m $</span> keys when looking for a key
that is present.</p>
<p>Notice that both of the values derived above decrease as <em>m</em> increases.
Specifically, if 
<span class="math align-center">$ m \geq n $</span>, the expected number of examined
keys on a failed lookup is no more than 
<span class="math align-center">$ 1 $</span>, and the expected number of
examined keys on a successful lookup is less than 
<span class="math align-center">$ 2 $</span>. We can therefore
expect to achieve very good performance if we keep the number of array
locations at least as large as the number of keys.</p>
<p>We have already seen (e.g., in &ldquo;

<a href="https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilder-impl">Implementation of
<strong>StringBuilder</strong>s</a>&rdquo;)
how we can keep an array large enough by doubling its size whenever we
need to. However, a hash table presents two unique challenges for this
technique. First, as we observed in 

<a href="https://ksu-cs-textbooks.github.io/cis300/hashing/simple">the previous
section</a>, we
are most likely to get good performance from a hash table if the number
of array locations is a prime number. However, doubling a prime number
will never give us a prime number. The other challenge is due to the
fact that when we change the size of the array, we consequently change
the hash function, as the hash function uses the array size. As a
result, the keys will need to go to different array locations in the new
array.</p>
<p>In order to tackle the first challenge, recall that we presented an
algorithm for finding all prime numbers less than a given <code>n</code> in
&ldquo;

<a href="https://ksu-cs-textbooks.github.io/cis300/linked-lists/sieve-eratosthenes">Finding Prime
Numbers</a>&rdquo;;
however, this is a rather expensive way to find a prime number of an
appropriate size. While there are more efficient algorithms, we really
don&rsquo;t need one. Suppose we start with an array size of 
<span class="math align-center">$ 5 $</span> (there may be
applications using many small hash tables &mdash; the .NET implementation
starts with an array size of <span style="white-space:nowrap">
<span class="math align-center">$ 3 $</span>).</span> 
<span class="math align-center">$ 5 $</span> is larger than
<span style="white-space:nowrap">
<span class="math align-center">$ 2^2 = 4 $</span>.</span> If we double this value 
<span class="math align-center">$ 28 $</span> times, we
reach a value larger than <span style="white-space:nowrap">
<span class="math align-center">$ 2^{30} $</span>,</span> which is larger than 
<span class="math align-center">$ 1 $</span>
billion. More importantly, this value is large enough that we can&rsquo;t
double it again, as an array in C# must contain fewer than

<span class="math align-center">$ 2^{31} $</span> locations. Hence, we need no more than 
<span class="math align-center">$ 29 $</span> different array
sizes. We can pre-compute these and hard-code them into our
implementation; for example,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span>[] _tableSizes = 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">47</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">197</span>, <span style="color:#ae81ff">397</span>, <span style="color:#ae81ff">797</span>, <span style="color:#ae81ff">1597</span>, <span style="color:#ae81ff">3203</span>, <span style="color:#ae81ff">6421</span>, <span style="color:#ae81ff">12853</span>, <span style="color:#ae81ff">25717</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">51437</span>, <span style="color:#ae81ff">102877</span>, <span style="color:#ae81ff">205759</span>, <span style="color:#ae81ff">411527</span>, <span style="color:#ae81ff">823117</span>, <span style="color:#ae81ff">1646237</span>, <span style="color:#ae81ff">3292489</span>, <span style="color:#ae81ff">6584983</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">13169977</span>, <span style="color:#ae81ff">26339969</span>, <span style="color:#ae81ff">52679969</span>, <span style="color:#ae81ff">105359939</span>, <span style="color:#ae81ff">210719881</span>, <span style="color:#ae81ff">421439783</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">842879579</span>, <span style="color:#ae81ff">1685759167</span> 
</span></span><span style="display:flex;"><span>}; 
</span></span></code></pre></div><p>Each of the values in the above array is a prime number, and each one
after the first is slightly more than twice its predecessor. In order to
make use of these values, we need a <strong>private</strong> field to store the index
at which the current table size is stored in this array. We also need to
keep track of the number of keys currently stored. As this information
is useful to the user, a <strong>public int Count</strong> property would be
appropriate. It can use the default implementation with a <strong>get</strong>
accessor and a <strong>private set</strong> accessor.</p>
<p>One important difference between the reason for rehashing and the reason
for creating a larger array for an implementation of a


<a href="https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilder-impl"><strong>StringBuilder</strong></a>,


<a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl">stack</a>, or


<a href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queue-impl">queue</a> is that rehashing
is done simply for performance reasons - there is always room to put a
new key and value into a hash table unless we have run out of memory.
For this reason, it makes sense to handle rehashing <em>after</em> we have
added the new key and value. This results in one extra linked-list
insertion (i.e., updating two references) each time we rehash, but it
simplifies the coding somewhat. Because rehashing is rarely done, this
overhead is minimal, and seems to be a reasonable price to pay for
simpler code.</p>
<p>Once a new key and value have been added, we first need to update the
<strong>Count</strong>. We then need to check to see whether this number exceeds the
current array size. As we do this, we should also make sure that the
array size we are using is not the last array size in <code>_tableSizes</code>,
because if it is, we can&rsquo;t rehash. If both of these conditions hold, we
need to rehash.</p>
<p>To begin rehashing, we copy the reference to the table into a local
variable and increment the field giving our current index into
<code>_tableSizes</code>. We then construct for the table field a new array whose
size is given by the value at the new current index into <code>_tableSizes</code>.
Note that it is important that the local variable is used to refer to
the old table, and that the field is used to refer to the new table, as
the hash function uses the field to obtain the array size.</p>
<p>We then need to move all keys and values from the old table to the new
one. As we do this, we will need to re-compute the hash function for each
key, as the hash function has now changed. We therefore need two nested
loops. The outer loop iterates through the locations in the old table,
and the inner loop iterates as long as the linked list at the current
table location is non-empty. On each iteration of the inner loop:</p>
<ul>
<li>Use a local variable to save a reference to the first cell in the
linked list at the current table location.</li>
<li>Remove this cell from this linked list.</li>
<li>Using the hash function, compute the new array location of the key
in this cell.</li>
<li>Insert this cell into the beginning of the linked list at the new
array location in the new table.</li>
</ul>

            <footer class="footline">
            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/clipboard.min.js?1685652312" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/featherlight.min.js?1685652312" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://ksu-cs-textbooks.github.io/cis300/js/mathjax/tex-mml-chtml.js?1685652312"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/theme.js?1685652312" defer></script>
    
    <script src="https://ksu-cs-textbooks.github.io/cis300/js/embed-iframe.js?1685652312 defer"></script>
    <script src="https://cdn.jsdelivr.net/npm/iframe-resizer@4.3.2/js/iframeResizer.contentWindow.min.js"></script>
    
  </body>
</html>
