<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hash Tables :: Data Structures in C#</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/</link><description>Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://textbooks.cs.ksu.edu/cis300/hashing/index.xml" rel="self" type="application/rss+xml"/><item><title>A Simple Hash Table Implementation</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/simple/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/simple/</guid><description>A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts.</description></item><item><title>Rehashing</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/rehashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/rehashing/</guid><description>Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let’s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k.</description></item><item><title>Memoization</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/memoization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/memoization/</guid><description>Memoization We we will now present an example of a common technique involving dictionaries. Consider the following variation of the 2-player game, Nim. The board consists of a number of stones arranged into several piles. Associated with each nonempty pile is a limit, which is a positive integer no greater than the number of stones on that pile (the limit for an empty pile is always 0). Players alternate taking stones according to the following rules:</description></item><item><title>Equality in C#</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/equality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/equality/</guid><description>Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality.</description></item><item><title>Hash Codes</title><link>https://textbooks.cs.ksu.edu/cis300/hashing/hash-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://textbooks.cs.ksu.edu/cis300/hashing/hash-functions/</guid><description>Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type’s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary&lt;TKey, TValue> class to be able to find a given key that it has stored.</description></item></channel></rss>