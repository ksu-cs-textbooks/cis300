




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hash Tables on Data Structures in C#</title>
    <link>https://ksu-cs-textbooks.github.io/cis300/hashing/index.html</link>
    <description>Recent content in Hash Tables on Data Structures in C#</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://ksu-cs-textbooks.github.io/cis300/hashing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A Simple Hash Table Implementation</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/hashing/simple/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/hashing/simple/index.html</guid>
      <description>A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts.</description>
    </item>
    <item>
      <title>Rehashing</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/hashing/rehashing/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/hashing/rehashing/index.html</guid>
      <description>Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let&amp;rsquo;s suppose we are using an array with $ m $ locations, and that we are storing $ n $ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k.</description>
    </item>
    <item>
      <title>Memoization</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/hashing/memoization/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/hashing/memoization/index.html</guid>
      <description>Memoization We we will now present an example of a common technique involving dictionaries. Consider the following variation of the 2-player game, Nim. The board consists of a number of stones arranged into several piles. Associated with each nonempty pile is a limit, which is a positive integer no greater than the number of stones on that pile (the limit for an empty pile is always 0). Players alternate taking stones according to the following rules:</description>
    </item>
    <item>
      <title>Equality in C#</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/hashing/equality/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/hashing/equality/index.html</guid>
      <description>Equality in C# Continuing our discussion from the previous section , we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality.</description>
    </item>
    <item>
      <title>Hash Codes</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/hashing/hash-functions/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/hashing/hash-functions/index.html</guid>
      <description>Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type&amp;rsquo;s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary&amp;lt;TKey,Â TValue&amp;gt; class to be able to find a given key that it has stored.</description>
    </item>
  </channel>
</rss>