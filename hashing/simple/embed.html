<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Simple Hash Table Implementation :: Data Structures in C#"><meta name=twitter:description content="A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/hashing/simple/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="A Simple Hash Table Implementation :: Data Structures in C#"><meta property="og:description" content="A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Hash Tables"><meta property="article:modified_time" content="2023-06-07T11:36:57-05:00"><meta itemprop=name content="A Simple Hash Table Implementation :: Data Structures in C#"><meta itemprop=description content="A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.
At the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts."><meta itemprop=dateModified content="2023-06-07T11:36:57-05:00"><meta itemprop=wordCount content="872"><title>A Simple Hash Table Implementation :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723840623 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723840623 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723840623 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723840623 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723840623 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723840623 rel=stylesheet><link href=/cis300/css/fonts.css?1723840623 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723840623 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723840623 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1723840623 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1723840623 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723840623 rel=stylesheet><link href=/cis300/css/print.css?1723840623 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723840623 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/hashing/simple/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=a-simple-hash-table-implementation>A Simple Hash Table Implementation</h2><p>In this section, we will look at a simple hash table implementation
using a fixed-length table. In subsequent sections, we will consider how
to adjust the table size for better performance, as well as how to
implement enumerators for iterating through the keys and/or values.</p><p>At the core of our implementation is the computation of the hash
function. Recall that the implementation of the hash function
computation is divided into two parts. The first part of the computation
is implemented within the definition of the key type via its
<strong>GetHashCode</strong> method. We will discuss this part of the computation in
the section, <a href=/cis300/hashing/hash-functions/>&ldquo;Hash
Codes&rdquo;</a>. Here, we will
focus on the second step, converting the <strong>int</strong> hash code returned by
the key&rsquo;s <strong>GetHashCode</strong> method to a table location.</p><p>One common technique, which is used in the .NET implementation of the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0" rel=external target=_blank><strong>Dictionary&lt;TKey, TValue></strong></a>
class, is called the <em>division method</em>. This technique consists of the
following:</p><ol><li>Reset the sign bit of the hash code to <code>0</code>.</li><li>Compute the remainder of dividing this value by the length of the
table.</li></ol><p>If <code>p</code> is a nonnegative <strong>int</strong> and <code>q</code> is a positive <strong>int</strong>, then
<code>p % q</code> gives a nonnegative value less than <code>q</code>; hence, if <code>q</code>
is the table length, <code>p % q</code> is a location within the table.
Furthermore, this calculation often does a good job of distributing hash
code values among the different table locations, but this depends on how
the hash codes were computed and what the length of the table is.</p><p>For example, suppose we use a size
<span class="math align-center">$ 2^k $</span> for some positive
integer <span style=white-space:nowrap><span class="math align-center">$ k $</span>.</span> In this case, the above computation can be simplified, as
the values formed by
<span class="math align-center">$ k $</span> bits are
<span class="math align-center">$ 0 $</span> through <span style=white-space:nowrap><span class="math align-center">$ 2^k - 1 $</span>,</span>
or all of the locations in the table. We can therefore simply use the
low-order
<span class="math align-center">$ k $</span> bits of the hash code as the table location. However, it
turns out that using the division method when the table size is a power
of
<span class="math align-center">$ 2 $</span> can lead to poor key distribution for some common hash code
schemes. To avoid these problems, a prime number should be used as the
table length. When a prime number is used, the division method tends to
result in a good distribution of the keys.</p><p>The reason we need to reset the sign bit of the hash code to <code>0</code> is to
ensure that the first operand to the <code>%</code> operator is nonnegative, and
hence that the result is nonnegative. Furthermore, simply taking the
absolute value of the hash code won&rsquo;t always work because
<span class="math align-center">$ -2^{31} $</span> can be stored in an <strong>int</strong>, but
<span class="math align-center">$ 2^{31} $</span> is too
large. Resetting the sign bit to <code>0</code> is a quick way to ensure we have a
nonnegative value without losing any additional information.</p><p>We can do this using a bitwise AND operator, denoted by a single
ampersand (<code>&</code>). This operator operates on the individual bits of an
integer type such as <strong>int</strong>. The logical AND of two <code>1</code> bits is <code>1</code>; all
other combinations result in <code>0</code>. Thus, if we want to set a bit to <code>0</code>, we
AND it with <code>0</code>, and ANDing a bit with <code>1</code> will leave it unchanged. The sign
bit is the high-order bit; hence, we want to AND the hash code with an
<strong>int</strong> whose first bit is <code>0</code> and whose remaining bits are <code>1</code>. The easiest
way to write this value is using hexadecimal notation, as each hex digit
corresponds to exactly four bits. We begin writing a hexadecimal value
with <code>0x</code>. The first four bits need to be one <code>0</code>, followed by three <code>1</code>s.
These three <code>1</code> are in the <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>,</span> <span style=white-space:nowrap><span class="math align-center">$ 2 $</span>,</span> and
<span class="math align-center">$ 4 $</span> bit positions of the first hex digit; hence, the value of
this hex digit should be <code>7</code>. We then want seven more hex digits, each
containing four <code>1</code>s. An additional <code>1</code> in the
<span class="math align-center">$ 8 $</span> position gives us a sum of
<span style=white-space:nowrap><span class="math align-center">$ 15 $</span>,</span> which is denoted as either <code>f</code> or <code>F</code> in hex. We can therefore reset
the sign bit of an <strong>int</strong> <code>i</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=n>i</span> <span class=p>=</span> <span class=n>i</span> <span class=p>&amp;</span> <span class=m>0x7fffffff</span><span class=p>;</span></span></span></code></pre></div><p>or:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=n>i</span> <span class=p>&amp;=</span> <span class=m>0x7fffffff</span><span class=p>;</span></span></span></code></pre></div><p>Now let&rsquo;s consider how we would look up a key. First, we need to obtain
the key&rsquo;s hash code by calling its <strong>GetHashCode</strong> method. From the hash
code, we use the division method to compute the table location where it
belongs. We then search the linked list for that key.</p><p>Adding a key and a value is done similarly. We first look for the key as
described above. If we find it, we either replace its <strong>KeyValuePair</strong>
with a new one containing the new value, or we throw an exception,
depending on how we want this method to behave. If we don&rsquo;t find it, we
add a new cell containing the given key and value to the beginning of
the list we searched.</p><p>Note that looking up a key or adding a key and a value as described
above can be implemented using either methods or indexers (.NET
uses both). See the section,
<a href=/cis300/appendix/syntax/indexers/>&ldquo;Indexers&rdquo;</a> for details on
how to implement an indexer.</p><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1723840623 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723840623 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1723840623></script><script src=/cis300/js/theme.js?1723840623 defer></script><script src=/cis300/js/embed-iframe.js?1723840623 defer></script></body></html>