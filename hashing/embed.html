<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .NET’s Dictionary<TKey, TValue> class."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hash Tables :: Data Structures in C#"><meta name=twitter:description content="Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .NET’s Dictionary<TKey, TValue> class."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/hashing/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Hash Tables :: Data Structures in C#"><meta property="og:description" content="Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .NET’s Dictionary<TKey, TValue> class."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta itemprop=name content="Hash Tables :: Data Structures in C#"><meta itemprop=description content="Hash Tables Throughout our discussion of dictionary implementations over the last two chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result — that we can achieve better performance if we don’t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in .NET’s Dictionary<TKey, TValue> class."><meta itemprop=dateModified content="2023-06-07T11:36:57-05:00"><meta itemprop=wordCount content="586"><title>Hash Tables :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/hashing/ rel=canonical type=text/html title="Hash Tables :: Data Structures in C#"><link href=/cis300/hashing/index.xml rel=alternate type=application/rss+xml title="Hash Tables :: Data Structures in C#"><link href=/cis300/hashing/index.print.html rel=alternate type=text/html title="Hash Tables :: Data Structures in C#"><link href=/cis300/hashing/tele.html rel=alternate type=text/html title="Hash Tables :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1768892168 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1768892168 defer></script><script src=/cis300/js/search-lunr.min.js?1768892168 defer></script><script src=/cis300/js/search.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1768892168"</script><script src=/cis300/js/lunr/lunr.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1768892168 rel=stylesheet><link href=/cis300/css/theme.min.css?1768892168 rel=stylesheet><link href=/cis300/css/format-html.min.css?1768892168 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/hashing/",window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1768892168 rel=stylesheet></head><body class="mobile-support embed html" data-url=/cis300/hashing/><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable hashing" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=hash-tables>Hash Tables</h1></div><h2 id=hash-tables>Hash Tables</h2><p>Throughout our discussion of dictionary implementations over the last two chapters,
we have taken advantage of the fact that the keys were sorted when
looking up specific keys. In this chapter, we examine a rather
surprising result &mdash; that we can achieve better performance if we don&rsquo;t
have to keep the keys in any particular order (i.e., so that we can
process them in that order). The technique uses a data structure known
as a <em>hash table</em>, which is the underlying data structure in .NET&rsquo;s
<strong>Dictionary&lt;TKey, TValue></strong> class.</p><p>A hash table is typically organized as an array of linked lists. The
individual cells in the linked lists each store a key and a value.
Associated with this structure is a <em>hash function</em>, which takes a key
as its parameter and computes an array location. This array location
contains a reference to the beginning of the linked list that will
contain the given key if it is in the hash table. Thus, in order to find
a key in a hash table, we first apply the hash function to the key, then
search the linked list at the location computed by the hash function.
The following picture illustrates the layout of a hash table in which
the keys are <strong>string</strong>s and the values are <strong>int</strong>s, and the hash
function is denoted by <em>h</em>:</p><p><a href=#R-image-a16f56a315c63c75648f06a26d80f4a8 class=lightbox-link><img alt="A hash table." class="border lazy lightbox figure-image" loading=lazy src=/cis300/hashing/hash-table.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a16f56a315c63c75648f06a26d80f4a8><img alt="A hash table." class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/hashing/hash-table.jpg></a></p><details open class="box cstyle notices note"><summary class=box-label tabindex=-1><i class="fa-fw fas fa-exclamation-circle"></i>
Note</summary><div class=box-content><p>In order to avoid cluttering the above picture, the <strong>string</strong>s are
shown inside the linked list cells, even though <strong>string</strong> is a
reference type.</p></div></details><p>In order to achieve good performance, we want all of the linked lists to
be short. This requires, among other things, that we make the array
sufficiently large. We therefore increase the size of the array as the
number of elements increases.</p><p>The above overview of hash tables reveals one of the challenges in using
a dictionary implemented using a hash table. Specifically, whenever we
define a new key type, this type is unknown to the dictionary
implementation. How then can it compute a hash function on an instance
of this type? The short answer to this question is that the hash
function is divided into two parts. The first part of the hash function
is implemented within the key type itself, where code can access the
implementation details of the key. Specifically, every type in C# has a
<strong>public</strong>
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-6.0#system-object-gethashcode" rel=external target=_blank><strong>GetHashCode</strong></a>
method, which takes no parameters and returns an <strong>int</strong>. Any new type
that redefines how its elements are compared for equality should
<em>override</em> this method so as to ensure that it returns the same value
whenever it is called on equal instances. The second part of the hash
function is implemented within the dictionary itself. This part takes
the <strong>int</strong> from the first part and uses it to compute an array
location. We will discuss both parts of the hash function computation in
more detail in later sections.</p><p>In the next few sections, we will present the implementation details of
a hash table. We will then discuss how a dictionary can facilitate a
technique called <em>memoization</em>, which can be used to improve
dramatically the performance of certain algorithms. This discussion will
provide a motivation for defining a new key type. We then take a close
look at how equality is handled in C#, as we will need to be able to
implement equality tests if we are to define new types that can be used
as keys. We then complete the discussion on defining new key types by
illustrating how the <strong>GetHashCode</strong> method can be implemented.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1768892168></script><script src=/cis300/js/clipboard/clipboard.min.js?1768892168 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1768892168 defer></script><script src=/cis300/js/theme.min.js?1768892168 defer></script><script src=/cis300/js/embed-iframe.min.js?1768892168 defer></script></body></html>