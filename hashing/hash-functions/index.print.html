<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type’s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary<TKey, TValue> class to be able to find a given key that it has stored. On the other hand, because the number of possible keys is usually larger than the number of possible hash codes, unequal keys are also allowed to have the same hash code. The computation should be done quickly. Hash codes should be uniformly distributed even if the keys are not. The last goal above may seem rather daunting, particularly in light of our desire for a quick computation. In fact, it is impossible to guarantee in general — provided there are more than $ 2^{32}(k - 1) $ possible keys from which to choose, no matter how the hash code computation is implemented, we can always find at least $ k $ keys with the same hash code. However, this is a problem that has been studied a great deal, and several techniques have been developed that are effective in practice. We will caution, however, that not every technique that looks like it should be effective actually is in practice. It is best to use techniques that have been demonstrated to be effective in a wide variety of applications. We will examine one of these techniques in what follows."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hash Codes :: Data Structures in C#"><meta name=twitter:description content="Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type’s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary<TKey, TValue> class to be able to find a given key that it has stored. On the other hand, because the number of possible keys is usually larger than the number of possible hash codes, unequal keys are also allowed to have the same hash code. The computation should be done quickly. Hash codes should be uniformly distributed even if the keys are not. The last goal above may seem rather daunting, particularly in light of our desire for a quick computation. In fact, it is impossible to guarantee in general — provided there are more than $ 2^{32}(k - 1) $ possible keys from which to choose, no matter how the hash code computation is implemented, we can always find at least $ k $ keys with the same hash code. However, this is a problem that has been studied a great deal, and several techniques have been developed that are effective in practice. We will caution, however, that not every technique that looks like it should be effective actually is in practice. It is best to use techniques that have been demonstrated to be effective in a wide variety of applications. We will examine one of these techniques in what follows."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/hashing/hash-functions/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Hash Codes :: Data Structures in C#"><meta property="og:description" content="Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type’s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary<TKey, TValue> class to be able to find a given key that it has stored. On the other hand, because the number of possible keys is usually larger than the number of possible hash codes, unequal keys are also allowed to have the same hash code. The computation should be done quickly. Hash codes should be uniformly distributed even if the keys are not. The last goal above may seem rather daunting, particularly in light of our desire for a quick computation. In fact, it is impossible to guarantee in general — provided there are more than $ 2^{32}(k - 1) $ possible keys from which to choose, no matter how the hash code computation is implemented, we can always find at least $ k $ keys with the same hash code. However, this is a problem that has been studied a great deal, and several techniques have been developed that are effective in practice. We will caution, however, that not every technique that looks like it should be effective actually is in practice. It is best to use techniques that have been demonstrated to be effective in a wide variety of applications. We will examine one of these techniques in what follows."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Hash Tables"><meta property="article:modified_time" content="2023-06-07T11:36:57-05:00"><meta itemprop=name content="Hash Codes :: Data Structures in C#"><meta itemprop=description content="Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type’s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:
Equal keys must have the same hash code. This is necessary in order for the Dictionary<TKey, TValue> class to be able to find a given key that it has stored. On the other hand, because the number of possible keys is usually larger than the number of possible hash codes, unequal keys are also allowed to have the same hash code. The computation should be done quickly. Hash codes should be uniformly distributed even if the keys are not. The last goal above may seem rather daunting, particularly in light of our desire for a quick computation. In fact, it is impossible to guarantee in general — provided there are more than $ 2^{32}(k - 1) $ possible keys from which to choose, no matter how the hash code computation is implemented, we can always find at least $ k $ keys with the same hash code. However, this is a problem that has been studied a great deal, and several techniques have been developed that are effective in practice. We will caution, however, that not every technique that looks like it should be effective actually is in practice. It is best to use techniques that have been demonstrated to be effective in a wide variety of applications. We will examine one of these techniques in what follows."><meta itemprop=dateModified content="2023-06-07T11:36:57-05:00"><meta itemprop=wordCount content="1218"><title>Hash Codes :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/hashing/hash-functions/ rel=canonical type=text/html title="Hash Codes :: Data Structures in C#"><link href=/cis300/hashing/hash-functions/index.xml rel=alternate type=application/rss+xml title="Hash Codes :: Data Structures in C#"><link href=/cis300/hashing/hash-functions/tele.html rel=alternate type=text/html title="Hash Codes :: Data Structures in C#"><link href=/cis300/hashing/hash-functions/embed.html rel=alternate type=text/html title="Hash Codes :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1768892768 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1768892768 defer></script><script src=/cis300/js/search-lunr.min.js?1768892768 defer></script><script src=/cis300/js/search.min.js?1768892768 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1768892768"</script><script src=/cis300/js/lunr/lunr.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1768892768 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1768892768 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892768 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892768 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1768892768 rel=stylesheet><link href=/cis300/css/theme.min.css?1768892768 rel=stylesheet><link href=/cis300/css/format-print.min.css?1768892768 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/hashing/hash-functions/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1768892768 rel=stylesheet></head><body class="mobile-support print" data-url=/cis300/hashing/hash-functions/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable hashing" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=hash-codes>Hash Codes</h1></div><h2 id=hash-codes>Hash Codes</h2><p>Whenever equality is redefined for a type, the hash code computation for
that type needs to be redefined in a consistent way. This is done by
<a href=/cis300/strings/stringbuilder-impl/#overriding>overriding</a> that
type&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.object.gethashcode?view=net-6.0#system-object-gethashcode" rel=external target=_blank><strong>GetHashCode</strong></a>
method. In order for hashing to be implemented correctly and
efficiently, this method should satisfy the following goals:</p><ul><li>Equal keys must have the same hash code. This is necessary in order
for the <strong>Dictionary&lt;TKey, TValue></strong> class to be able to find a
given key that it has stored. On the other hand, because the number
of possible keys is usually larger than the number of possible hash
codes, unequal keys are also allowed to have the same hash code.</li><li>The computation should be done quickly.</li><li>Hash codes should be uniformly distributed even if the keys are not.</li></ul><p>The last goal above may seem rather daunting, particularly in light of
our desire for a quick computation. In fact, it is impossible to
guarantee in general &mdash; provided there are more than
<span class="math align-center">$ 2^{32}(k - 1) $</span> possible keys from which to choose, no
matter how the hash code computation is implemented, we can always find
at least <span class="math align-center">$ k $</span> keys with the same hash code. However, this is a problem
that has been studied a great deal, and several techniques have been
developed that are effective in practice. We will caution, however, that
not every technique that looks like it should be effective actually is
in practice. It is best to use techniques that have been demonstrated to
be effective in a wide variety of applications. We will examine one of
these techniques in what follows.</p><p>A guiding principle in developing hashing techniques is to use all
information available in the key. By using all the information, we will
be sure to use the information that distinguishes this key from other
keys. This information includes not just the values of the individual
parts of the the key, but also the order in which they occur, provided
this order is significant in distinguishing unequal keys. For example,
the strings, &ldquo;being&rdquo; and &ldquo;begin&rdquo; contain the same letters, but are
different because the letters occur in a different order.</p><p>One specific technique initializes the hash code to 0, then processes
the key one component at a time. These components may be bytes,
characters, or other parts no larger than 32 bits each. For example, for
the Nim board positions discussed in
<a href=/cis300/hashing/memoization/>&ldquo;Memoization&rdquo;</a>, the
components would be the number of stones on each pile, the limit for
each pile, and the total number of piles (to distinguish between a board
ending with empty piles and a board with fewer piles). For each
component, it does the following:</p><ul><li>Multiply the hash code by some fixed odd integer.</li><li>Add the current component to the hash code.</li></ul><p>Due to the repeated
multiplications, the above computation will often overflow an <strong>int</strong>.
This is not a problem &mdash; the remaining bits are sufficient for the hash code.</p><p>In order to understand this computation a little better, let&rsquo;s first
ignore the effect of this overflow. We&rsquo;ll denote the fixed odd integer
by <span class="math align-center">$ x $</span>, and the components of the key as
<span style=white-space:nowrap><span class="math align-center">$ k_1, \dots, k_n $</span>.</span> Then
this is the result of the computation:</p><span class="math align-left">$$(\dots ((0x + k_1)x + k_2) \dots)x + k_n = k_1 x^{n-1} + k_2 x^{n-2} + \dots + k_n.$$</span><p>Because the above is a polynomial, this hashing scheme is called
<em>polynomial hashing</em>. While the computation itself is efficient,
performing just a couple of arithmetic operations on each component, the
result is to multiply each component by a unique value (<span class="math align-center">$ x^i $</span>
for some <span style=white-space:nowrap><span class="math align-center">$ i $</span>)</span> depending on its position within the key.</p><p>Now let&rsquo;s consider the effect of overflow on the above polynomial. What
this does is to keep only the low-order 32 bits of the value of the
polynomial. Looking at it another way, we end up multiplying
<span class="math align-center">$ k_i $</span> by only the low-order 32 bits of <span style=white-space:nowrap><span class="math align-center">$ x^{n-i} $</span>.</span>
This helps to explain why <span class="math align-center">$ x $</span> is an odd number &mdash; raising an even number
to the <span style=white-space:nowrap><span class="math align-center">$ i $</span>th</span> power forms a number ending in <span class="math align-center">$ i $</span> 0s in binary. Thus, if
there are more than 32 components in the key, all but the last 32 will
be multiplied by <span style=white-space:nowrap><span class="math align-center">$ 0 $</span>,</span> and hence, ignored.</p><p>There are other potential problems with using certain odd numbers for
<span class="math align-center">$ x $</span>. For example, we wouldn&rsquo;t want to use <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>,</span> because that would result
in simply adding all the components together, and we would lose any
information regarding their positions within the key. Using <span class="math align-center">$ -1 $</span> would be
almost as bad, as we would multiply all components in odd positions by
<span class="math align-center">$ -1 $</span> and all components in even positions by <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span> The effect of overflow can
cause similar behavior; for example, if we place
<span class="math align-center">$ 2^{31} - 1 $</span> in an <strong>int</strong> variable and square it,
the overflow causes the result to be <span style=white-space:nowrap>1.</span> Successive powers will then
alternate between <span class="math align-center">$ 2^{31} - 1 $</span> and <span style=white-space:nowrap><span class="math align-center">$ 1 $</span>.</span></p><p>It turns out that this cyclic behavior occurs no matter what odd number
we use for <span style=white-space:nowrap><span class="math align-center">$ x $</span>.</span> However, in most cases the cycle is long enough that
keys of a reasonable size will have each component multiplied by a
unique value. The only odd numbers that result in short cycles are those
that are adjacent to a multiple of a large power of <span class="math align-center">$ 2 $</span> (note that <span class="math align-center">$ 0 $</span> is a
multiple of any integer).</p><p>The other potential problem occurs when we are hashing fairly short
keys. In such cases, if <span class="math align-center">$ x $</span> is also small enough, the values computed
will all be much smaller than the maximum possible integer value
<span style=white-space:nowrap><span class="math align-center">$ (2^{31} - 1) $</span>.</span> As a result, we will not have a uniform
distribution of values. We therefore want to avoid making <span class="math align-center">$ x $</span> too small.</p><p>Putting all this together, choosing <span class="math align-center">$ x $</span> to be an odd number between <span class="math align-center">$ 30 $</span>
and <span class="math align-center">$ 40 $</span> works pretty well. These values are large enough so that seven key
components will usually overflow an <strong>int</strong>. Furthermore, they all have
a cycle length greater than <span class="math align-center">$ 100 $</span> million.</p><p>We should always save the hash code in a <strong>private</strong> field after we
compute it so that subsequent requests for the same hash code don&rsquo;t
result in repeating the computation. This can be done in either of two
ways. One way is to compute it in an <em>eager</em> fashion by doing it in the
constructor. When doing it this way, the <strong>GetHashCode</strong> method simply
needs to return the value of the <strong>private</strong> field. While this is often
the easiest way, it sometimes results in computing a hash code that we
end up not using. The alternative is to compute it in a <em>lazy</em> fashion.
This requires an extra <strong>private</strong> field of type <strong>bool</strong>. This field is
used to indicate whether the hash code has been computed yet or not.
With this approach, the <strong>GetHashCode</strong> method first checks this field
to see if the hash code has been computed. If not, it computes the hash
code and saves it in its field. In either case, it then returns the
value of the hash code field.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1768892768></script><script src=/cis300/js/clipboard/clipboard.min.js?1768892768 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1768892768 defer></script><script src=/cis300/js/theme.min.js?1768892768 defer></script></div><script src=/cis300/js/tele-scroll.min.js?1768892768 defer></script></body></html>