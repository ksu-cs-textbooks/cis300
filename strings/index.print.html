<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="strings and StringBuilders C# and .NET provide two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="strings and StringBuilders :: Data Structures in C#"><meta name=twitter:description content="strings and StringBuilders C# and .NET provide two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/strings/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="strings and StringBuilders :: Data Structures in C#"><meta property="og:description" content="strings and StringBuilders C# and .NET provide two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="strings and StringBuilders :: Data Structures in C#"><meta itemprop=description content="strings and StringBuilders C# and .NET provide two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other."><meta itemprop=dateModified content="2023-05-31T10:25:43-05:00"><meta itemprop=wordCount content="59"><title>strings and StringBuilders :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723839223 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723839223 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723839223 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723839223 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723839223 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723839223 rel=stylesheet><link href=/cis300/css/fonts.css?1723839223 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723839223 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723839223 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723839223 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723839223 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723839223 rel=stylesheet><link href=/cis300/css/print.css?1723839223 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723839223 rel=stylesheet><script src=/cis300/js/variant.js?1723839223></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723839223 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/strings/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>strings and StringBuilders</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/io/other-file-io/ title="Other File I/O (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/strings/strings/ title="strings (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=strings-and-stringbuilders>strings and StringBuilders</h1></div><h2 id=strings-and-stringbuilders><strong>string</strong>s and <strong>StringBuilder</strong>s</h2><p>C# and .NET provide two data structures for representing
sequences of characters - <strong>string</strong>s and <strong>StringBuilder</strong>s. Each of
these data structures has its own advantages and disadvantages. In this
chapter, we will examine how these two types are used and implemented.
In the process, we will note the tradeoffs involved in using one or the
other.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of strings and StringBuilders</h1><article class=default><header class=headline></header><div hidden><h1 id=strings>strings</h1></div><h2 id=strings><strong>string</strong>s</h2><p>Instances of the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0" rel=external target=_blank><strong>string</strong></a>
class are <em>immutable</em> sequences of characters. Because <strong>string</strong> is a
class, it is a <a href=/cis300/appendix/syntax/reference-value/>reference
type</a>. Because
instances are immutable, once they are constructed, their contents
cannot change. Note that this does <em>not</em> mean that <strong>string</strong> variables
cannot change - we can assign a <strong>string</strong> variable <code>s</code> the value &ldquo;abc&rdquo;
and later assign it the value &ldquo;xyz&rdquo;. These assignments simply assign to
<code>s</code> references to different instances of the <strong>string</strong> class. What
immutability does mean is that there is no way to change any of the
characters in either of these instances (i.e., in either &ldquo;abc&rdquo; or
&ldquo;xyz&rdquo;). As a result, it is safe to copy a <strong>string</strong> by simply assigning
the value of one <strong>string</strong> variable to another; for example, if <code>s</code> is
a <strong>string</strong> variable, we can write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>t</span> <span class=p>=</span> <span class=n>s</span><span class=p>;</span></span></span></code></pre></div><p>Note that this is <em>not</em> safe when dealing with mutable reference types,
such as arrays. For example, let <code>a</code> be an <strong>int[Â ]</strong> with at least
one element, and consider the following code sequence:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span><span class=p>[</span> <span class=p>]</span> <span class=n>b</span> <span class=p>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=p>[</span><span class=m>0</span><span class=p>]++;</span></span></span></code></pre></div><p>Because <code>a</code> and <code>b</code> refer to the same array, <code>a[0]</code> is incremented as
well. This danger is absent for <strong>string</strong>s because they are immutable.</p><p>We access individual characters in a <strong>string</strong> by indexing; i.e., if
<code>s</code> is a <strong>string</strong> variable, then <code>s[0]</code> retrieves its first character,
<code>s[1]</code> retrieves its second character, etc. For example, if <code>s</code> refers
to the string, &ldquo;abc&rdquo;, then after executing</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>char</span> <span class=n>c</span> <span class=p>=</span> <span class=n>s</span><span class=p>[</span><span class=m>1</span><span class=p>];</span></span></span></code></pre></div><p><code>c</code> will contain &lsquo;b&rsquo;. Note that a statement like</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>s</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span></span></span></code></pre></div><p>is prohibited in order to enforce immutability.</p><p>We obtain the number of characters in a <strong>string</strong> using its
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.length?view=net-6.0#system-string-length" rel=external target=_blank><strong>Length</strong></a>
property; for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span> <span class=n>len</span> <span class=p>=</span> <span class=n>s</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span></span></span></code></pre></div><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>A <strong>string</strong> may have a length of 0. This means that it is the <em>empty
string</em>, denoted by &ldquo;&rdquo;. Note that "" is different from a <strong>null</strong>
reference - for example, if <code>s</code> refers to &ldquo;&rdquo;, then <code>s.Length</code>
has a value of 0, but if <code>s</code> is <strong>null</strong>, then this expression will
throw a <strong>NullReferenceException</strong>.</p></div></div><p>We can concatenate two <strong>string</strong>s using the <code>+</code> operator. For example, if
<code>s</code> refers to the <strong>string</strong> &ldquo;abc&rdquo; and <code>t</code> refers to the <strong>string</strong>
&ldquo;xyz&rdquo;, then</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>u</span> <span class=p>=</span> <span class=n>s</span> <span class=p>+</span> <span class=n>t</span><span class=p>;</span></span></span></code></pre></div><p>will assign the <strong>string</strong> &ldquo;abcxyz&rdquo; to <code>u</code>.</p><p>Because <strong>string</strong>s are immutable, building long <strong>string</strong>s directly
from many small pieces is very inefficient. Suppose, for example, that
we want to convert all the lower-case characters in the <strong>string</strong>
<code>text</code> to upper-case, and to convert all upper-case letters in <code>text</code> to
lower-case. All other characters we will leave unchanged. We can do this
with the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>result</span> <span class=p>=</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span> <span class=p>=</span> <span class=n>text</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>IsLower</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=p>+=</span> <span class=kt>char</span><span class=p>.</span><span class=n>ToUpper</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>IsUpper</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=p>+=</span> <span class=kt>char</span><span class=p>.</span><span class=n>ToLower</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=p>+=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now suppose that <code>text</code> contains 100,000 characters. Each iteration of
the loop executes one of the three branches of the <strong>if</strong>-statement,
each of which concatenates one character to the <strong>string</strong> accumulated
so far. Because <strong>string</strong>s are immutable, this concatenation must be
done by copying all the characters in <code>result</code>, along with the
concatenated character, to a new <strong>string</strong>. As a result, if we were to
add up the total number of characters copied over the course of the
entire loop, we would come up with 5,000,050,000 character copies done.
This may take a while. In general, we say that this code runs in
<em>O</em>(<em>n</em><sup>2</sup>) time, where <em>n</em> is the length of <code>text</code>. This means
that as <em>n</em> increases, the running time of the code is at worst
proportional to <em>n</em><sup>2</sup>. In <a href=/cis300/strings/stringbuilders/>the next
section</a>, we will see
how we can do this much more efficiently using another data structure.</p><p><strong>string</strong>s have many other methods to allow various kinds of
manipulation - see <a href="https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-6.0" rel=external target=_blank>the documentation for the <strong>string</strong>
class</a>
for details.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=stringbuilders>StringBuilders</h1></div><h2 id=stringbuilders><strong>StringBuilder</strong>s</h2><p>In <a href=/cis300/strings/strings/>the previous
section</a>, we saw that
building large <strong>string</strong>s from small pieces by concatenating them
together is very inefficient. This inefficiency is due to the fact that
<strong>string</strong>s are immutable. In order to overcome the inefficiency of
concatenation, we need an alternative data structure that we can modify.
The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0" rel=external target=_blank><strong>StringBuilder</strong></a>
class fills this need.</p><p>Like <strong>string</strong>s, <strong>StringBuilder</strong>s implement sequences of characters,
but the contents of <strong>StringBuilder</strong>s can be changed. The
<strong>StringBuilder</strong> class has six constructors. The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.-ctor?view=net-6.0#system-text-stringbuilder-ctor" rel=external target=_blank>simplest
<strong>StringBuilder</strong>
constructor</a>
takes no parameters and constructs an empty <strong>StringBuilder</strong> &mdash; i.e., a
<strong>StringBuilder</strong> containing no characters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>StringBuilder</span> <span class=n>sb</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span></span></span></code></pre></div><p>We can then modify a <strong>StringBuilder</strong> in various ways. First, we may
append a <strong>char</strong> to the end using its
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.append?view=net-6.0#system-text-stringbuilder-append(system-char)" rel=external target=_blank><strong>Append</strong></a>
method. This method not only changes the contents of the
<strong>StringBuilder</strong>, but it also returns a reference to it. Thus if we
have <strong>char</strong> variables, <code>a</code>, <code>b</code>, and <code>c</code>, and a <strong>StringBuilder</strong>
variable <code>sb</code>, we can write code such as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>sb</span><span class=p>.</span><span class=n>Append</span><span class=p>(</span><span class=n>a</span><span class=p>).</span><span class=n>Append</span><span class=p>(</span><span class=n>b</span><span class=p>).</span><span class=n>Append</span><span class=p>(</span><span class=n>c</span><span class=p>);</span></span></span></code></pre></div><p>The first call to <strong>Append</strong> appends the contents of <code>a</code> to <code>sb</code>, and
returns <code>sb</code>. Thus, the second call to <strong>Append</strong> also applies to <code>sb</code> -
it appends the contents of <code>b</code>. Likewise, the third call appends the
contents of <code>c</code>.</p><p>Because this method changes a <strong>StringBuilder</strong>, rather than
constructing a new one, its implementation is very efficient - in most
cases, only the appended character needs to be copied (see
&ldquo;<a href=/cis300/strings/stringbuilder-impl/>Implementation of
<strong>StringBuilder</strong>s</a>&rdquo;
for details). This class has other <strong>Append</strong> methods as well, including
one that <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.append?view=net-6.0#system-text-stringbuilder-append(system-string)" rel=external target=_blank>appends the contents of a given
<strong>string</strong></a>.
This method likewise only needs to copy the appended characters.</p><p>Let us now return to the problem of converting all lower-case letters in
a <strong>string</strong> to upper-case, converting all upper-case letters to
lower-case, and leaving all other characters unchanged. We can use a
<strong>StringBuilder</strong> as an intermediate data structure to do this much more
efficiently than the code presented in <a href=/cis300/strings/strings/>the previous
section</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>StringBuilder</span> <span class=n>sb</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span> <span class=p>=</span> <span class=n>text</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>IsLower</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sb</span><span class=p>.</span><span class=n>Append</span><span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>ToUpper</span><span class=p>(</span><span class=n>c</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>IsUpper</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sb</span><span class=p>.</span><span class=n>Append</span><span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>ToLower</span><span class=p>(</span><span class=n>c</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sb</span><span class=p>.</span><span class=n>Append</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=n>result</span> <span class=p>=</span> <span class=n>sb</span><span class=p>.</span><span class=n>ToString</span><span class=p>();</span></span></span></code></pre></div><p>On most iterations, the above loop only copies one character. In
addition, the call to the <strong>StringBuilder</strong>&rsquo;s <strong>ToString</strong> method copies
each character in the result. If <code>text</code> is 100,000 characters long, this
is a total of 200,000 character copies. Using the <strong>StringBuilder</strong>
implementation described in <a href=/cis300/strings/stringbuilder-impl/>the next
section</a>, there
are some iterations that copy more than one character, but even if we
account for this, it turns out that fewer than 400,000 characters are
copied, as opposed to over five billion character copies when
<strong>string</strong>s are used directly (see <a href=/cis300/strings/strings/>the previous
section</a>). The .NET
<strong>StringBuilder</strong> implementation performs even
better. In either case, the above code runs in <em>O</em>(<em>n</em>) time, where <em>n</em>
is the length of <code>text</code>; i.e., as <em>n</em> gets large, the running time is at
worst proportional to <em>n</em>. Thus, its performance degrades much less
rapidly than the <em>O</em>(<em>n</em><sup>2</sup>) code that uses <strong>string</strong>s
directly.</p><p>A program that runs the above code and the code given in <a href=/cis300/strings/strings/>the previous
section</a> on user-provided
text files can be obtained by creating a Git repository (see <a href=/cis300/appendix/vs/repos/>&ldquo;Git
Repositories&rdquo;</a>) using
<a href=https://classroom.github.com/a/PO7WgRNh rel=external target=_blank>this URL</a>. A noticeable
performance difference can be seen on text files larger than 100K - for
example, the full text of <a href=http://www.gutenberg.org/cache/epub/12/pg12.txt rel=external target=_blank>Lewis Carroll&rsquo;s <em>Through the Looking
Glass</em></a>.</p><p><strong>StringBuilder</strong>s have some features in common with <strong>string</strong>s. For
example, we access individual characters in a <strong>StringBuilder</strong> by
indexing; i.e., if <code>sb</code> is a <strong>StringBuilder</strong> variable, then <code>sb[0]</code>
accesses its first character, <code>sb[1]</code> accesses its second character,
etc. The main difference here is that with a <strong>StringBuilder</strong>, we may
use indexing to change characters; e.g., we may do the following,
provided <code>sb</code> contains at least 3 characters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>sb</span><span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=p>=</span> <span class=sc>&#39;x&#39;</span><span class=p>;</span></span></span></code></pre></div><p>A <strong>StringBuilder</strong> also has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.length?view=net-6.0#system-text-stringbuilder-length" rel=external target=_blank><strong>Length</strong></a>
property, which gets the number of characters contained. However, we may
also set this property to any nonnegative value, provided there is
enough memory available to provide this length. For example, we may
write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>sb</span><span class=p>.</span><span class=n>Length</span> <span class=p>=</span> <span class=m>10</span><span class=p>;</span></span></span></code></pre></div><p>If the new length is shorter than the old, characters are removed from
the end of the <strong>StringBuilder</strong>. If the new length is longer that the
old, <strong>char</strong>s containing the Unicode NULL value (0 in decimal) are
appended.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>The Unicode NULL value is different from a <strong>null</strong>
reference. Because <strong>char</strong> is a <a href=/cis300/appendix/syntax/reference-value/>value
type</a>, a <strong>char</strong>
cannot store a <strong>null</strong> reference.</p></div></div><p><strong>StringBuilder</strong>s have many other methods to allow various kinds of
manipulation - see <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0" rel=external target=_blank>the documentation for the <strong>StringBuilder</strong>
class</a>
for details. There is also a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.-ctor?view=net-6.0#system-text-stringbuilder-ctor(system-string)" rel=external target=_blank><strong>StringBuilder</strong>
constructor</a>
that takes a <strong>string</strong> as its only parameter and constructs a
<strong>StringBuilder</strong> containing the contents of that <strong>string</strong>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementation-of-stringbuilders>Implementation of StringBuilders</h1></div><h2 id=implementation-of-stringbuilders>Implementation of <strong>StringBuilder</strong>s</h2><p>In this section, we will examine some of the implementation details of
the <strong>StringBuilder</strong> class. There are several reasons for doing this.
First, by examining these details, we can begin to understand why a
<strong>StringBuilder</strong> is so much more efficient than a <strong>string</strong> when it
comes to building long <strong>string</strong>s a character at a time. Second, by
studying implementations of data structures, we can learn techniques
that might be useful to us if we need to build our own data structures.
Finally, a computing professional who better understands the underlying
software will be better equipped to use that software effectively.</p><p>In what follows, we will develop an implementation of a simplified
<strong>StringBuilder</strong> class. Specifically, we will only implement enough to
support the program that flips the case of all characters in a
<strong>string</strong> (see <a href=/cis300/strings/stringbuilders/>the previous
section</a>). Most other
features of a <strong>StringBuilder</strong> have a rather straightforward
implementation once the basics are done (we will show how to implement
an indexer in <a href=/cis300/appendix/syntax/indexers/>a later
section</a>).</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>The
implementation described here is much simpler than the .NET
implementation, which achieves
even better performance.</p></div></div><p>In order to illustrate more clearly the techniques used to implement a
<strong>StringBuilder</strong>, we will present an implementation that uses only
those types provided by the C#
core language, rather than those found in a library such as .NET. One
of the more useful data
structures that the C# core language provides for building more
advanced data structures
is the array. We can represent the characters in a <strong>StringBuilder</strong>
using a <strong>char[Â ]</strong>. One difficulty in using an array, however, is
that we don&rsquo;t know how many characters our <strong>StringBuilder</strong> might need.
We will return to this issue shortly, but for now, let&rsquo;s just
arbitrarily pick a size for our array, and define:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The initial capacity of the underlying array.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kd>const</span> <span class=kt>int</span> <span class=n>_initialCapacity</span> <span class=p>=</span> <span class=m>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The character in this StringBuilder.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>char</span><span class=p>[]</span> <span class=n>_characters</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=n>_initialCapacity</span><span class=p>];</span></span></span></code></pre></div><p>An array with 100 elements will give us room enough to store up to 100
characters. In fact, initializing the array in this way actually gives
us 100 characters, as each array element is initialized to a Unicode
NULL character (a <strong>char</strong> with a decimal value of 0). Because <strong>char</strong>
is a <a href=/cis300/appendix/syntax/reference-value/>value type</a>,
each array element is going to store a <strong>char</strong> - it&rsquo;s just a question
of which <strong>char</strong> it is going to store. Therefore, if we want to be able
to represent a sequence of <em>fewer</em> than 100 characters, we need an
additional field to keep track of how many characters of the array
actually represent characters in the <strong>StringBuilder</strong>. We therefore
define:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The number of characters in this StringBuilder.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=n>_length</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span></span></span></code></pre></div><p>Thus, for example, if <code>_length</code> is 25, the first 25 characters in
<code>_characters</code> will be the characters in the <strong>StringBuilder</strong>.</p><p>Because both fields have initializers, the default constructor will
initialize them both; hence, we don&rsquo;t need to write a constructor. Let&rsquo;s
focus instead on the <strong>Append</strong> method. This method needs to take a
<strong>char</strong> as its only parameter and return a <strong>StringBuilder</strong> (itself).
Its effect needs to be to add the given <strong>char</strong> to the end of the
sequence of characters in the <strong>StringBuilder</strong>.</p><p>In order to see how this can be done, consider how our fields together
represent the sequence of characters:</p><p><a href=#R-image-e577dad9d2e7876e4629c9820ef92c26 class=lightbox-link><img alt="The implementation of a StringBuilder" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/strings/stringbuilder-impl/stringbuilder-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e577dad9d2e7876e4629c9820ef92c26><img alt="The implementation of a StringBuilder" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/strings/stringbuilder-impl/stringbuilder-impl.jpg></a></p><p>Within the array referred to by <code>_characters</code>, the first <code>_length</code>
locations (i.e., locations 0 through <code>_length</code>Â -Â 1) store the
characters in the <strong>StringBuilder</strong>. This means that
<code>_characters[_length]</code> is the next available location, provided this is
a valid array location. In this case, we can simply place the <strong>char</strong>
to be appended in <code>_characters[_length]</code>, increment <code>_length</code> (because
the number of characters in the <strong>StringBuilder</strong> has increased by 1),
and return the <strong>StringBuilder</strong>.</p><p>However, what if we are already using all of the array locations for
characters in the <strong>StringBuilder</strong>? In this case, <code>_length</code> is the
length of the array, and therefore is not a valid array location. In
order to handle this case, we need to make more room. The only way to do
this to construct a new, larger array, and copy all of the characters
into it. We will then make <code>_characters</code> refer to the new array. (.NET actually provides a method to do all this, but in order
to show the details of what is happening, we will not use it.) Now that
there is enough room, we can append the new character as above. The code
is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Appends the given character to the end of this StringBuilder.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;c&#34;&gt;The character to append.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;This StringBuilder.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>StringBuilder</span> <span class=n>Append</span><span class=p>(</span><span class=kt>char</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_length</span> <span class=p>==</span> <span class=n>_characters</span><span class=p>.</span><span class=n>Length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span><span class=p>[]</span> <span class=n>chars</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>char</span><span class=p>[</span><span class=m>2</span> <span class=p>*</span> <span class=n>_length</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>_characters</span><span class=p>.</span><span class=n>CopyTo</span><span class=p>(</span><span class=n>chars</span><span class=p>,</span> <span class=m>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>_characters</span> <span class=p>=</span> <span class=n>chars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>_characters</span><span class=p>[</span><span class=n>_length</span><span class=p>]</span> <span class=p>=</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>_length</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>A few comments on the above code are in order. First, when we need a new
array, we allocate one of twice the size as the original array. We do
this for a couple of reasons. First, notice that copying every character
from one array to another is expensive if there are a lot of characters.
For this reason, we don&rsquo;t want to do it very often. By doubling the size
of the array every time we run out of room, we increase the size by
enough that it will be a while before we need to do it again. On the
other hand, doubling the array doesn&rsquo;t waste too much space if we don&rsquo;t
need to fill it entirely.</p><p>The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.array.copyto?view=net-6.0#system-array-copyto(system-array-system-int32)" rel=external target=_blank><strong>CopyTo</strong></a>
method used above copies all of the elements in the array to which this
method belongs (in this case, <code>_characters</code>) to the array given by the
first parameter (<code>chars</code> in this case), placing them beginning at the
location given by the second parameter (0 in this case). Thus, we are
copying all the elements of <code>_characters</code> to <code>chars</code>, placing them
beginning at location 0.</p><p>The last statement within the <strong>if</strong> block assigns the reference stored
in <code>chars</code> to <code>_characters</code>; i.e., it makes <code>_characters</code> refer to the
same array as does <code>chars</code>. The last statement in the method returns the
<strong>StringBuilder</strong> whose <strong>Append</strong> method was called.</p><p><span id=overriding></span> To complete this simple implementation, we
need to provide a <strong>ToString</strong> method. This method is already defined
for every <strong>object</strong>; hence, <strong>StringBuilder</strong> <em>inherits</em> this
definition by default. However, the <strong>ToString</strong> method defined for
<strong>object</strong>s doesn&rsquo;t give us the <strong>string</strong> we want. Fortunately, though,
this method is a <strong>virtual</strong> method, meaning that we can re-define by
<em>overriding</em> it. We do this by using the keyword, <strong>override</strong>, in its
definition. Visual StudioÂ®&rsquo;s auto-complete feature is helpful here,
as when we type the word <strong>override</strong>, it presents us with a list of the
methods that can be overridden. Selecting <strong>ToString</strong> from this list
will fill in a template for the method with a correct parameter list and
return type.</p><p>We want this method to return the <strong>string</strong> formed from the first
<code>_length</code> characters in <code>_characters</code>. We can form such a string using
one of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.-ctor?view=netframework-4.7.2#System_String__ctor_System_Char___System_Int32_System_Int32_" rel=external target=_blank><strong>string</strong>
constructor</a>s.
This constructor takes three parameters:</p><ul><li>a <strong>char[Â ]</strong> containing the characters to form the <strong>string</strong>;</li><li>an <strong>int</strong> giving the index in this array of the first character to
use; and</li><li>an <strong>int</strong> giving the number of characters to use.</li></ul><p>We can therefore define the <strong>ToString</strong> method as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Converts this StringBuilder to a string.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The string equivalent of this StringBuilder.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>override</span> <span class=kt>string</span> <span class=n>ToString</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=kt>string</span><span class=p>(</span><span class=n>_characters</span><span class=p>,</span> <span class=m>0</span><span class=p>,</span> <span class=n>_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>You can obtain a program containing the complete <strong>class</strong> definition by
creating a Git repository (see <a href=/cis300/appendix/vs/repos/>&ldquo;Git
Repositories&rdquo;</a>) using
<a href=https://classroom.github.com/a/Nxy4T-la rel=external target=_blank>this URL</a>. This program is a
modification of the program used in <a href=/cis300/strings/stringbuilders/>the previous
section</a> to compare the performance
differences between using
<strong>string</strong>s or <strong>StringBuilder</strong>s when building <strong>string</strong>s a
character at a time. Its only modification is to use this
<strong>StringBuilder</strong> class, defined within a class
library, instead of
the class defined in .NET. By running the program on long
<strong>string</strong>s, you can verify that the performance of this
<strong>StringBuilder</strong> class is comparable to that of the <strong>StringBuilder</strong>
in .NET.</p><p>Now that we have the details of a <strong>StringBuilder</strong> implementation, we
can begin to see why it is so much more efficient to build a <strong>string</strong>
a character at a time using a <strong>StringBuilder</strong>, as opposed to using a
<strong>string</strong>. As we have noted, allocating a new array and copying all
characters to it is expensive; however, we have tried to reduce the
number of times this is done. To see how this is accomplished, suppose
we are building a <strong>string</strong> of 100,000 characters. The first time we
need a larger array, we will copy 100 characters to a 200-element array.
The next time, we will copy 200 characters to a 400-element array. This
will continue until we copy 51,200 characters to a 102,400-element
array, which is large enough to hold all of the characters. If we add up
all of the character copies we have done when allocating new arrays, we
find that there are a total of 102,300 copies. In addition, each time we
call <strong>Append</strong>, we copy the <strong>char</strong> parameter to the array. This is
another 100,000 copies. Finally, the <strong>ToString</strong> method must copy all
of the characters to the <strong>string</strong> it is constructing. This is another
100,000 character copies, for a total of 302,300 copies. In general, the
number of character copies will always be less than 4<em>n</em>, where <em>n</em> is
the length of the <strong>string</strong> being built.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Rod Howell
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/4453de351fe700d9a927dd9cbec5947f1915cb62>May 31, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723839223 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723839223 defer></script><script src=/cis300/js/theme.js?1723839223 defer></script></body></html>