<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Introduction to Tries</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/tries-multiple-impl">Next:
      Multiple Implementations of Children
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/tries">Up: Tries
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Introduction to Tries</h1>

A <i>trie</i> is a nonempty tree storing a set of words in the
    following way:
<ul>
<li> Each child of a node is labeled with a character. </li>
<li> Each node contains a boolean indicating whether the labels in the
	path from the root to that node form a word in the set. </li>
</ul>
The word, "trie", is taken from the middle of the word, "retrieval",
    but to avoid confusion, it is pronounced like "try" instead of
    like "tree".
<p></p>
Suppose, for example, that we want to store the following words:
<ul>
<li> ape</li>
<li> apple</li>
<li> cable</li>
<li> car</li>
<li> cart</li>
<li> cat</li>
<li> cattle</li>
<li> curl</li>
<li> far</li>
<li> farm</li>
</ul>
A trie storing these words (where we denote a value of <b>true</b> for
    the boolean with a '*') is as follows:
<p>
<img src="trie-example.jpg" alt="A trie">
</p>
Thus, for example, if we follow the path from the root through the
    labels 'c', 'a', and 'r', we reach a node with a <b>true</b>
    boolean value (shown by the '*' in the above picture); hence,
    "car" is in this set of words.  However, if we follow the path
    through the labels 'c', 'u', and 'r', the node we reach has a
    <b>false</b> boolean; hence, "cur" is not in this set.  Likewise,
    if we follow the path through 'a', we reach a node from which there
    is no child labeled 'c'; hence, "ace" is not in this set.
<p>
Note that each subtree of a trie is also a trie, although the "words"
      it stores may begin to look a little strange.  For example if
      we follow the path through 'c' and 'a' in the above figure, we
      reach a trie that contains the following "words":
</p>
<ul>
<li> "ble"</li>
<li> "r"</li>
<li> "rt"</li>
<li> "t"</li>
<li> "ttle"</li>
</ul>
These are actually the <i>completions</i> of the original words 
    that begin with the prefix "ca".  Note that if, in this
    subtree, we take the path through 't', we reach a trie containing
    the following completions:
<ul>
<li> "" [i.e., the empty string]</li>
<li> "tle"</li>
</ul>
In particular, the empty string is a word in this trie.  This
    motivates an alternative definition of the boolean stored in each
    node: it indicates whether the empty string is stored in the trie
    rooted at this node.  This definition may be somewhat preferable
    to the one given above, as it does not depend on any context, but
    instead focuses entirely on the trie rooted at that particular
    node.
<p>
One of the main advantages of a trie over an <a
	href="/~rhowell/DataStructures/redirect/avl-trees">AVL
	tree</a> is the speed with which we can look up words.
	Assuming we can quickly find the child with a given label, the
	time we need to look up a word is proportional to the length
	of the word, no matter how many words are in the trie.  Note
	that in looking up a word that is present in an AVL tree, we
	will at least need to compare the given word with its occurrence in
	the tree, in addition to any other comparisons done during the
	search.  The time it takes to do this one comparison is
	proportional to the length of the word, as we need to verify
	each character (we actually ignored the cost of such
	comparisons when we analyzed the performance of AVL trees).
	Consequently, we can expect a significant performance
	improvement by using a trie if our set of words is large.
</p>
Let's now consider how we can implement a trie.  There are various
    ways that this can be done, but we'll consider a fairly
    straightforward approach in this section (we'll improve the
    implementation in <a
    href="/~rhowell/DataStructures/redirect/tries-multiple-impl">the
    next section</a>).  We will assume that the words we are storing
    are comprised of only the 26 lower-case English letters.  In this
    implementation, a single node will contain the following
    <b>private</b> fields:
<ul>
<li> A <b>bool</b> storing whether the empty string is contained in
	the trie rooted at this node (or equivalently, whether this
	node ends a word in the entire trie). </li>
<li> A 26-element array of tries storing the children, where element
	0 stores the child labeled 'a', element 1 stores the child
	labeled 'b', etc.  If there is no child with some label, the
	corresponding array element is <b>null</b>. </li>
</ul>
Note that in this implementation, no <b>char</b>s or <b>string</b>s
    are actually stored.  We can see if a node has a child labeled by
    a given <b>char</b> by finding the difference between that
    <b>char</b> and 'a', and using that difference as the array
    index.  For example, suppose the array field is named
    <tt>_children</tt>, and suppose <tt>label</tt> is a <b>char</b>
    variable containing a lower-case letter.  Because <b>char</b> is
    technically a numeric type, we can perform arithmetic with
    <b>char</b>s; thus, we can obtain the child labeled by
    <tt>label</tt> by retrieving
    <tt>_children[label&nbsp;-&nbsp;'a']</tt>.  More specifically, if
    <tt>label</tt> contains 'd', then the difference,
    <tt>label&nbsp;-&nbsp;'a'</tt> will be 3; hence, the child with
    label 'd' will be stored at index 3.  We have therefore achieved
    our goal of providing quick access to a child with a given label.
<p>
Let's now consider how to implement a lookup.  We can define a
      <b>public</b> method for this purpose within the class
      implementing a trie node:
</p>
<pre>
public bool Contains(string s)
{

    . . .

}
</pre>
Note that this method
      does not need a trie node as a parameter because the method will
      belong to a trie node.  Thus, the method will be able to access
      the node as <a
      href="/~rhowell/DataStructures/redirect/static-this"><b>this</b></a>,
      and may access its <b>private</b> fields directly by their
      names.  The method consists of four cases:
<ul>
<li> <tt>s</tt> is the empty <b>string</b>.  In this case, the
	<b>bool</b> stored in 
	this node indicates whether it is a word in this trie; hence,
	we can simply return this <b>bool</b>. </li>
<li> The first character of <tt>s</tt> is not a
	lower-case English letter (i.e., it is less than 'a' or greater
	than 'z').  Then <tt>s</tt> can't be stored in this trie.  In
	this case, we can return <b>false</b>. </li>
<li> The child labeled with the first character of <tt>s</tt>
	(obtained as described above) is
	missing (i.e., is <b>null</b>).  Then <tt>s</tt> isn't stored in this
	trie.  Again, we return <b>false</b>. </li>
<li> The child labeled with the first character of <tt>s</tt> is
	present (i.e., non-<b>null</b>).  In this case, we need to
	determine whether the substring 
	following the first character of <tt>s</tt> is in the trie
	rooted at the child we retrieved.  This 
	can be found using a recursive call to this method within the
	child trie node.  We return the result of this recursive
	call. </li>
</ul>
In order to be able to look up words, we need to be able to build a
    trie to look in.  We therefore need to be able to add words to a
    trie.  It's not practical to make a trie node immutable, as there
    is too much information that would need to be copied if we need to
    replace a node with a new one (we would need to construct a new
    node for each letter of each word we added).  We therefore should
    provide a <b>public</b> method within the trie node class for the
    purpose of adding a word to the trie rooted at this node:  
<pre>
public void Add(string s)
{

    . . .

}
</pre>
This time there are three cases:
<ul>
<li> <tt>s</tt> is the empty <b>string</b>.  Then we can record this word
	by setting the <b>bool</b> in this node to <b>true</b>. </li>
<li> The first character of <tt>s</tt> is not a lower-case
	English letter.  Then we can't add the word.  In this case, we'll
	need to throw an exception. </li>
<li> The first character is a lower-case English letter.  In this
	case, we need to add the substring following the first character
	of <tt>s</tt> to the child labeled with the first letter.  We do
	this as follows:
<ul>
<li> If the child labeled with the first letter of the word is missing
	    (i.e., <b>null</b>), we construct a new trie node and place
	    it in the array location for this child. </li>
<li> Now that we have a child labeled with the first letter, we can
	    add the substring following the first letter
	    to this child by making a recursive call. </li>
</ul>
</li>
</ul>


<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/tries-multiple-impl">Next:
      Multiple Implementations of Children
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/tries">Up: Tries
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Tue Mar  6 16:17:50 CST 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
