<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Multiple Implementations of Children</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Multiple Implementations of Children</h1>

The trie implementation given in <a href="/~rhowell/DataStructures/redirect/tries-intro">the
      previous section</a> offers very efficient lookups - a word of
      length <i>m</i> can be looked up in <i>O</i>(<i>m</i>) time, no
      matter how many words are in the trie.  However, it wastes a
      large amount of space.  In a typical trie, a majority of the
      nodes will have no more than one child; however, each node
      contains a 26-element array to store its children.  Furthermore,
      each of these arrays is automatically initialized so that all
      its elements are <b>null</b>.  This initialization takes time.
      Hence, building a trie may be rather inefficient as well.
<p>
We can implement a trie more efficiently if we can customize the
      implementation of a node based on the number of children it
      has.  Because most of the nodes in a trie can be expected to
      have either no children or only one child, we can define
      alternate implementations for these special cases:
<ul>
<li> For a node with no children, there is no need to represent any
	children - we only need the <b>bool</b> indicating whether the
	trie rooted at this node contains the empty <b>string</b>. </li>
<li> For a node with exactly one child, we maintain a single reference
	to that one child.  If we do this, however, we won't be able
	to infer the child's label from where we store the child;
	hence, we also need to have a <b>char</b> giving the child's
	label.  We also need the <b>bool</b> indicating whether the
	trie rooted at this node contains the empty
	<b>string</b>. </li>
</ul>
For all other nodes, we can use an implementation similar to the one
      outlined in <a href="/~rhowell/DataStructures/redirect/tries-intro">the
      previous section</a>.  We will still waste some space with the
      nodes having more than one child but fewer than 26; however, the
      amount of space wasted will now be much less.  Furthermore, in
      each of these three implementations, we can quickly access the
      child with a given label (or determine that there is no such
      child).
<p>
Conceptually, this sounds great, but we run into some obstacles as
      soon as we try to implement this approach.  Because we are
      implementing nodes in three different ways, we need to define
      three different classes.  Each of these classes defines a
      different type.  So how do we build a trie from three different
      types of nodes?  In particular, how do we define the type of a
      child when that child may be any of three different types?
</p>
The answer is to use a C# construct called an <i>interface</i>.  An
    interface facilitates <i>abstraction</i> - hiding lower-level
    details in order to focus on higher-level details.  At a high
    level (i.e., ignoring the specific implementations), these three
    different classes appear to be the same: they are all used to
    implement tries of words made up of lower-case English letters.
    More specifically, we want to be able to add a <b>string</b> to
    any of these classes, as well as to determine whether they contain
    a given <b>string</b>.  An interface allows us to define a type
    that has this functionality, and to define various sub-types that
    have different implementations, but still have this functionality.
<p>
A simple example of an interface is <a href="https://msdn.microsoft.com/en-us/library/4d7sx9hd.aspx"><b>IComparable&lt;T&gt;</b></a>.
	Recall from the section, "<a href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/dictionary-linked-lists">Implementing
	a Dictionary with a Linked List</a>", that we can constrain
	the keys in a dictionary implementation to be of a type that
	can be ordered by using a <b>where</b> clause on the
      <b>class</b> statement, as follows:
    <pre>
      public class Dictionary&lt;TKey, TValue&gt; where TKey : IComparable&lt;TKey&gt;
    </pre>
    
	The <a href="https://referencesource.microsoft.com/#mscorlib/system/icomparable.cs,3911354c40e0c30e">source
	code for the <b>IComparable&lt;T&gt;</b> interface</a> has been posted
	by Microsoft®.  The essential part of this definition is:
<pre>
      public interface IComparable&lt;in T&gt;
      {
          int CompareTo(T other);
      }
    </pre>
    (Don't worry about the <b>in</b> keyword with the type parameter
    in the first line.)
This definition defines the type <b>IComparable&lt;T&gt;</b> as having a
    method <b>CompareTo</b> that takes a parameter of the generic type
    <b>T</b> and returns an <b>int</b>.
    Note that there is no <b>public</b> or <b>private</b>
    access modifier on the method definition.  This is because access
    modifiers are disallowed within interfaces - all definitions
    are implicitly <b>public</b>.  Note also that there is no actual
    definition of the <b>CompareTo</b> method, but only a header
    followed by a semicolon.  Definitions of method bodies are also
    disallowed within interfaces - an interface doesn't
    define the behavior of a method, but only how it should be used
    (i.e., its parameter list and return type).  For this reason, it
    is impossible to construct an instance of an interface
    directly.  Instead, one or more sub-types of the interface
    must be defined, and these sub-types must provide definitions for
    the behavior of <b>CompareTo</b>.  As a result, because the
    <b>Dictionary&lt;TKey, TValue&gt;</b> class restricts type
    <b>TKey</b> to be a sub-type of <b>IComparable&lt;T&gt;</b>, its
    can use the 
    <b>CompareTo</b> method of any instance of type <b>TKey</b>. 
<p>
Now suppose that we want to define a class <b>Fraction</b> and use it
      as a key in our dictionary implementation.  We would begin
      the class definition within Visual Studio® as follows:
</p>
<img alt="Beginning an interface" src="interface-example1.jpg"/>
<p>
At the end of the first line of the <b>class</b> definition, "<tt>:
    IComparable&lt;Fraction&gt;</tt>" indicates that the class being
    defined is a 
    subtype of <b>IComparable&lt;Fraction&gt;</b>.  In general, we can
    list one or 
    more interface names after the colon, separating these names with
    commas.  Each name that we list requires that all of the methods,
    properties, and <a href="/~rhowell/DataStructures/redirect/indexers">indexers</a>
    from that interface must be fully defined within this class.  If
    we hover the mouse over the word, "IComparable&lt;Fraction&gt;", a
    drop-down menu appears.  By selecting "Implement interface" from
    this menu, all of the required members of the interface are
    provided for us:
</p>
<img alt="Interface members are auto-filled" src="interface-example2.jpg"/>
<p>
Note that in order to implement a method specified in an interface, we
    must define it as <b>public</b>.  We now just need to replace the
    <b>throw</b> with the proper code for the <b>CompareTo</b> method
    and fill in any other class members that we need; for example:
</p>
<pre>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Ksu.Cis300.Fractions
{
    /// &lt;summary&gt;
    /// An immutable fraction whose instances can be ordered.
    /// &lt;/summary&gt;
    public class Fraction : IComparable&lt;Fraction&gt;
    {
        /// &lt;summary&gt;
        /// Gets the numerator.
        /// &lt;/summary&gt;
        public int Numerator { get; }

        /// &lt;summary&gt;
        /// Gets the denominator.
        /// &lt;/summary&gt;
        public int Denominator { get; }

        /// &lt;summary&gt;
        /// Constructs a new fraction with the given numerator and denominator.
        /// &lt;/summary&gt;
        /// &lt;param name="numerator"&gt;The numerator.&lt;/param&gt;
        /// &lt;param name="denominator"&gt;The denominator.&lt;/param&gt;
        public Fraction(int numerator, int denominator)
        {
            if (denominator &lt;= 0)
            {
                throw new ArgumentException();
            }
            Numerator = numerator;
            Denominator = denominator;
        }

        /// &lt;summary&gt;
        /// Compares this fraction with the given fraction.
        /// &lt;/summary&gt;
        /// &lt;param name="other"&gt;The fraction to compare to.&lt;/param&gt;
        /// &lt;returns&gt;A negative value if this fraction is less
        /// than other, 0 if they are equal, or a positive value if this
        /// fraction is greater than other.&lt;/returns&gt;
        public int CompareTo(Fraction other)
        {
            long prod1 = (long)Numerator * other.Denominator;
            long prod2 = (long)other.Numerator * Denominator;
            return prod1.CompareTo(prod2);
        }

        // Other class members
    }
}
    </pre>
    Note that the <b>CompareTo</b> method above is <i>not</i>
    recursive. The <b>CompareTo</b> method that it calls is a member
    of the <b>long</b> structure, not the <b>Fraction</b> class.
    <p></p>
As we suggested above, interfaces can also include properties.  For
      example, <a href="http://msdn.microsoft.com/en-us/library/92t2ye13(v=vs.110).aspx"><b>ICollection&lt;T&gt;</b></a>
      is a generic interface implemented by both arrays and the class
      <a href="http://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx"><b>List&lt;T&gt;</b></a>.
      This interface contains the following member (among others):
<pre>
int Count { get; }
</pre>
This member specifies that every subclass must contain a property
    called <b>Count</b> with a getter.  At first, it would appear that
    an array does not have such a property, as we cannot write
    something like:
<pre>
int[] a = new int[10];
int k = a.Count;  // This gives a syntax error.
</pre>
<a name="explicit-impl"></a>
In fact, an array does contain a <b>Count</b> property, but this
    property is available only when the array is treated as an
    <b>ICollection&lt;T&gt;</b> (or an <a href="http://msdn.microsoft.com/en-us/library/5y536ey6.aspx"><b>IList&lt;T&gt;</b></a>,
    which is an interface that is a subtype of
    <b>ICollection&lt;T&gt;</b>, and is also implemented by arrays).
    For example, we can write:
<pre>
int[] a = new int[10];
ICollection&lt;int&gt; col = a;
int k = col.Count;
</pre>
or
<pre>
int[] a = new int[10];
int k = ((ICollection&lt;int&gt;)a).Count;
</pre>
This behavior occurs because an array <i>explicitly implements</i> the
    <b>Count</b> property.  We can do this as follows:
<pre>
public class ExplicitImplementationExample&lt;T&gt; : ICollection&lt;T&gt;
{
    int ICollection&lt;T&gt;.Count
    {
        get
        {
            // Code to return the proper value
        }
    }

    // Other class members
}
</pre>
Thus, if we create an instance of
    <b>ExplicitImplementationExample&lt;T&gt;</b>, we cannot access
    its <b>Count</b> property unless we either store it in a variable
    of type <b>ICollection&lt;T&gt;</b> or cast it to this type.  Note
    that whereas the <b>public</b> access modifier is required when
    implementing an interface member, neither the <b>public</b> nor
    the <b>private</b> access modifier is allowed when
    <i>explicitly</i> implementing an interface member.
<p>
We can also include <a href="/~rhowell/DataStructures/redirect/indexers">indexers</a>
    within interfaces.  For example, the <b>IList&lt;T&gt;</b>
    interface is defined as follows:
<pre>
public interface IList&lt;T&gt; : ICollection&lt;T&gt;
{
    T this[int index] { get; set; }

    int IndexOf(T item);

    void Insert(int index, T item);

    void RemoveAt(int index);
}
</pre>
The "<tt>: ICollection&lt;T&gt;</tt>" at the end of the first line
    specifies that <b>IList&lt;T&gt;</b> is a subtype of
    <b>ICollection&lt;T&gt;</b>; thus, the interface includes all
    members of <b>ICollection&lt;T&gt;</b>, plus the ones listed.
    The first member listed above specifies an indexer with a
    getter and a setter.
<p>
Now that we have seen a little of what interfaces are all about, let's
      see how we can use them to provide three different
      implementations of trie nodes.  We first need to define an
      interface, which we will call <b>ITrie</b>, specifying the two
      <b>public</b> members of <a href="/~rhowell/DataStructures/redirect/tries-intro">our
      previous implementation of a trie node</a>.  We do, however,
      need to make one change to the way the <b>Add</b> method is
      called.  This change is needed because when we add a
      <b>string</b> to a trie, we may need to change the
      implementation of the root node.  We can't simply change the
      type of an object - instead, we'll need to construct a new
      instance of the appropriate implementation.  Hence, the
      <b>Add</b> method will need to return the root of the resulting
      trie.  Because this node may have any of the three
      implementations, the return type of this method should be
      <b>ITrie</b>.  The <b>ITrie</b> interface is therefore as
      follows:
</p>
<pre>
/// &lt;summary&gt;
/// An interface for a trie.
/// &lt;/summary&gt;
public interface ITrie
{
    /// &lt;summary&gt;
    /// Determines whether this trie contains the given string.
    /// &lt;/summary&gt;
    /// &lt;param name="s"&gt;The string to look for.&lt;/param&gt;
    /// &lt;returns&gt;Whether this trie contains s.&lt;/returns&gt;
    bool Contains(string s);

    /// &lt;summary&gt;
    /// Adds the given string to this trie.
    /// &lt;/summary&gt;
    /// &lt;param name="s"&gt;The string to add.&lt;/param&gt;
    /// &lt;returns&gt;The resulting trie.&lt;/returns&gt;
    ITrie Add(string s);
}
</pre>
We will then need to define three classes, each of which implements
    the above interface.  We will use the following names for these
    classes:
<ul>
<li> <b>TrieWithNoChildren</b>
    will be used for nodes
    with no children. </li>
<li> <b>TrieWithOneChild</b> will be used for nodes with exactly
    one child. </li>
<li> <b>TrieWithManyChildren</b> will be used for all other nodes; this
    will be the class described in <a href="/~rhowell/DataStructures/redirect/tries-intro">the previous
    section</a> with a few modifications. </li>
</ul>
These three classes will be similar because they each will implement
    the <b>ITrie</b> interface.  This implies that they will each need
    a <b>Contains</b> method and an <b>Add</b> method as specified by
    the interface definition.  However, the code for each of these
    methods will be different, as will other aspects of the
    implementations.  For example, the <b>TrieWithNoChildren</b> and
    <b>TrieWithOneChild</b> classes need <b>private</b> fields as
    described at the beginning of this section, whereas the
    <b>TrieWithManyChildren</b> classes needs the same <b>private</b>
    fields as outlined in <a href="/~rhowell/DataStructures/redirect/tries-intro">the previous
    section</a>.  In each case, whenever we need to refer to a trie,
    we will use the type <b>ITrie</b>.
<p>
The <b>Add</b> methods for both <b>TrieWithNoChildren</b> and
      <b>TrieWithOneChild</b> will need to be able to construct instances
      of <b>TrieWithOneChild</b> and <b>TrieWithManyChildren</b>,
      respectively, when they have no room for the <b>string</b> being
      added.  The instances they will need to construct will need
      information regarding the <b>string</b>s already being stored,
      plus the <b>string</b> being added;
      hence, we will need to define constructors for both
      <b>TrieWithOneChild</b> and <b>TrieWithManyChildren</b>.  Each of these
      constructors will need to take the <b>string</b> being added as
      one of its parameters.  Because the
      instance being constructed also needs to retain all of the
      information stored in the implementation that calls it, additional
      parameters for each of these constructors will correspond to the
      <b>private</b> fields of the implementation that will need to
      call it.
</p>
Thus, the parameters for the <b>TrieWithOneChild</b> constructor will be a
    <b>string</b> to be stored (i.e., the one being added) and a
    <b>bool</b> indicating whether the 
    empty <b>string</b> is also to be stored (i.e., because it was
    stored in the original <b>TrieWithNoChildren</b>).
    Furthermore, because the empty <b>string</b> can always be added
    to a <b>TrieWithNoChildren</b> without constructing a new node, this
    constructor should never be passed 
    the empty <b>string</b>.  The constructor can then operate as
    follows:
<ul>
<li> If the given <b>string</b> is empty or begins with a character
	that is not a lower-case English letter, throw an exception.
	</li>
<li> Initialize the <b>bool</b> field with the given
	<b>bool</b>. </li>
<li> Initialize the <b>char</b> field with the first character of the
	given <b>string</b>. </li>
<li> Initialize the <b>ITrie</b> field with the result of constructing
	a new <b>TrieWithNoChildren</b> and adding to it the substring of the
	given <b>string</b> following the first character.  </li>
</ul>
The parameters for the <b>TrieWithManyChildren</b> constructor will need
    to be a <b>string</b> to be stored (i.e., the one being added), a
    <b>bool</b> indicating 
    whether the empty <b>string</b> is to be stored, a <b>char</b>
    giving the label of a child, and an <b>ITrie</b> giving a child
    (these last three parameters will come from the original
    <b>TrieWithOneChild</b>). 
    It can use the last three parameters to initialize its <b>bool</b>
    field and one of its children (computing the child's index as in <a href="/~rhowell/DataStructures/redirect/tries-intro">the previous
    section</a>).  It can then use its own <b>Add</b> method to add
    the given <b>string</b>, as there will always be room to add a
    <b>string</b> to this implementation; hence, it can ignore the
    value returned by the <b>Add</b> method.  Furthermore, because the
    <b>Add</b> method does error checking on the given <b>string</b>,
    the only error checking this constructor needs to do is on the
    given <b>char</b>, to verify that it is a lower-case English letter.
<p>
The <b>Contains</b> method for <b>TrieWithManyChildren</b> can be exactly
      the same as for the implementation in <a href="/~rhowell/DataStructures/redirect/tries-intro">the
      previous section</a>.  For the other two classes, the structure
      of the method is similar.  Specifically, the empty <b>string</b>
      needs to be handled first and in exactly the same way, as the
      empty <b>string</b> is represented in the same way in all three
      implementations.  Nonempty <b>string</b>s, however, are
      represented differently, and hence need to be handled
      differently.  This is easy for the <b>TrieWithNoChildren</b> class,
      as this implementation can't store a nonempty <b>string</b>;
      hence, its <b>Contains</b> method should simply return
      <b>false</b> in this case.  For <b>TrieWithOneChild</b>, we need to
      check to see if the first character of the given <b>string</b>
      matches the child's label.  If so, we can recursively look for
      the remainder of the <b>string</b> in that child.  Otherwise, we
      should simply return <b>false</b>, as this <b>string</b> is not
      in this trie.
</p>
The <b>Add</b> method for <b>TrieWithManyChildren</b> needs some
    modification from the description given in <a href="/~rhowell/DataStructures/redirect/tries-intro">the previous
    section</a>.  First, the method must return the resulting trie,
    which will always be <b>this</b>, as this implementation never
    needs to be replaced by another to accommodate a new
    <b>string</b>.  The only other change that needs to be made is
    where a new child is constructed - this new child should be a
    <b>TrieWithNoChildren</b>.
<p>
The <b>Add</b> method for <b>TrieWithNoChildren</b> will need to handle
      the empty <b>string</b> in the same way as the above <b>Add</b>
      method.  However, this implementation cannot store a nonempty
      <b>string</b>.  In this case, it will need to construct and
      return a new <b>TrieWithOneChild</b> containing the <b>string</b> to
      be added and the <b>bool</b> stored in this node.
</p>
The <b>Add</b> method for <b>TrieWithOneChild</b> will need three cases:
<ul>
<li> The empty <b>string</b>:  This case can be handled in the same
	way as for the other two classes. </li>
<li> A nonempty <b>string</b> whose first character matches the child's
	label:  The remainder of the <b>string</b> can be added to the
	child using the child's <b>Add</b> method.  Because this
	method may return a different node, we need to replace the
	child with the value this method returns.  We can then return
	<b>this</b>, as we didn't need more room for the given
	<b>string</b>. </li>
<li> A nonempty <b>string</b> whose first character does not match the
	child's label.  In this case, we need to return a new
	<b>TrieWithManyChildren</b> containing the given <b>string</b> and
	all of the information already being stored. </li>
</ul>
Code that uses such a trie will need to refer to it as an <b>ITrie</b>
    whenever possible.  The only exception to this rule occurs when we
    are constructing a new trie, as we cannot construct an instance of
    an interface.  Here, we want to construct the simplest
    implementation - a <b>TrieWithNoChildren</b>.  Otherwise, the only
    difference in usage as compared to the implementation of <a href="/~rhowell/DataStructures/redirect/tries-intro">the previous
    section</a> is that the <b>Add</b> method now returns the
    resulting trie, whose root may be a different object; hence, we
    will need to be sure to replace the current trie with whatever the
    <b>Add</b> method returns.


<p></p>
<p>
</p>
<p>
</p>
<p></p>
</p></p></p></body>
</html>
