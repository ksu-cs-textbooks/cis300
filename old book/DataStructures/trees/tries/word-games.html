<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Tries in Word Games</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Tries in Word Games</h1>

One application of tries is for implementing word games such as
    Boggle® or Scrabble®.  This section discusses how a trie can be
    used to reduce dramatically the amount of time spent searching for
    words in such games.  We will focus specifically on Boggle, but
    the same principles apply to other word games as well.
<p>
A Boggle game consists of either 16 or 25 dice with letters on their
      faces, along with a tray containing a 4 x 4 or
      5 x 5 grid for holding these dice.  The face of each
      die contains a single letter, except that one face of one die
      contains "Qu".  The tray has a large cover such that the dice can
      be placed in the cover and the tray placed upside-down on top of
      the cover.  The whole thing can then be shaken, then inverted so
      that each die ends up in a different grid cell, forming a random
      game board such as:
</p>
<img alt="A Boggle game board" src="boggle.jpg"/>
<p>
Players are then given a certain amount of time during which they
      compete to try to form as many unique words as they can from
      these letters.  The letters of a word must be adjacent either
      horizontally, vertically, or diagonally, and no die may be used
      more than once in a single word.  There is a minimum word
      length, and longer words are worth more points.  For example,
      the above game board contains the words, "WITCH", "ITCH",
      "PELLET", "TELL", and "DATA", among many others.
</p>
<img alt="Words on a Boggle game board" src="boggle2.jpg"/>
<p>
Suppose we want to build a program that plays Boggle against a human
      opponent.  The program would need to look for words on a given
      board.  The dictionary of words can of course be stored in a
      trie.  In what follows, we will show how the structure of a trie
      can be particularly helpful in guiding this search so that words
      are found more quickly.
</p>
We can think of a search from a given starting point as a traversal of
    a tree.  The root of the tree is the starting point, and its
    children are searches starting from adjacent dice.  We must be
    careful, however, to include in such a tree only those adjacent
    dice that do not already occur on the path to the given die.  For
    example, if we start a search at the upper-left corner of the
    above board, its children would be the three adjacent dice
    containing "I", "C", and "A".  The children of "I", then, would not
    include "H" because it is already on the path to "I".  
    Part of this tree would look like this:
<p>
<img alt="A part of a tree representing a Boggle search space" src="boggle-tree.jpg"/>
</p>
Note that this tree is not a data structure - it need not be
    explicitly stored anywhere.  Rather, it is a mathematical object
    that helps us to design an algorithm for finding all of the
    words.  Each word on the board is simply a path in this tree
    starting from the root.  We can therefore traverse this tree in
    much the same way as we outlined in <a href="/~rhowell/DataStructures/redirect/traversing-tries">the
    previous section</a> for tries.  For each node in the tree, we can
    look up the path leading to that node, and output it if it is a
    word in the dictionary.
<p>
In order to be able to implement such a traversal, we need to be able
      to find the children of a node.  These children are the adjacent
      cells that are not used in the path to the node.  An efficient
      way to keep track of the cells used in this path is with a
      <b>bool[ , ]</b> of the same size as the Boggle board
      - a value of <b>true</b> in this array will indicate that the
      corresponding cell on the board has been used in the current
      path.  The children of a node are then the adjacent cells
      whose entries in this array are <b>false</b>.
</p>
A preorder traversal of this tree will therefore need the following
    parameters (and possibly others, depending on how we want to
    output the words found):
<ul>
<li> The row index of the current cell. </li>
<li> The column index of the current cell. </li>
<li> The <b>bool[ , ]</b> described above.  The current cell
	will have a <b>false</b> entry in this array. </li>
<li> A <b>StringBuilder</b> giving the letters on the path up to, but
	  not including, the current cell. </li>
</ul>
<p>
The preorder traversal will first need to update the cells used by
      setting the location corresponding to the current cell to
      <b>true</b>.  Likewise, it will need to update the
      <b>StringBuilder</b> by appending the contents of the current
      cell.  Then it will need to process the root by looking up the
      contents of the <b>StringBuilder</b> - if this forms a word, it
      should output this word.  Then it should process the children:
      for each adjacent cell whose 
      entry in the <b>bool[ , ]</b> is <b>false</b>, it
      should make a recursive call on that cell.  After all the
      children have been processed, it will need to return the
      <b>bool[ , ]</b> and the <b>StringBuilder</b> to their
      earlier states by setting the array entry back to <b>false</b>
      and removing the character(s) appended earlier.
</p>
Once such a method is written, we can call it once for each cell on
    the board.  For each of these calls, all entries in the
    <b>bool[ , ]</b> should be false, and the
    <b>StringBuilder</b> should be empty.
<p>
While the algorithm described above will find all the words on a
      Boggle board, a 5 x 5 board will require quite a while
      for the algorithm to process.  While this might be acceptable if
      we are implementing a game that humans can compete with, from an
      algorithmic standpoint, we would like to improve the
      performance.  (In fact, there are probably better ways to make a
      program with which humans can compete, as this search will only
      find words that begin near the top of the board.)
</p>
We can begin to see how to improve the performance if we observe the
    similarity between the trees we have been discussing and a trie
    containing the word list.  Consider, for example, a portion of the
    child labeled 'h' in a trie representing a large set of words:
<p>
<img alt="A portion of a trie." src="trie-portion.jpg"/>
</p>
We have omitted some of the children because they are irrelevant to
    the search we are performing (e.g., there is no die containing "E"
    adjacent to "H" on the above game board).  Also, we are assuming a
    minimum word length of 4; hence, "ha", "hi", and "hit" are not
    shown as words in this trie.
<p>
Notice the similarity between the trie portion shown above and the
      tree shown earlier.  The root of the tree has children
      representing dice containing "I" and "A", and the former node
      has children representing dice containing "T", "C", and "A";
      likewise, though they are listed in a different order, the trie
      has children labeled 'i' and 'a', and the former node has
      children labeled 't', 'c', and 'a'.
</p>
What is more important to our discussion, however, is that the trie
    does not have a child labeled 'c', as there is no English word
    beginning with "hc".  Similarly, the child labeled 'i' does not
    have a child labeled 'i', as there is no English word beginning
    with "hii".  If there are no words in the word list beginning with
    these prefixes, there is no need to search the subtrees rooted at
    the corresponding nodes when doing the preorder traversal.  Using
    the trie to prune the search in this way ends up avoiding many
    subtrees that don't lead to any words.  As a result, only a small
    fraction of the original tree is searched.
<p>
In order to take advantage of the trie in this way, we need a method
      in the trie implementation to return the child having a given
      label, or <b>null</b> if there is no such child.  Alternatively,
      we might provide a method that takes a <b>string</b> and returns
      the trie that this <b>string</b> leads to, or <b>null</b> if
      there is no such trie (this method would make it easier to
      handle the die containing "Qu").  Either way, we can then
      traverse the trie as we are doing the preorder traversal
      described above, and avoid searching a subtree whenever the trie
      becomes null.
<p>
This revised preorder traversal needs an extra parameter - a trie
      giving all completions of words beginning with the prefix given
      by the <b>StringBuilder</b> parameter.  We will need to ensure
      that this parameter is never <b>null</b>.  The algorithm then
      proceeds as follows:
</p>
<ul>
<li> From the given trie, get the subtrie containing the completions of
	words beginning with the contents of the current cell.
<li> If this subtrie is not <b>null</b>:
<ul>
<li> Set the location in the <b>bool[ , ]</b> corresponding
	    to the current cell to <b>true</b>. </li>
<li> Append the contents of the current cell to the
	    <b>StringBuilder</b>. </li>
<li> If the subtrie obtained above contains the empty <b>string</b>,
	    output the contents 
	    of the <b>StringBuilder</b> as a word found. </li>
<li> Recursively traverse each adjacent cell whose corresponding entry
	    in the <b>bool[ , ]</b> is <b>false</b>.  The
	    recursive calls should use the subtrie obtained
	    above. </li>
<li> Set the location in the <b>bool[ , ]</b> corresponding
	    to the current cell to <b>false</b>. </li>
<li> Remove the contents of the current cell from the end of the
	    <b>StringBuilder</b> (i.e., decrease its <b>Length</b> by
	    the appropriate amount). </li>
</ul>
</li>
</li></ul>
We would then apply the above algorithm to each cell on the board.
    For each cell, we would use a <b>bool[ , ]</b> whose
    entries are all <b>false</b>, an empty <b>StringBuilder</b>, and
    the entire trie.  Note that we have designed the preorder
    traversal so that it leaves each of these parameters unchanged;
    hence, we only need to initialize them once.  The resulting search
    will find all of the words on the board quickly.

<p></p>
<p></p>
<p></p>
<p>
</p>
<p></p>
</p></body>
</html>
