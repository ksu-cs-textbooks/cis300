<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Introduction to Binary Search Trees</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/bst-remove">Next: Removing
      from a Binary Search Tree
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-trees">Previous:
      Binary Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-search-trees">Up:
      Binary Search Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Introduction to Binary Search Trees</h1>

<p>
In this section and <a
    href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/bst-remove">the
    next</a>, we will present a binary search tree as a data
    structure that can be used to implement a <a
    href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/dictionary-class">dictionary</a>
    whose key
    type can be ordered.  This implementation will provide efficient
    lookups, insertions, and deletions in most cases; however, there
    will be cases in which the performance is bad.  In <a
    href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/avl-trees">a
    later section</a>, we will show how to extend this good
    performance to all cases.
</p>
A <i>binary search tree</i> is a <a
      href="/~rhowell/DataStructures/redirect/binary-trees">binary
      tree</a> containing key-value pairs whose keys can be ordered.
      Furthermore, the data items are arranged such that the key in
      each node is:
<ul>
<li> greater than all the keys in its left child; and</li>
<li> less than all the keys in its right child.</li>
</ul>
Note that this implies that all keys must be unique.
For example, the following is a binary search tree storing integer
    keys (only the keys are shown):
<p>
<img src="binary-search-tree-ex.jpg" alt="A binary search tree">
</p>
The hierarchical nature of this structure allows us to do something
    like a binary search to find a key.  Suppose, for example, that we
    are looking for 41 in the above tree.  We first compare 41 with
    the key in the root.  Because 41&nbsp;&lt;&nbsp;54, we can safely
    ignore the right child, as all keys there must be greater than 54.
    We therefore compare 41 to the key in the root of the left child.
    Because 41&nbsp;&gt;&nbsp;23, we look in the right child, and
    compare 41 to 35.  Because 41&nbsp;&gt;&nbsp;35, we look in the
    right child, where we find the key we are looking for.
<p>
Note the similarity of the search described above to a binary search.
It isn't exactly the same, because there is no guarantee that the root
is the middle element in the tree - in fact, it could be the first
or the last.  In many applications, however, when we build a
binary search tree as we will describe below, the root of the tree
tends to be roughly the middle element.  When this is the case,
looking up a key is very
efficient.  <a href="/~rhowell/DataStructures/redirect/avl-trees">Later</a>,
we will show how we can build and maintain a binary search tree so
that this is always the case.
</p>
It isn't hard to implement the search strategy outlined above using a
loop.  However, in order to reinforce the concept of recursion as a
tree processing technique, let's consider how we would implement the
search using recursion.  The algorithm breaks into four cases:
<ul>
<li> The tree is empty.  In this case, the element we are looking for
  is not present. </li>
<li> The key we are looking for is at the root - we have found
  what we are looking for. </li>
<li> The key we are looking for is less than the key at the
  root.  We then need to look for the given key in the left child.
  Because this is a smaller instance of our original problem, we
  can solve it using a recursive call. </li>
<li> The key we are looking for is greater than the key at the
  root.  We then look in the right child using a recursive call. </li>
</ul>
It is important to handle the case of an empty tree first, as the
    other cases don't make sense if the tree is empty. In fact, if we
    are using <b>null</b> to represent an empty binary search tree (as
    is fairly common), we will get a <b>NullReferenceException</b> if
    we try to compare a given key with the key at the root.
    Furthermore, if we
    need to compare elements using a <a
    href="http://msdn.microsoft.com/en-us/library/43hc6wht.aspx"><b>CompareTo</b></a>
    method, it would be more efficient to structure the code so that
    this method is only called once; e.g.,
<ul>
<li> If the tree is empty&nbsp;.&nbsp;.&nbsp;.&nbsp;.</li>
<li> Otherwise:
<ul>
<li> Get the result of the comparison. </li>
<li> If the result is 0&nbsp;.&nbsp;.&nbsp;.&nbsp;. </li>
<li> Otherwise, if the result is
  negative&nbsp;.&nbsp;.&nbsp;.&nbsp;. </li>
<li> Otherwise&nbsp;.&nbsp;.&nbsp;.&nbsp;. </li>
</ul>
</li>
</ul>
This method would need to take two parameters - the key we are looking
for and the tree we are looking in.  This second parameter will
actually be a reference to a node, which will either be the root of
the tree or <b>null</b> if the tree is empty.  Because this method requires
    a parameter that is not provided to the <b>TryGetValue</b> method,
    this method would be a 
    <b>private</b> method that the <b>TryGetValue</b> method can call.  This
    <b>private</b> method would then return the node
    containing the key, or <b>null</b> if this key was not found.  The
    <b>TryGetValue</b> method can be implemented easily using this
    <b>private</b> method.

<p></p>
We also need to be able to implement the <b>Add</b> method.  Let's
    first consider how to do this assuming we 
are representing our binary search tree with immutable nodes.  The
first thing to observe is that because we can't modify an immutable
node, we will need to build a binary search tree containing the nodes
    in the current tree, plus a new node containing the new key and
    value.  In order to accomplish this, we will describe a
    <b>private</b> recursive method that returns the result of adding
    a given key and value to a given binary search tree.  The
    <b>Add</b> method will then need to call this <b>private</b>
    method and save the resulting tree.
    <p></p>
    We
therefore want to design a <b>private</b> method that will take three
    parameters: 
<ul>
<li> a binary search tree (i.e., reference to a node);  </li>
      <li> the key we want to add; and
      </li>
    <li> the value we want to add.</li>
</ul>
It will return the binary search tree that results from adding the
    given key and value to the given
tree.
<p>
This method again has four cases:
<ul>
<li> The tree is empty.  In this case, we need to construct a node
  containing the given key and value and two empty children, and return
  this node as the resulting tree. </li>
<li> The root of the tree contains a key equal to
  the given key.
  In this case, we can't add the item - we need to throw an exception.  </li>
<li> The given key is less than the key at the root.  We can
  then use 
  a recursive call to add the given key and value to the left child.  The tree
  returned by the recursive call needs to be the left child of the
  result to be returned by the method.  We therefore construct a new
  node containing the 
  data and right child from the given tree, but having the result of
  the recursive call as 
  its left child.  We return this new node. </li>
<li> The given key is greater than the key at the root.  We
  use a 
  recursive call to add it to the right child, and construct a new
  node with the result of the recursive call as its right child.  We
  return this new 
  node. </li>
</ul>
Note that the above algorithm only adds the given data item when it
    reaches an empty tree.  Not only is this the most straightforward
    way to add items, but it also tends to keep paths in the tree
    short, as each insertion is only lengthening one path.  <a
    href="/~rhowell/viewer/index.html">This page</a> contains an
    application that will show the result of adding a key at a time to
    a binary search tree.  The keys in this application are treated as
    strings; hence, you can use numbers if you want, but they will be
    compared as strings (e.g., "10"&nbsp;&lt;&nbsp;"5" because
    '1'&nbsp;&lt;&nbsp;'5').  For this reason, it is usually better to
    use either letters, words, or integers that all have the same
    number of digits.
<p>
The above algorithm can be implemented in the same way if mutable
      binary tree nodes are used; however, we can improve its
      performance a bit by avoiding the construction of new nodes when
      recursive calls are made.  Instead, we can change the child to
      refer to the tree returned.  If we make this optimization, the
      tree we return will be the same one that we were given in the
      cases that make recursive calls.  However, we still need to
      construct a new node in the case in which the tree is empty.
      For this reason, it is still necessary to return the resulting
      tree, and we need to make sure that the
      <b>Add</b> method always uses the returned tree.
</p>

<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/bst-remove">Next: Removing
      from a Binary Search Tree
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-trees">Previous:
      Binary Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-search-trees">Up:
      Binary Search Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Mon Feb 26 07:24:59 CST 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
