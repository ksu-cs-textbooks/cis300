<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>AVL Trees</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/tries">Next: Tries
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-search-trees">Previous:
      Binary Search Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/trees">Up: Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>AVL Trees</h1>

Up to this point, we haven't addressed the performance of binary
    search trees.  In considering this performance, let's assume that
    the time needed to compare two keys is bounded by some fixed
    constant.  The main reason we do this is that this cost doesn't
    depend on the number of keys in the tree; however, it may depend
    on the sizes of the keys, as, for example, if keys are
    <b>string</b>s.  However, we will ignore this complication for the
    purpose of this discussion.
<p>
Each of the methods we have described for finding a key, adding a key
      and a value, or removing a key and its associated value, follows
      a single path in the given 
      tree.  As a result, the time needed for each of these methods is
      at worst proportional to the <i>height</i> of the tree, where
      the height is defined to be the length of the longest path from
      the root to any node.  (Thus, the height of a one-node tree is
      0, because no steps are needed to get from the root to the only
      node - the root itself - and the height of a two-node tree is
      always 1.)  In other words, we say that the worst-case running
      time of each of these methods is in <i>O</i>(<i>h</i>), where
      <i>h</i> is the height of the tree.
</p>
Depending on the shape of the tree, <i>O</i>(<i>h</i>) running time
    might be very good.  For example, it is possible to show that if
    keys are randomly taken from a uniform distribution and
    successively added to an initially empty binary search tree, the
    expected height is in <i>O</i>(log&nbsp;<i>n</i>), where <i>n</i>
    is the number of nodes.  In this case, we would expect logarithmic
    performance for lookups, insertions, and deletions.  In fact,
    there are many applications in which the height of a binary search
    tree remains fairly small in comparison to the number of nodes.
<p>
On the other hand, such a shape is by no means guaranteed.  For
      example, suppose a binary search tree were built by adding the
      <b>int</b> keys 1 through <i>n</i>
      in increasing order.  Then 1 would go at the
      root, and 2 would be its right child.  Each
      successive key would then be larger than any key currently in
      the tree, and hence would be added as the right child of the
      last node on the path going to the right.  As a result, the tree
      would have the following shape:
</p>
<img src="bst-chain.jpg" alt="A badly-shaped binary search tree">
<p>
The height of this tree is <i>n</i>&nbsp;-&nbsp;1; consequently,
      lookups will take time linear in <i>n</i>, the number of
      elements, in the worst case.  This performance is comparable with
      that of a linked list.  In order to guaranteed good performance,
      we need a way to ensure that the height of a binary search tree
      does not grow too quickly.
</p>
One way to accomplish this is to require that each node always has
    children that differ in height by at most 1.  In order for this
    restriction to make sense, we need to extend the definition of the
    height of a tree to apply to an empty tree.  Because the height of
    a one-node tree is 0, we will define the height of an empty tree
    to be -1.  We call this restricted form of a binary search tree
    an <i>AVL tree</i> ("AVL" stands for the names of the inventors,
    Adelson-Velskii and Landis).
<p>
<a href="http://people.cis.ksu.edu/~rhowell/viewer/minAVL.html">This
	page</a> contains a Java applet/application that displays an
	AVL tree of a given height using as few nodes as possible.
	For example, the following screen capture shows an AVL tree of
	height 8 having a minimum number of nodes:
</p>
<img src="min-avl.jpg" 
    alt="An AVL tree with height 8 and minimum number of nodes">
<p>
As the above picture illustrates, a minimum of 88 nodes are required
      for an AVL tree to reach a height of 8.  In general, it can be
      shown that the height of an AVL tree is at worst proportional to
      log&nbsp;<i>n</i>, where <i>n</i> is the number of nodes in the
      tree.  Thus, if we can maintain the shape of an AVL tree
      efficiently, we should have efficient lookups and updates.
</p>
Regarding the AVL tree shown above, notice that the tree is not as
    well-balanced as it could be.  For example, 0 is at depth 8,
    whereas 87, which also has two empty children, is only at depth 4.
    Furthermore, it is possible to arrange 88 nodes into a binary tree
    with height as small as 6.  However, maintaining a more-balanced
    structure would likely require more work, and as a result, the
    overall performance might not be as good.  As we will show in what
    follows, the balance criterion for an AVL tree can be maintained
    without a great deal of overhead.
<p>
The first thing we should consider is how we can efficiently determine
      the height of a binary tree.  We don't want to have to explore
      the entire tree to find the longest path from the root - this
      would be way too expensive.  Instead, we store the height of a
      tree as a <b>private</b> field in its root.  If our nodes are
      mutable, we would also need to provide a <b>public</b> property
      to give read/write access to this field.  However, such a setup
      places the burden of maintaining the heights on the user of the
      binary tree node class.  Using immutable nodes allows a much
      cleaner (albeit slightly less efficient) solution.  In what
      follows, we will show how to modify the definition of an
      immutable binary tree node so that whenever a binary tree is
      created from such nodes, the resulting tree is guaranteed to
      satisfy the AVL tree balance criterion.  As a result, user code
      will be able to form AVL trees as if they were ordinary binary
      search trees.
</p>
In order to allow convenient and efficient access to the height, even
for empty trees, we can provide a
    <b>static</b> method to take a binary tree node as its only
    parameter and return its height.  Making this method <b>static</b>
    will allow us to handle empty (i.e., <b>null</b>) trees.  If the
    tree is empty, this method will return -1; otherwise, it will
    return the height stored in the tree.  This method can be
    <b>public</b>.
<p>
We then can modify the constructor so that it initializes the height
      field.  Using the above method, it can find the heights of each
      child, and add 1 to the maximum of these values.  This 
      is the height of the node being constructed.  It can initialize
      the height field to this value, and because the nodes are
      immutable, this field will store the correct height from that
      point on.
</p>
<p>
Now that we have a way to find the height of a tree efficiently, we
      can focus on how we maintain the balance property.  Whenever an
      insertion or deletion would cause the balance property to be
      violated for a particular node, we perform a <i>rotation</i> at
      that node.  Suppose, for example, that we have inserted an
      element into a node's left child, and that this operation causes
      the height of the new left child to be two greater than the
      height of the right child (note that this same scenario could
      have occurred if we had removed an element from the right
      child).  We can then rotate the tree using a <i>single rotate
      right</i>:
</p>
<img src="single-rotate.jpg" alt="A single rotate right">
<p>
The tree on the left above represents the tree whose left child has a
height 2 greater than its right child.  The root and the lines to its
children are drawn using dashes to indicate that the root node has not
yet been constructed - we have at this point simply built a new left
child, and the tree on the left shows the tree that would be formed if
we were building an ordinary binary search tree.  The circles in the
picture indicate individual nodes, and the triangles indicate
arbitrary trees (which may be empty).  Note that the because the left
child has a height 2 greater than the right child, we know that the
left child cannot be empty; hence, we can safely depict it as a node
with two children.  The labels are chosen to indicate the order of the
elements - e.g., as "a"&nbsp;&lt;&nbsp;"b", every key in tree <i>a</i>
is less than the key in node <i>b</i>.  The tree on the right shows
that tree that would be built by performing this rotation.  Note that
the rotation preserves the order of the keys.
</p>
Suppose the name of our class implementing a binary tree node is
    <b>BinaryTreeNode&lt;T&gt;</b>, and suppose it has the following
    properties:
<ul>
<li> <b>Data:</b> gets the data stored in the node. </li>
<li> <b>LeftChild:</b> gets the left child of the node. </li>
<li> <b>RightChild:</b> gets the right child of the node. </li>
</ul>
Then the following code can be used to perform a single rotate right:
<pre>
/// &lt;summary&gt;
/// Builds the result of performing a single rotate right on the binary tree
/// described by the given root, left child, and right child.
/// &lt;/summary&gt;
/// &lt;param name="root"&gt;The data stored in the root of the original tree.&lt;/param&gt;
/// &lt;param name="left"&gt;The left child of the root of the original tree.&lt;/param&gt;
/// &lt;param name="right"&gt;The right child of the root of the original tree.&lt;/param&gt;
/// &lt;returns&gt;The result of performing a single rotate right on the tree described
/// by the parameters.&lt;/returns&gt;
private static BinaryTreeNode&lt;T&gt; SingleRotateRight(T root, BinaryTreeNode&lt;T&gt; left, 
    BinaryTreeNode&lt;T&gt; right)
{
    BinaryTreeNode&lt;T&gt; newRight = new BinaryTreeNode&lt;T&gt;(root, left.RightChild, right);
    return new BinaryTreeNode&lt;T&gt;(left.Data, left.LeftChild, newRight);
}
</pre>
Relating this code to the tree on the left in the picture above, the
    parameter <tt>root</tt> refers to <i>d</i>, the parameter
    <tt>left</tt> refers to the tree rooted at <i>b</i>, and the
    parameter <tt>right</tt> refers to the tree <i>e</i>.  The code
    first constructs the right child of the tree on the right and
    places it in the variable <tt>newRight</tt>.  It then constructs
    the entire tree on the right and returns it.
<p>
Now that we have seen what a single rotate right does and how to code
      it, we need to consider whether it fixes the problem.  Recall
      that we were assuming that the given left child (i.e., the tree
      rooted at <i>b</i> in the tree on the left above) has a height 2
      greater than the given right child (i.e., the tree <i>e</i> in
      the tree on the left above).  Let's suppose the tree <i>e</i>
      has height <i>h</i>.  Then the tree rooted at <i>b</i> has
      height <i>h</i>&nbsp;+&nbsp;2.  By the definition of the height
      of a tree, either <i>a</i> or <i>c</i> (or both) must have height
      <i>h</i>&nbsp;+&nbsp;1.  Assuming that every tree we've built so
      far is an AVL tree, the children of <i>b</i> must differ in
      height by at most 2; hence, <i>a</i> and <i>c</i> must both have
      a height of at least <i>h</i> and at most
      <i>h</i>&nbsp;+&nbsp;1.
</p>
Given these heights, let's examine the tree on the right.  We have
    assumed that every tree we've built up to this point is an AVL
    tree, so we don't need to worry about any balances within
    <i>a</i>, <i>c</i>, or <i>e</i>.  Because <i>c</i> has either
    height <i>h</i> or height <i>h</i>&nbsp;+&nbsp;1 and <i>e</i> has
    height <i>h</i>, the tree rooted at <i>d</i> satisfies the balance
    criterion.  However, if <i>c</i> has height <i>h</i>&nbsp;+&nbsp;1
    and <i>a</i> has height <i>h</i>, then the tree rooted at <i>d</i>
    has height <i>h</i>&nbsp;+&nbsp;2, and the balance criterion is
    <i>not</i> satisfied.  On the other hand, if <i>a</i> has height
    <i>h</i>&nbsp;+1&nbsp;, the tree rooted at <i>d</i> will have a
    height of either <i>h</i>&nbsp;+&nbsp;1 or <i>h</i>&nbsp;+&nbsp;2,
    depending on the height of <i>c</i>.  In these cases, the balance
    criterion is satisfied.
<p>
We therefore conclude that a single rotate right will restore the
      balance if:
<ul>
<li> The height of the original left child (i.e., the tree rooted at
	<i>b</i> in the above figure) is 2 greater than the
	height of the original right child (tree <i>e</i> in the above
	figure); and </li>
<li> The height of the left child of the original left child (tree
	<i>a</i> in the above figure) is
	greater than the height of the original right child (tree
	<i>e</i>). </li> 
</ul>
For the case in which the height of the left child of the original
    left child (tree <i>a</i>) is <i>not</i> greater than the height of
    the original 
    right child (tree <i>e</i>), we will need to use a different kind
    of rotation. 
<p>
Before we consider the other kind of rotation, we can observe that if
      an insertion or deletion leaves the right child with a height 2
      greater than the left child and the right child of the right
      child with a height greater than the left child, the mirror
      image of a single rotate right will restore the balance.  This
      rotation is called a <i>single rotate left</i>:
</p>
<img src="single-rotate-left.jpg" alt="A single rotate left">
<p>
Returning to the case in which the left child has a height 2 greater
      than the right child, but the left child of the left child has a
      height no greater than the right child, we can in this case do a
      <i>double rotate right</i>:
</p>
<img src="double-rotate.jpg" alt="A double rotate right">
<p>
Note that we have drawn the trees a bit differently by showing more
      detail.  Let's now show that this rotation restores the balance
      in this case.  Suppose that in the tree on the left, <i>g</i>
      has height <i>h</i>.  Then the tree rooted at <i>b</i> has
      height <i>h</i>&nbsp;+&nbsp;2.  Because the height of <i>a</i>
      is no greater than the height of <i>g</i>, assuming all trees we
      have built so far are AVL trees, <i>a</i> must have height
      <i>h</i> and the tree rooted at <i>d</i> must have height
      <i>h</i>&nbsp;+&nbsp;1 (thus, it makes sense to draw it as
      having a root node).  This means that <i>c</i> and <i>e</i> both
      must have heights of either <i>h</i> or <i>h</i>&nbsp;-&nbsp;1.
      It is now not hard to verify that the balance criterion is
      satisfied at <i>b</i>, <i>f</i>, and <i>d</i> in the tree on the
      right.
<p>
The only remaining case is the mirror image of the above - i.e., that
      the right child has height 2 greater than the left child, but
      the height of the right child of the right child is no greater
      than the height of the left child.  In this case, a <i>double
      rotate left</i> can be applied:
</p>
<img src="double-rotate-left.jpg" alt="A double rotate left">
<p>
We have shown how to restore the balance whenever the balance
      criterion is violated.  Now we just need to put it all together
      in a <b>public static</b> method that will replace the
      constructor as far as user code is concerned.  In order to
      prevent the user from calling the constructor directly, we also
      need to make the constructor <b>private</b>.  We want this
      <b>static</b> method to take the same parameters as the
      constructor:
</p>
<ul>
<li> The data item that can be stored at the root, provided no
	rotation is required. </li>
<li> The tree that can be used as the left child if no rotation is
	required. </li>
<li> The tree that can be used as the right child if no rotation is
	required. </li>
</ul>
The purpose of this method is to build a tree including all the given
    nodes, with the given data item following all nodes in the left
    child and preceding all nodes in the right child, but satisfying
    the AVL tree balance criterion.  Because this method will be the
    only way for user code to build a tree, we can assume that both of
    the given trees satisfy the AVL balance criterion.  Suppose that
    the name of the <b>static</b> method to get the height of a tree
    is <b>Height</b>, and that the names of the methods to do the
    remaining rotations are <b>SingleRotateLeft</b>,
    <b>DoubleRotateRight</b>, and <b>DoubleRotateLeft</b>,
    respectively.  Further suppose that the parameter lists for each
    of these last three methods are the same as for
    <b>SingleRotateRight</b> above.  The following method can then be
    used to build AVL trees:
<!-- <ul> -->
<!-- <li> If the two given trees differ in height by more than 2, throw an -->
<!-- 	exception, as we can't handle such a case. </li> -->
<!-- <li> If the height of the given left child is 2 greater than the -->
<!-- 	height of the given right child: -->
<!-- <ul> -->
<!-- <li> If the height of the given left child's left child is greater -->
<!-- 	    than the height of the given right child, return the -->
<!-- 	    result of a single rotate right. </li> -->
<!-- <li> Otherwise, return the result of a double rotate right. </li> -->
<!-- </ul> -->
<!-- <li> Otherwise, if the height of the given right child is 2 greater -->
<!-- 	than the height of the given left child: -->
<!-- <ul> -->
<!-- <li> If the height of the given right child's right child is greater -->
<!-- 	    than the height of the given left child, return the result -->
<!-- 	    of a single rotate left. </li> -->
<!-- <li> Otherwise, return the result of a double rotate left. </li> -->
<!-- </ul> -->
<!-- <li> Otherwise, return a new node whose data is the given data, whose -->
<!-- 	left child is the given left child, and whose right child is -->
<!-- 	the given right child. </li> -->
<!-- </ul> -->
<pre>
/// &lt;summary&gt;
/// Constructs an AVL Tree from the given data element and trees. The heights of the 
/// trees must differ by at most two. The tree built will have the same inorder traversal order 
/// as if the data were at the root, left were the left child, and right were the right
/// child.
/// &lt;/summary&gt;
/// &lt;param name="data"&gt;A data item to be stored in the tree.&lt;/param&gt;
/// &lt;param name="left"&gt;An AVL Tree containing elements less than data.&lt;/param&gt;
/// &lt;param name="right"&gt;An AVL Tree containing elements greater than data.&lt;/param&gt;
/// &lt;returns&gt;The AVL Tree constructed.&lt;/returns&gt;
public static BinaryTreeNode&lt;T&gt; GetAvlTree(T data, BinaryTreeNode&lt;T&gt; left,
    BinaryTreeNode&lt;T&gt; right)
{
    int diff = Height(left) - Height(right);
    if (Math.Abs(diff) &gt; 2)
    {
        throw new ArgumentException();
    }
    else if (diff == 2)
    {
        if (Height(left.LeftChild) &gt; Height(right))
        {
            return SingleRotateRight(data, left, right);
        }
        else
        {
            return DoubleRotateRight(data, left, right);
        }
    }
    else if (diff == -2)
    {
        if (Height(right.RightChild) &gt; Height(left))
        {
            return SingleRotateLeft(data, left, right);
        }
        else
        {
            return DoubleRotateLeft(data, left, right);
        }
    }
    else
    {
        return new BinaryTreeNode&lt;T&gt;(data, left, right);
    }
}
</pre>
In order to build and maintain an AVL tree, user code simply needs to
    call the above wherever it would have invoked the
    <b>BinaryTreeNode&lt;T&gt;</b> constructor in building and
    maintaining an ordinary binary search tree.  The extra overhead is
    fairly minimal - each time a new node is constructed, we need to
    check a few heights (which are stored in fields), and if a
    rotation is needed, construct one or two extra nodes.  As a
    result, because the height of an AVL tree is guaranteed to be
    logarithmic in the number of nodes, the worst-case running times
    of both lookups and updates are in <i>O</i>(log&nbsp;<i>n</i>),
    where <i>n</i> is the number of nodes in the tree.

<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/tries">Next: Tries
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/binary-search-trees">Previous:
      Binary Search Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/trees">Up: Trees
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Fri Mar  2 13:17:08 CST 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
