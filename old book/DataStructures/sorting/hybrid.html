<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Hybrid Sorting Algorithms</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/sorting-strings">Next:
      Sorting Strings
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/split-sorts">Previous:
      Split Sorts
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/sorting">Up: Sorting
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Hybrid Sorting Algorithms</h1>

The best versions of <a
      href="/~rhowell/DataStructures/redirect/split-sorts">quick
      sort</a> are competitive with both <a
      href="/~rhowell/DataStructures/redirect/heap-sort">heap sort</a>
      and <a href="/~rhowell/DataStructures/redirect/merge-sorts">merge
      sort</a> on the vast majority of inputs.  However, quick sort
      has a very bad worst case - <i>O</i>(<i>n</i><sup>2</sup>)
      running time and <i>O</i>(<i>n</i>) stack usage.  By
      comparison, both heap sort and merge sort have
      <i>O</i>(<i>n</i>&nbsp;lg&nbsp;<i>n</i>) worst-case running
      time, together with a stack usage of <i>O</i>(1) for heap sort
      or <i>O</i>(lg&nbsp;<i>n</i>) for merge sort.  Furthermore,
      <a
      href="/~rhowell/DataStructures/redirect/insert-sorts">insertion
      sort</a> performs better than any of these algorithms on small
      data sets.  In this section, we look at ways to combine some of
      these algorithms to obtain a sorting algorithm that has the
      advantages of each of them.
<p>
We will start with quick sort, which gives the best performance for
      most inputs.  One way of improving its performance is to make
      use of the fact that <a
      href="/~rhowell/DataStructures/redirect/insert-sorts">insertion
      sort</a> is more efficient for small data sets.  Improving the
      performance on small
      portions can lead to significant performance improvements for
      large arrays because quick sort breaks large arrays into many
      small portions.  Hence, when the portion we are sorting becomes
      small enough, rather than finding a pivot and splitting, we instead call
      insertion sort.
</p>
An alternative to the above improvement is to use the fact that
    insertion sort runs in <i>O</i>(<i>n</i>) time when the number of
    inversions is linear in the number of array elements.  To
    accomplish this, we modify quick sort slightly so that instead of
    sorting the array, it brings each element near where it belongs.
    We will refer to this modified algorithm as a <i>partial sort</i>.
    After we have done the partial sort, we then sort the array using
    insertion sort.  The modification we make to quick sort to obtain
    the partial sort is simply to change
    when we stop sorting.  We only sort portions that are larger
    than some threshold - we leave other portions unsorted.
<p>
Suppose, for example, that we choose a threshold of 10.  Once the
      partial sort reaches an array portion with nine or fewer
      elements, we do nothing with it.  Note, however, that these
      elements are all larger than the elements that precede this
      portion, and they are all smaller than the elements that follow
      this portion; hence, each element can form an inversion with at
      most eight other elements - the other elements in the same
      portion.  Because each inversion contains two elements, this
      means that there can be no more than 4<i>n</i> inversions in the
      entire array once the partial sort finishes.  The
      subsequent call to insertion sort will therefore finish the
      sorting in linear time.
</p>
<p>
Both of the above techniques yield performance improvements over quick
      sort alone.  In fact, for many years, such combinations of an
      optimized version of quick
      sort with insertion sort were so efficient for most inputs that
      they were the most commonly-used algorithms for
      general-purpose sorting. On modern hardware architectures, the
      first approach above tends to give the better 
      performance.
</p>
Nevertheless, neither of the above approaches can guarantee
    <i>O</i>(<i>n</i>&nbsp;lg&nbsp;<i>n</i>) performance - in the
    worst case, they are all still in <i>O</i>(<i>n</i><sup>2</sup>).
    Furthermore, the bad cases still use linear stack space.  To
    overcome these shortfalls, we can put a limit on the depth of
    recursion.  Once this limit is reached, we can finish sorting this
    portion with an <i>O</i>(<i>n</i>&nbsp;lg&nbsp;<i>n</i>) algorithm
    such as <a href="/~rhowell/DataStructures/redirect/heap-sort">heap
    sort</a>.  The idea is to pick a limit that is large enough that
    it is rarely reached, but still small enough that bad cases will
    cause the alternative sort to be invoked before too much time is
    spent.  A limit of about 2&nbsp;lg&nbsp;<i>n</i>, where <i>n</i>
    is the size of the entire array, has been suggested.  Because
    arrays in C# must have fewer than 2<sup>31</sup> elements, this
    value is always less than 62; hence, it is also safe to use a
    constant for the limit.  The resulting algorithm has a worst-case
    running time in
    <i>O</i>(<i>n</i>&nbsp;lg&nbsp;<i>n</i>) and a worst-case stack
    usage of <i>O</i>(lg&nbsp;<i>n</i>).  This logarithmic bound on
    the stack usage is sufficient to avoid a
    <b>StackOverflowException</b>.
<p>
The combination of <a
      href="/~rhowell/DataStructures/redirect/median-of-3">quick sort
      using median-of-three partitioning</a> with
      insertion sort for small portions and heap sort when the
      recursion depth limit is reached is known as <i>introsort</i>
      (short for <i>introspective sort</i>).  Other improvements
      exist, but we will not discuss them here.  The best versions of
      introsort are among the best sorting algorithms available,
      unless the array is nearly sorted.  Of course, if the
      data won't fit in an array, we can't use introsort - we should
      use <a
      href="/~rhowell/DataStructures/redirect/external-merge-sort">external
      merge sort</a> instead.  Furthermore, like quick sort and heap
      sort, introsort is not stable.
      When a stable sort is not needed, however, and when none of the
      above special cases applies, introsort is one of the best
      choices available.
</p>


<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/sorting-strings">Next:
      Sorting Strings
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/split-sorts">Previous:
      Split Sorts
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/sorting">Up: Sorting
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Thu May  3 14:04:22 CDT 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2015, 2017, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
