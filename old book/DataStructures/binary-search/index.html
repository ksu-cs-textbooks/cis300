<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Binary Search</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Binary Search</h1>
<p>
      In <a href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/dictionary-linked-lists">the
	previous section</a>, we discussed how linked lists could be
	used to implement a dictionary.  An alternative to a linked
	list would be an array.  A couple of other alternatives are the
      non-generic <a href="http://msdn.microsoft.com/en-us/library/system.collections.arraylist.aspx"><b>System.Collections.ArrayList</b></a>
      or the generic <a href="http://msdn.microsoft.com/en-us/library/6sh2ey19(v=vs.110).aspx"><b>System.Collections.Generic.List&lt;T&gt;</b></a>.
      These classes are similar to singly-dimensioned arrays, but they
      can grow as needed.  In this respect, they are like a <a href="http://msdn.microsoft.com/en-us/library/system.text.stringbuilder(v=vs.110).aspx"><b>StringBuilder</b></a>,
      but instead of storing <b>char</b>s, an <b>ArrayList</b> stores
      <b>object</b>s and a <b>List&lt;T&gt;</b> stores instances of
      the type parameter <b>T</b>.  Elements can be retrieved from
      instances of these classes using indexing, just like retrieving
      an element from an array.
</p>
Assuming we restrict the keys to be sub-types of
    <b>IComparable&lt;TKey&gt;</b>, where <b>TKey</b> is the key type,
    we can store the keys in order in any of these data structures.
    We can then search for a key in the same way as we described for a
    linked list.  However, such a search can be expensive - to search
    for a key that is larger than any key in the dictionary, we need
    to examine all of the keys.  We say that the performance of this
    sequential search is in O(<i>n</i>), where <i>n</i> is the number
    of keys in the dictionary.  This means that as <i>n</i> grows, the
    time required for the search is at worst proportional to <i>n</i>.
<p></p>
We can improve this performance dramatically for arrays or array-like
    structures such as <b>ArrayList</b>s or <b>List&lt;T&gt;</b>s
    using a technique called <i>binary search</i>
    (there isn't much we can do to improve the performance of
    searching a linked list, as its structure restricts us to
    traversing it sequentially).  The idea is similar to what humans
    do when looking for something in an ordered list such as a
    dictionary or an index of a book.  Rather than looking
    sequentially through the sequence, we first look in the middle and
    narrow our search space depending on how what we are looking for
    compares with what we are looking at.  For example, if we are
    looking for "Les Miserables", we first look in the middle of the
    sequence, where we might see "Othello".  Because "Les Miserables"
    is alphabetically less than "Othello", we can narrow the search
    space to those titles less than "Othello".  In the middle of this
    search space, we might find the title, "Great Expectations".
    Because "Les Miserables" is alphabetically greater than "Great
    Expectations", we narrow the search space to those titles greater
    than "Great Expectations" and less than "Othello".  We continue
    narrowing in this way until either we find "Les Miserables" or the
    search space becomes empty, implying that the data set does not
    contain this title.
<p>
In a binary search, each lookup is as nearly as possible in the center
      of the search space.  This means that each time we look at an
      entry, we either find what we are looking for, or we decrease
      the size of the search space to at most half its previous size.
      For large data sets the search space therefore shrinks rapidly.
      For example, if we start with 1,000,000 elements and
      repeatedly reduce the search space to at most half its previous
      size, after 20 such reductions, we are left with nothing.
      Likewise, if we start with 1,000,000,000 elements, 30 such
      reductions in size lead to an empty search space.
</p>
To implement this algorithm, we need to keep track of the search
    space.  We will use two <b>int</b> variables, <tt>start</tt> and
    <tt>end</tt>.  <tt>start</tt> will keep track of the first index
    in the search space, while <tt>end</tt> will keep track of the
    first index <i>past</i> the search space, as follows:
<p>
<img alt="The search space for binary search" src="binary-search-space.jpg"/>
</p>
The way we have defined <tt>end</tt> may seem unnatural at first, but
    because it simplifies various calculations, it is a common way of
    describing a search space.  For example, the number of elements in
    such a search space is simply the difference between <tt>end</tt>
    and <tt>start</tt>, and to describe an entire array, we can
    initialize <tt>start</tt> to 0 and <tt>end</tt> to the array's
    length.
<p>
We then need a loop to iterate as long as this search space is nonempty
      (we can return from inside this loop if we find what we are
      looking for).  On each iteration, we need to find the midpoint
      of the search space.  This midpoint is simply the average of
      <tt>start</tt> and <tt>end</tt> - i.e., their sum divided by 2.
      We need to be a bit careful here because we are doing integer
      division, which may involve rounding.  As a result, we may not
      get exactly the average.  In any case, we need to ensure that
      the index we compute is within the search space - otherwise, we
      may not reduce the search space, and an infinite loop will
      result.  Because the search space is nonempty,
      <tt>start</tt> &lt; <tt>end</tt>; hence, the true
      average is strictly between <tt>start</tt> and <tt>end</tt>.  If
      this average is not an integer, the result will be rounded down
      to the next integer.  Because <tt>start</tt> is an integer, this
      result will be no less than
      <tt>start</tt>, but less than <tt>end</tt>; hence it will be in
      the search space.
</p>
Once we have computed this midpoint, we need to compare the key of the
    element at that location with the key we are looking for.  Recall
    that we use the <b>CompareTo</b> method to do this comparison.
    Note that for large key types, the <b>CompareTo</b> method can be
    expensive.    For this reason,
    it is best to call the <b>CompareTo</b> method only once for a
    given pair of keys, and if necessary, save the result it
    returns in order to make more than one comparison between this
    result and 0.
<p>
Thus, once we have obtained the result of the <b>CompareTo</b> method,
      we need to determine which of the three cases we have.  If the
      keys are equal, we should be able to return.  If the key we are
      looking for is less than the key at the midpoint, we need to
      adjust <tt>end</tt>.  Otherwise, we need to adjust
      <tt>start</tt>.
</p>
If the loop finishes without returning, then the search space is
    empty; hence, the key we are looking
    for is not in the data set.  However, <tt>start</tt> will end up
    at the point at which this key could be inserted; hence, the
    binary search can be used for both lookups and insertions.
<p>
Binary search is a very efficient way to search an ordered array-like
      structure.  In particular, it always makes no more than
      <i>O</i>(log <i>n</i>) comparisons, where <i>n</i> is the
      number of elements in the data set.  The log function grows very
      slowly - much more slowly than <i>n</i>.
</p>
<p></p>
<p>
</p>
<p></p>
</body>
</html>
