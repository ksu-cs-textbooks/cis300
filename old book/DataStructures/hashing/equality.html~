<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Equality in C#</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/hash-functions">Next: Hash
      Codes
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/memoization">Previous:
      Memoization 
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/dictionaries">Up:
      Hash Tables
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Equality in C#</h1>

Continuing our discussion from <a
      href="/~rhowell/DataStructures/redirect/memoization">the
      previous section</a>, we want to define a type that represents a
      Nim board.  Furthermore, we need to be able to compare instances
      of this type for equality.  Before we can address how this can
      be done, we first need to take a careful look at how C# handles
      equality.  In what follows, we will discuss how C# handles the
      == operator, the non-<b>static</b> <b>Equals</b> method, and two
      <b>static</b> methods for determining equality.  We will then
      show how the comparison can be defined so that all of these
      mechanisms behave in a consistent way.
<p>
We first consider the == operator.  The behavior of this operator is
      determined by the <i>compile-time</i> types of its operands.
      This is determined by the declared types of variables, the
      declared return types of methods or properties, and the rules
      for evaluating expressions.  Thus, for example, if we have a
      statement
</p>
<pre>
object x = "abc";
</pre>
the compile-time type of <tt>x</tt> is <b>object</b>, even though it
    actually refers to a <b>string</b>.
<p>
For pre-defined <a
      href="/~rhowell/DataStructures/redirect/reference-value">value
      types</a>, == evaluates to 
      <b>true</b> if its operands contain the same values.  Because
      <a
      href="/~rhowell/DataStructures/redirect/enumerations">enumerations</a>
      are represented as numeric types such as <b>int</b> or
      <b>byte</b>, this rule applies to them as well.  For
      user-defined structures, == is undefined unless the structure
      definition explicitly defines the == and != operators.  We will
      show how this can be done below.
</p>
By default, when == is applied to reference types, it evaluates to
    <b>true</b> when the two operands refer to the same object (i.e.,
    they refer to the same memory location).  A class may override
    this behavior by explicitly defining the == and != operators.  For
    example, the <b>string</b> class defines the == operator to
    evaluate to <b>true</b> if the given <b>string</b>s are the same
    length and contain the same sequence of characters.
<p>
Let's consider an example that illustrates the rules for reference
      types:
<pre>
string a = "abc";
string b = "0abc".Substring(1);
object x = a;
object y = b;
bool comp1 = a == b;
bool comp2 = x == y;
</pre>
The first two lines assign to <tt>a</tt> and <tt>b</tt> the same
    sequence of characters; however, because the <b>string</b>s are
    computed differently, they are different objects.  The next two
    lines copy the reference in <tt>a</tt> to <tt>x</tt> and the
    reference in <tt>b</tt> to <tt>y</tt>.  Thus, at this point, all
    four variables refer to a <b>string</b> "abc"; however, <tt>a</tt>
    and <tt>x</tt> refer to a different object than do <tt>b</tt> and
    <tt>y</tt>.  The fifth line compares <tt>a</tt> and <tt>b</tt> for
    equality using ==.  The compile-time types of <tt>a</tt> and
    <tt>b</tt> are both <b>string</b>; hence, these variables are
    compared using the rules for comparing <b>string</b>s.  Because
    they refer to <b>string</b>s of the same length and containing the
    same sequence of characters, <tt>comp1</tt> is assigned
    <b>true</b>.  The behavior of the last line is determined by
    the compile-time types of <tt>x</tt> and <tt>y</tt>.  These types are
    both <b>object</b>, which defines the default behavior of this
    operator for reference types.  Thus, the comparison determines
    whether the two variables refer to the same object.  Because they
    do not, <tt>comp2</tt> is assigned <b>false</b>.
<p>
Now let's consider the non-<b>static</b> <b>Equals</b> method.  The
      biggest difference between this method and the == operator is
      that the behavior of <b>x.Equals(y)</b> is determined by
      the <i>run-time</i> type of <tt>x</tt>.  This is
      determined by the actual type of the object, independent of
      how any variables or return types are declared.
</p>
<p>
By default, if <tt>x</tt> is a value type and <tt>y</tt> can be
      treated as having the same type, then <b>x.Equals(y)</b> returns
      <b>true</b> if <tt>x</tt> and <tt>y</tt> have the same
      value (if <tt>y</tt> can't be treated as having the same type as
      <tt>x</tt>, then this method returns <b>false</b>).  Thus, for
      pre-defined value types, the behavior is the 
      same as for == once the types are determined (provided the types
      are consistent).  However,
      the <b>Equals</b> method is always defined, whereas the ==
      operator may not be.  Furthermore, structures may
      <i>override</i> this method to change this behavior - we will
      show how to do this below.
</p>
By default, if <tt>x</tt> is a reference type, <b>x.Equals(y)</b>
    returns <b>true</b> if <tt>x</tt> and <tt>y</tt> refer to the same
    object.  Hence, this behavior is the same as for == once the types
    are determined (except that if <tt>x</tt> is <b>null</b>,
    <b>x.Equals(y)</b> will throw a <b>NullReferenceException</b>,
    whereas <tt>x&nbsp;==&nbsp;y</tt> will not).  However, classes may
    override this method to change this behavior.  For example, the
    <b>string</b> class overrides this method to return <b>true</b> if
    <b>y</b> is a <b>string</b> of the same length and containing the
    same sequence of characters as <tt>x</tt>.
<p>
Let's now continue the above example by adding the following lines:
</p>
<pre>
bool comp3 = a.Equals(b);
bool comp4 = a.Equals(x);
bool comp5 = x.Equals(a);
bool comp6 = x.Equals(y);
</pre>
These all evaluate to <b>true</b> for one simple reason - the behavior
    is determined by the run-time type of <tt>a</tt> in the case of
    the first two lines, or of <tt>x</tt> in the case of the last two
    lines.  Because these types are both <b>string</b>, the objects
    are compared as <b>string</b>s.  (Actually, it's a bit more
    complicated in the case of <tt>comp3</tt>, but we'll explain this
    later.)
<p>
The <b>object</b> class defines, in addition to the <b>Equals</b>
      method described above, two <b>public static</b> methods, which
      are in turn inherited by every type in C#:
<ul>
<li> <b>bool Equals(object x, object y)</b>:  The main purpose of this
	method is to avoid the <b>NullReferenceException</b> that
	is thrown by <b>x.Equals(y)</b> when <tt>x</tt> is
	<b>null</b>.  If neither <tt>x</tt> nor <tt>y</tt> is
	<b>null</b>, this method simply returns the value of
	<b>x.Equals(y)</b>.  Otherwise, it will return <b>true</b> if
	both <tt>x</tt> and <tt>y</tt> are <b>null</b>.  User-defined
	types cannot override this method, but because it calls the
	non-<b>static Equals</b> method, which they can override, they
	can affect its behavior indirectly. </li>
<li> <b>bool ReferenceEquals(object x, object y)</b>:  This method
	returns <b>true</b> if <tt>x</tt> and <tt>y</tt> refer to the
	same object or are both <b>null</b>.  If either <tt>x</tt> or
	<tt>y</tt> is a value type, it will return <b>false</b>.
	User-defined types cannot override this method. </li>
</ul>
Finally, there is nothing to prevent user-defined types from including
    their own <b>Equals</b> methods with different parameter lists.
    In fact, the <b>string</b> class includes definitions of the
    following <b>public</b> methods:
<ul>
<li> <b>bool Equals(string s)</b>:  This method actually does the same
	thing as the non-<b>static</b> <b>Equals</b> method defined in
	the <b>object</b> class, but is slightly more efficient
	because less run-time type checking needs to be done.  This is
	the method that is called in the computation of <tt>comp3</tt>
	in the above example. </li>
<li> <b>static bool Equals(string x, string y)</b>:  This method does
	the same thing as the <b>static Equals</b> method defined in
	the <b>object</b> class, but again is slightly more efficient
	because less run-time type checking needs to be done. </li>
</ul>
All of this can be rather daunting at first.  Fortunately, in most
    cases these comparisons end up working the way we expect them to.
    The main thing we want to focus on here is how to define equality
    properly in a user-defined type.
<p>
<a name="operator-overloading"></a>
Let's start with the == operator.  This is one of several operators
      that may be defined within class and structure definitions.  If
      we are defining a class or structure called <b>SomeType</b>, we
      can include a definition of the == operator as follows:
</p>
<pre>
public static bool operator ==(SomeType x, SomeType y)
{
    // Definition of the behavior of ==
}
</pre>
Note the resemblance to the definition of a <b>static</b> method.
    Even though we define it using the syntax for a method definition,
    we still use it as we typically use the == operator; e.g.,
<pre>
if (a == b)
{
    . . .
}
</pre>
If <tt>a</tt> and <tt>b</tt> are both of type <b>SomeType</b>, the
    above definition will be called using <tt>a</tt> as the parameter
    <tt>x</tt> and <tt>b</tt> as the parameter <tt>y</tt>.
<p>
Within the operator definition, if it is within a class definition,
      the first thing we need to do is to handle the cases in which
      one or both parameters are <b>null</b>.  We don't need to do this
      for a structure definition because value types can't be
      <b>null</b>, but if we omit this part for a reference type,
      comparing a variable or expression of this type to <b>null</b>
      will most likely result in a <b>NullReferenceException</b>.  We
      need to be a bit careful here, because if we use == to compare
      one of the parameters to <b>null</b> it will be a recursive call
      - infinite recursion, in fact.  Furthermore, using
      <b>x.Equals(null)</b> is always a bad idea, as if <tt>x</tt>
      does, in fact, equal <b>null</b>, this will throw a
      <b>NullReferenceException</b>.  We therefore need to use one of
      the <b>static</b> methods, <b>Equals</b> or
      <b>ReferenceEquals</b>:
</p>
<pre>
public static bool operator ==(SomeType x, SomeType y)
{
    if (Equals(x, null))
    {
         return (Equals(y, null));
    }
    else if (Equals(y, null))
    {
        return false;
    }
    else
    {
        // Code to determine if x == y
    }
}
</pre>
Note that because all three calls to <b>Equals</b> have <b>null</b> as
    a parameter, these calls won't result in calling the <b>Equals</b>
    method that we will override below.
<p>
Whenever we define the == operator, C# requires that we also define
      the != operator.  In virtually all cases, what we want this
      operator to do is to return the negation of what the == operator
      does:
</p>
<pre>
public static bool operator !=(SomeType x, SomeType y)
{
    return !(x == y);
}
</pre>
We now turn to the (non-<b>static</b>) <b>Equals</b> method.  This is
      defined in the <b>object</b> class to be a <b>virtual</b>
      method, meaning that sub-types are allowed to <a
      href="/~rhowell/DataStructures/redirect/method-overriding">override</a>
      its behavior.  Because every type in C# is a subtype of
      <b>object</b>, this method is present in every type, and it can
      be overridden by any class or structure.  <p></p> We override
      this method as follows:
<pre>
public override bool Equals(object obj)
{
    // Definition of the behavior of Equals
}
</pre>
For the body of the method, we
    first need to take care of the fact that the parameter is of type
    <b>object</b>; hence, it may not even have the same type as what
    we want to compare it to.  If this is the case, we can immediately
    return <b>false</b>.  Otherwise, in order to ensure consistency
    between this method and the == operator, we can do the actual
    comparison using the == operator:
<pre>
public override bool Equals(object obj)
{
    if (obj is SomeType)
    {
        return this == (SomeType)obj;
    }
    else
    {
        return false;
    }
}
</pre>
The above definitions give a template for defining the == and !=
    operators and the non-<b>static Equals</b> method for most classes
    that we would want to compare for equality.  For structures, we
    can remove the code that handles <b>null</b> parameters from the
    == definition.  In either case, all we then need to do to complete
    the definitions is to replace the name <b>SomeType</b>, wherever
    it occurs, with the
    name of the type we are defining, and to fill in the hole left in
    the definition of the == operator.  It is here where we actually
    define how the comparison is to be made.
<p>
Suppose, for example, that we want to define a class to represent a
      Nim board position (see the <a
      href="/~rhowell/DataStructures/redirect/memoization">previous
      section</a>).  This class will need to have two <b>private</b>
      fields: an <b>int[&nbsp;]</b> storing the number of stones on
      each pile and an <b>int[&nbsp;]</b> storing the limit for each
      pile.  These two arrays should be non-<b>null</b> and have the
      same length, but this 
      should be enforced by the constructor.  By default, two
      instances of a class are considered to be equal (by either the
      == operator or the non-<b>static Equals</b> method) if they are
      the same object.  This is too strong for our purposes; instead,
      two instances <tt>x</tt> 
      and <tt>y</tt> of the
      board position class should be considered equal if
</p>
<ul>
<li> Their arrays giving the number of stones on each pile have the
	same length; and </li> <li> For each index <i>i</i> into the
	arrays giving the number of stones on each pile, the elements
	at location <i>i</i> of these arrays have the same value, and
	the elements at location <i>i</i> of the arrays giving the
	limit for each pile have the same value. </li>
</ul>
Code to make this determination and return the result can be inserted
    into the above template defining of the == operator, and the other
    two templates can be customized to refer to this type.
    <p>
      Any class that redefines equality should also redefine the hash
      code computation to be consistent with the equality definition.
      We will show how to do this in the next section.
    </p>
    

<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/hash-functions">Next: Hash
      Codes
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/memoization">Previous:
      Memoization 
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/dictionaries">Up:
      Hash Tables
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Mon Jul 30 04:36:54 CDT 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
