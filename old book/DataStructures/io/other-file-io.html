<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Other File I/O</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Other File I/O</h1>

Not all files are plain text files - often we need to read and/or write
    binary data.  The .NET Framework provides the <a href="http://msdn.microsoft.com/en-us/library/system.io.filestream.aspx"><b>FileStream</b></a>
    class for this purpose.
<p>
The <b>FileStream</b> class provides constructors for creating
      a <b>FileStream</b> for reading, writing, or both.  These
      constructors can be used to specify how the file is to be opened
      or created, the type of access to be allowed (i.e.,
      reading/writing), and how the file is to be locked.  In most
      cases, however, a simpler way to construct an appropriate
      <b>FileStream</b> is to use one of the following <b>static</b>
      methods provided by the 
      the <a href="https://msdn.microsoft.com/en-us/library/system.io.file.aspx"><b>File</b></a>
      class:
</p>
<ul>
<li> <a href="https://msdn.microsoft.com/en-us/library/system.io.file.openread.aspx"><b>File.OpenRead(string
	  fn)</b></a>: returns a <b>FileStream</b> for reading the
	  file with the given path name.  A
	  <b>FileNotFoundException</b> is thrown if the 
	file does not exist.
      </li>
<li> <a href="https://msdn.microsoft.com/en-us/library/system.io.file.openwrite.aspx"><b>File.OpenWrite(string
	  fn)</b></a>: returns a <b>FileStream</b> for writing to the
	  file with the given path name.  If the file exists, it will
	  be replaced; otherwise, it will be created.
</li>
</ul>
<p>
Two of the most commonly-used methods of a <b>FileStream</b> are <a href="http://msdn.microsoft.com/en-us/library/system.io.filestream.readbyte.aspx"><b>ReadByte</b></a>
	and <a href="http://msdn.microsoft.com/en-us/library/system.io.filestream.writebyte.aspx"><b>WriteByte</b></a>.
	The <b>ReadByte</b> method takes no parameters and returns an
	<b>int</b>.  If there is at least one byte available to read, the
	next one is read and its value (a nonnegative integer less
	than 256) is returned; otherwise, the value returned is -1
	(this is the only way to detect when the end of the stream has
	been reached).  The <b>WriteByte</b> method takes a
	<b>byte</b> as its only parameter and writes it to the file.
	It returns nothing.
</p>
Because a <b>FileStream</b> has no <b>EndOfStream</b> property, we
    must code a loop to read to the end of the stream somewhat
    differently from what we have seen before.  We can take advantage
    of the fact that in C#, an assignment statement can be used within
    an expression.  When this is done, the value of the assignment
    statement is
    the value that it assigns.  Thus, if <tt>input</tt> is a
    <b>FileStream</b> opened for input, we can set up a loop to read a
    byte at a time to the end of the stream as follows:
<pre>
int k;
while ((k = input.ReadByte()) != -1)
{
    byte b = (byte)k;
    . . .
}
</pre>
In the above code, the <b>ReadByte</b> method reads a byte from the
    file as long as there is one to read, and assigns it to the
    <b>int</b> variable <tt>k</tt>.  If there is no byte to read, it
    assigns -1 to <tt>k</tt>.  In either case, the value of the
    assignment statement is the value assigned to <tt>k</tt>.  Thus,
    if the <b>ReadByte</b> method is at the end of the stream, it
    returns -1, which is assigned to <tt>k</tt>, and the loop
    terminates.  Otherwise, the loop iterates, assigning <tt>k</tt> to
    <tt>b</tt> as a <b>byte</b>.  The remainder of the iteration can
    then use the <b>byte</b> read, which is in <tt>b</tt>.

<p></p>
<p>
</p>
<p></p>
</body>
</html>
