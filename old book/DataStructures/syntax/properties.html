<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Properties</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Properties</h1>

A property is used syntactically like a field of a class or structure,
    but provides greater flexibility in implementation.  For example,
    the <b>string</b> 
    class contains a <b>public</b> property called <a href="http://msdn.microsoft.com/en-us/library/system.string.length.aspx"><b>Length</b></a>.
    This property is accessed in code much as if it were a
    <b>public int</b> field;
    i.e., if <tt>s</tt> is a <b>string</b> variable, we can access its
    <b>Length</b> property with the expression:
<pre>
s.Length
</pre>
which evaluates to an <b>int</b>.
If <b>Length</b> were a <b>public int</b> field, we would access it in
    just the same way.  However, it turns out that we cannot assign a
    value to this property, as we can to a <b>public</b> field;
    i.e., the statement,
<pre>
s.Length = 0;
</pre>
is not allowed.  The reason for this limitation is that properties can
    be defined to restrict whether they can be read from or written
    to.  The <b>Length</b> property is defined so that it can be read
    from, but not written to.  This flexibility is one of the two main
    differences between a field and a property.  The other main
    difference has to do with maintainability and is therefore easier
    to understand once we see how to define a property.  
<p>
Suppose we wish to provide full read/write access to
      a <b>double</b> value.  Rather than defining a <b>public double</b>
      field, we can define a simple <b>double</b> property as follows:
<pre>
public double X { get; set; }
</pre>
    This property then functions just like a <b>public</b> field - the
      <b>get</b> keyword allows code to read from the
      property, and the <b>set</b> keyword allows code to write to
      the property.  A property definition requires at least one of
      these keywords, but one of them may be omitted to define a
      read-only property (if <b>set</b> is omitted) or a write-only
      property (if <b>get</b> is omitted).  For example, the following
    defines <b>X</b> to be a read-only property:
<pre>
public double X { get; }
</pre>
    Although this property is read-only, the constructor for the class
    or structure containing this definition is allowed to initialize it.
    Sometimes, however we want certain methods of the containing class
    or structure to be able to modify the property's value without
    allowing user code to do so.  To accomplish this, We can define <b>X</b>
      in this way:
<pre>
public double X { get; private set; }
</pre>
    The above examples are the simplest ways to define properties.
    They all rely on the <i>default implementation</i> of the
    property.  Unlike a field, the name of the property is not
    actually a variable; instead, there is a <i>hidden</i> variable
    that is automatically defined.  The only way this hidden variable
    can be accessed is through the property.
    <p>
      The distinction between a property and its hidden variable may
      seem artificial at first.  However, the real flexibility of a
      property is revealed by the fact that we can define our own
      implementation, rather than relying on the default
      implementation.  For example, suppose a certain data structure
      stores a <b>StringBuilder</b> called <tt>_word</tt>, and we want
      to provide read-only access to its length.  We can facilitate
      this by defining the following property:
<pre>
public int WordLength
{
    get =&gt; _word.Length;
}
</pre>
    In fact, we can abbreviate this definition as follows:
<pre>
public int WordLength =&gt; _word.Length;
</pre>
    In this case, the <b>get</b> keyword is implied.  In either case,
    the code to the right of the "=&gt;" must be an expression whose
    type is the same as the property's type.  Note that when we
    provide such an expression, there is no longer a hidden variable,
    as we have provided explicit code indicating how the value of the
    property is to be computed.
    <p>
      We can also provide an explicit implementation for the
      <b>set</b> accessor.  Suppose, for example, that we want to
      allow the user read/write access to the length of
      <tt>_word</tt>.  In order to be able to provide write access, we
      must be able to acquire the value that the user wishes to assign
      to the length.  C# provides a keyword <b>value</b> for this
      purpose - its type is the same as the type of the property, and
      it stores the value that user code assigns to the property.
      Hence, we can define the property as follows: 
    </p>
<pre>
public int WordLength
 {
    get =&gt; _word.Length;
    set =&gt; _word.Length = value;
 }
</pre>
    Again, the code to the right of the "=&gt;" must be an expression
    whose type is the same as the type of the property (note that in
    C#, an assignment statement can be used as an expression whose
    type is that of the value being assigned).
    <p>
      It is this flexibility in defining the implementation of a
      property that makes <b>public</b> properties more maintainable
      than <b>public</b> fields.  Returning to the example at the
      beginning of this section, suppose we had simply defined
      <b>X</b> as a <b>public double</b> field.  As we pointed out
      above, such a field could be used by user code in the same way
      as the first definition of the property <b>X</b>.  However, a
      field is part of the implementation of a class or structure.  By
      making it <b>public</b>, we have exposed part of the
      implementation to user code.  This means that if we later change this
      part of the implementation, we will potentially break user code
      that relies on it.  If, instead, we were to use a property, we
      can then change the implementation by modifying the <b>get</b> and/or
      <b>set</b> accessors.  As long as we don't remove either
      accessor (or make it <b>private</b>), such a change is invisible
      to user code.  Due to this maintainability, good programmers
      will never use <b>public</b> fields (unless they are <a href="/~rhowell/DataStructures/redirect/const">constants</a>);
      instead, they will use <b>public</b> properties.
    </p>
    In some cases, we need more than a single to expression to define
    a <b>get</b> or <b>set</b> accessor.  For example, suppose a data
    structure stores an <b>int[Â ]</b> <tt>_elements</tt>, and we
    wish to provide read-only access to this array.  In order to
    ensure read-only access, we don't want to give user code a
    reference to the array, as the code would then be able to modify
    its contents.  We therefore wish to make a copy of the array, and
    return that array to the user code (though a better solution might be to
    define an <a href="/~rhowell/DataStructures/redirect/indexers">indexer</a>).
    We can accomplish this as follows:
<pre>
public int[ ] Elements
{
    get
    {
        int[] temp = new int[_elements.Length];
        _elements.CopyTo(temp, 0);
        return temp;
    }
}
</pre>
    Thus, arbitrary code may be included within the <b>get</b>
    accessor, provided it returns a value of the appropriate type;
    however, it is good programming practice to avoid changing the
    fields of a class or structure within the <b>get</b> accessor of
    one of its properties.  In a similar way, arbitrary code may be
    used to implement a <b>set</b> accessor.  As we can see from this
    most general way of defining properties, they are really more like
    methods than fields.
    <p>
Given how similar accessors are to methods, we might also wonder why
    we don't just use methods instead of properties.  In fact, we can
    do just that - properties don't give any functional advantage over
    methods, and in fact, some object-oriented languages don't have
    properties.  The advantage is stylistic.  Methods are meant to
    perform actions, whereas properties are meant to represent
    entities.  Thus, we could define methods <b>GetX</b> and
    <b>SetX</b> to provide access to the <b>private</b> field
    <tt>_x</tt>; however, it is stylistically cleaner to define a
    property called <b>X</b>.
<p></p>
<p>
</p>
<p></p>
</p></p></p></body>
</html>
