<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>out and ref Parameters</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/foreach">Next: The
      <b>foreach</b> Statement
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/static-this">Previous:
      The Keywords static and this
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/syntax">Up: C# Syntax
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>out and ref Parameters</h1>

Normally, when a method is called, the <i>call-by-value</i> mechanism
    is used.  Suppose, for example, we have a method:
<pre>
private void DoSomething(int k)
{
    . . .
}
</pre>
We can call this method with a statement like:
<pre>
DoSomething(n);
</pre>
provided <tt>n</tt> is an initialized variable consistent with the
    <b>int</b> type.  For example, suppose <tt>n</tt> is an
    <b>int</b> variable containing a value of 28.  The call-by-value
    mechanism works by copying the value of <tt>n</tt> (i.e., 28) to
    <tt>k</tt>.  Whatever the <b>DoSomething</b> method may
    do to <tt>k</tt> has no effect on <tt>n</tt> - they are different
    variables.  The same can be said if we had instead passed a
    variable <tt>k</tt> - the <tt>k</tt> in the calling code is still
    a different variable from the <tt>k</tt> in the <b>DoSomething</b>
    method.  Finally, if we call <b>DoSomething</b> with an expression
    like 42 or 9 + n, the mechanism is the same.
<p>
If a parameter is of a <a
      href="/~rhowell/DataStructures/redirect/reference-value">reference
      type</a>, the same mechanism is used, but it is worth
      considering that case separately to see exactly what
      happens.  Suppose, for example, that we have the following
      method:
<pre>
private void DoSomethingElse(int[] a)
{
    a[0] = 1;
    a = new int[10];
    a[1] = 2;
}
</pre>
Further suppose that we call this method with
<pre>
int[] b = new int[5];
DoSomethingElse(b);
</pre>
The initialization of <tt>b</tt> above assigns to <tt>b</tt> a
    reference to an array
    containing five 0s.  The call to <b>DoSomethingElse</b> copies the
    value of <tt>b</tt> to <tt>a</tt>.  Note, however, that the value
    of <tt>b</tt> is a reference; hence, after this value is copied,
    <tt>a</tt> and <tt>b</tt> refer to the same five-element array.
    Therefore, when <tt>a[0]</tt> is assigned <tt>1</tt>,
    <tt>b[0]</tt> also becomes <tt>1</tt>.  When <tt>a</tt> is
    assigned a new array, however, this does not affect <tt>b</tt>,
    as <tt>b</tt> is a different variable - <tt>b</tt> still refers to
    the same five-element array.  Furthermore, when <tt>a[1]</tt> is
    assigned a value of 2, because <tt>a</tt> and <tt>b</tt> now refer
    to different arrays, the contents of <tt>b</tt> are unchanged.
    Thus, when <b>DoSomethingElse</b> completes, <tt>b</tt> will refer
    to a five-element array whose element at location 0 is 1, and
    whose other elements are 0.
<p>
While the call-by-value mechanism is used by default, another
      mechanism, known as the <i>call-by-reference</i> mechanism, can
      be specified.  When call-by-reference is used, the parameter
      passed in the calling code must be a variable, not a property or
      expression.  Instead of copying the value of this variable into
      the corresponding parameter within the method, this mechanism
      causes the variable within the method to be an <i>alias</i> for
      the variable being passed.  In other words, the two variables
      are simply different names for the same underlying variable
      (consequently, the types of the two variables must be
      identical).  Thus,
      whatever changes are made to the parameter within the method are
      reflected in the variable passed to the method in the calling
      code as well.
</p>
One case in which this mechanism is useful is when we would like to
    have a method return more than one value.  Suppose, for example,
    that we would like to find both the maximum and minimum values in
    a given <b>int[&nbsp;]</b>.  A <b>return</b> statement can return
    only one value.  Although there are ways of packaging more than one
    value together in one object, a cleaner way is to use two
    parameters that use the call-by-reference mechanism.  The method
    can then change the values of these variables to the maximum and
    minimum values, and these values would be available to the calling
    code.
<p>
Specifically, we can define the method using <b>out</b> parameters:
<pre>
private void MinimumAndMaximum(int[] array, out int min, out int max)
{
    min = array[0];
    max = array[0];
    for (int i = 1; i &lt; array.Length; i++)
    {
        if (array[i] &lt; min)
        {
            min = array[i];
        }
        if (array[i] &gt; max)
        {
            max = array[i];
        }
    }
}
</pre>
The <b>out</b> keyword in the first line above specifies the
    call-by-reference mechanism for <tt>min</tt> and <tt>max</tt>.  We
    could then call this code as follows, assuming <tt>a</tt> is an
    <b>int[&nbsp;]</b> containing at least one element:
<pre>
int minimum;
int maximum;
MinimumAndMaximum(a, out minimum, out maximum);
</pre>
When this code completes, <tt>minimum</tt> will contain the minimum
    element in <tt>a</tt> and <tt>maximum</tt> will contain the
    maximum element in <tt>a</tt>.
<p>
When using <b>out</b> parameters, it is important that the keyword
      <b>out</b> is placed prior to the variable name in both the
      method call and the method definition.  If you omit this keyword
      in one of these places, then the parameter lists won't match,
      and you'll get a syntax error to this effect.  
</p>
Note that <b>out</b> parameters do not need to be initialized prior to
    the method call in which they are used.  However, they need to be
    assigned a value within the method to which they are passed.
    Another way of using the call-by-reference mechanism places a
    slightly different requirement on where the variables need to be
    initialized.  This other way is to use <b>ref</b> parameters.  The
    only difference between <b>ref</b> parameters and <b>out</b>
    parameters is that <b>ref</b> parameters must be initialized prior
    to being passed to the method.  Thus, we would typically use
    an <b>out</b> parameter when we expect the method to assign it its
    first value, but we would use a <b>ref</b> parameter when we
    expect the method to change a value that the variable already
    has (the method may, in fact, use this value prior to changing
    it).
<p>
For example, suppose we want to define a method to swap the contents of
      two <b>int</b> variables.  We use <b>ref</b> parameters to
      accomplish this:
<pre>
private void Swap(ref int i, ref int j)
{
    int temp = i;
    i = j;
    j = temp;
}
</pre>
We could then call this method as follows:
<pre>
int m = 10;
int n = 12;
Swap(ref m, ref n);
</pre>
After this code is executed, <tt>m</tt> will contain 12 and <tt>n</tt>
    will contain 10.
<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/foreach">Next: The
      <b>foreach</b> Statement
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/static-this">Previous:
      The Keywords static and this
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/syntax">Up: C# Syntax
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Wed Oct  1 10:33:55 CDT 2014
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
