<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>The Keywords static and this</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>

<h1>The Keywords static and this</h1>

Object-oriented programming languages such as C# are centered on the
    concept of an object.  Class and structure definitions give
    instructions for constructing individual objects of various types,
    normally by using the <b>new</b> keyword.  When an object is
    constructed, it has its own fields in which values may be stored.
    Specifically, if type <b>T</b> has an <b>int</b> field called
    <tt>_length</tt>, then each object of type <b>T</b> will have have
    such a field, and each of these fields may store a different
    <b>int</b>.  Thus, for example, if <tt>x</tt> and <tt>y</tt> are
    instances of type <b>T</b>, then <tt>x._length</tt> may contain 7,
    while <tt>y._length</tt> may contain 12.
<p>
Likewise, we can think of each object as having its own methods and
      properties, as when any of these methods or properties use the
      fields of the containing class or structure, they will access
      the fields belonging to a specific object.  For example, if type
      <b>T</b> contains an <b>Add</b> method that changes the value
      stored in the <tt>_length</tt> filed, then a call <b>x.Add</b>
      will potentially change the value stored in <tt>x._length</tt>.
</p>
However, there are times when we want to define a field, method, or
    property, but we don't want it associated with any specific
    object.  For example, suppose we want to define a unique
    <b>long</b> value for each instance of some class <b>C</b>.  We
    can define a <b>private long</b> field <tt>_id</tt> within this
    class and give it a value within its constructor.  But how do we
    get this value in a way that ensures that it is unique?  One way
    is to define a <b>private static long</b> field <tt>_nextId</tt>,
    as in the following code:
<pre>
public class C
{
    private static long _nextId = 0;

    private long _id;

    public C()
    {
        _id = _nextId;
        _nextId++;
    }

    // Other members could also be defined.
}
</pre>
By defining <tt>_nextId</tt> to be <b>static</b>, we are specifying
    that each instance of <b>C</b> will not contain a <tt>_nextId</tt>
    field, but instead, there is a single <tt>_nextId</tt> field
    belonging to the entire class.  As a result, code belonging to any
    instance of <b>C</b> can access this one field.  Thus, each time
    an instance of <b>C</b> is constructed, this one field is
    incremented.  This field therefore acts as a counter that keeps
    track of how many instances of <b>C</b> have been constructed.  On
    the other hand, because <tt>_id</tt> is not <b>static</b>, each
    instance of <b>C</b> contains an <tt>_id</tt> field.  Thus, when
    the assignment,
<pre>
_id = _nextId;
</pre>
is done, the value in the single <tt>_nextId</tt> field is copied to
    the value of the <tt>_id</tt> field belonging to the instance
    being constructed.  Because the single <tt>_nextId</tt> field is
    incremented every time a new instance of <b>C</b> is constructed,
    each instance receives a different value for <tt>_id</tt>.
<p>
We can also define <b>static</b> methods or properties.  For example,
      the <a href="http://msdn.microsoft.com/en-us/library/519bytz3(v=vs.110).aspx"><b>MessageBox.Show(string
      text)</b></a> method is <b>static</b>.  Because it is
      <b>static</b>, we don't need a <b>MessageBox</b> object in order
      to call this method - we simply call something like:
<pre>
MessageBox.Show("Hello world!");
</pre>
<b>static</b> methods can also be useful for avoiding
    <b>NullReferenceException</b>s.  For example, there are times when
    we want to determine whether a variable <tt>x</tt> contains
    <b>null</b>, but <tt>x</tt> is of an unknown type (perhaps its
    type is defined by some <a href="/~rhowell/DataStructures/redirect/generic">type
    parameter</a> <b>T</b>).  In such a case, we cannot use == to make
    the comparison because == is not defined for all types.
    Furthermore, the following will never work:
<pre>
if (x.Equals(null))
{
    . . .
}
</pre>
Such code will compile, but if <tt>x</tt> is <b>null</b>, then calling
    its <b>Equals</b> method will throw a
    <b>NullReferenceException</b>.  In all other cases, the
    <b>if</b>-condition will evaluate to <b>false</b>.  Fortunately, a
    <a href="http://msdn.microsoft.com/en-us/library/w4hkze5k(v=vs.110).aspx"><b>static
    Equals</b></a> method is available to handle this situation:
<pre>
if (Equals(x, null))
{
    . . . 
}
</pre>
Because this method is defined within the <b>object</b> class, which
    is a supertype of every other type in C#, we can refer to this
    method without specifying the containing class, just as if we had
    defined it in the class or structure we are writing.  Because this
    method does not belong to individual objects, we don't need any
    specific object available in order to call it.  It therefore
    avoids a <b>NullReferenceException</b>.  
<p>
Because a <b>static</b> method or property does not belong to any
      instance of its type, it cannot access any non-<b>static</b>
      members directly, as they all belong to specific instances of
      the type.  If however, the code has access to a specific
      instance of the type (for example, this instance might be passed
      as a parameter), the code may reference non-<b>static</b>
      members of that instance.  For example, suppose we were to add
      to the class <b>C</b> above a method such as:
</p>
<pre>
public static int DoSomething(C x)
{
    . . .
}
</pre>
Code inside this method would be able to access <tt>_nextID</tt>, but
    not <tt>_id</tt>.  Furthermore, it would be able to access any
    <b>static</b> methods or properties contained in the class
    definition, as well as all constructors, but no non-<b>static</b>
    methods or properties.  However, it may access
    <tt>x._id</tt>, as well as any other members of <tt>x</tt>.
<p>
Code within a constructor or a non-<b>static</b> method or property
      can also access the object that contains it by using the keyword
      <b>this</b>.  Thus, in the constructor code above, we could have
      written the line
<pre>
_id = _nextId;
</pre>
as
<pre>
this._id = _nextId;
</pre>
In fact, the way we originally wrote the code is simply an
    abbreviation of the above line.  Another way of thinking of the
    restrictions on code within a <b>static</b> method or property is
    that this code cannot use <b>this</b>, either explicitly or
    implicitly.
<p></p>

<p>

</p>
<small>
<i> Â© Copyright 2014, <a href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i>
</small>
<p></p>
<table border="0" cellpadding="2" summary="This table is used for layout
purposes only.">
<tr>
<td align="center">
<a href="http://validator.w3.org/check/referer"><img alt="Valid HTML 4.01!" border="0" height="31" src="/~rhowell/valid-html401.gif" width="88"/></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
<img alt="Valid CSS!" border="0" height="31" src="/~howell/vcss.gif" width="88"/>
</a>
</td>
</tr></tr></table>
</p></p></body>
</html>
