<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Implementing Stacks and Queues with Linked Lists</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/sieve-eratosthenes">Next:
      Finding Prime Numbers
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-list-intro">Previous:
      Introduction to Linked Lists
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-lists">Up: Linked
      Lists 
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Implementing Stacks and Queues with Linked Lists</h1>

Because linked lists store data elements in linear sequences, they can
    be used to give alternative implementations of stacks and queues.
    One advantage to using linked lists is that we don't have to worry
    about filling up something like an array - we can just keep
    allocating cells as long as we need to (unless we run out of
    memory).
<p>
Implementing a stack using a linked list is particularly easy because
      all accesses to a stack are at the top.  One end of a linked
      list, the beginning, is always directly accessible.  We should
      therefore arrange the elements so that the top element of the
      stack is at the beginning of the linked list, and the bottom
      element of the stack is at the end of the linked list.  We can
      represent an empty stack with <b>null</b>.
</p>
We therefore need a <b>private LinkedListCell&lt;T&gt;</b> field to implement a
    generic stack <b>Stack&lt;T&gt;</b> using a linked list. This
    field will refer to the cell containing the data item at the top
    of the stack.  A <b>public Count</b> property will be used to keep
    track of the number of elements in the stack.
<p></p>
The <b>public</b> methods <b>Push</b>, <b>Peek</b>, and <b>Pop</b> are
    then fairly straightforward to implement.  For <b>Push</b> we need
    to add the given element to a new cell at the beginning of the
    linked list, as shown in <a
    href="/~rhowell/DataStructures/redirect/linked-list-intro">the
    previous section</a>, and update the <b>Count</b>.  To
    implement <b>Peek</b>, if the stack is nonempty, we simply return
    the <b>Data</b> property of the cell at the beginning of the
    linked list; otherwise, we throw an
    <b>InvalidOperationException</b>.  To implement <b>Pop</b>:
<ol>
<li> Using <b>Peek</b>, obtain the element to be returned; </li>
<li> Remove the first element from the linked list as shown in <a
    href="/~rhowell/DataStructures/redirect/linked-list-intro">the
    previous section</a>; </li>
<li> Update the <b>Count</b>; and </li>
<li> Return the retrieved value. </li>
</ol>
<p>
Implementing a queue is a little more involved because we need to
      operate at both ends of the linked list.  For efficiency, we
      should keep a reference to the last cell in the linked list, as
      this will allow us to access both ends of the linked list
      directly.  We will therefore have the following:
</p>
<img src="linked-list-queue.jpg" 
    alt="Implementing a queue with a linked list">
<p>
We now need to decide which end to make the front of the queue.  As we
      saw in <a
      href="/~rhowell/DataStructures/redirect/linked-list-intro">the
      previous section</a>, both inserting and removing can be done
      efficiently at the beginning of a linked list.  Likewise, it is
      easy to insert an element at the end if we have a reference to
      the last cell.  Suppose, for example, that <tt>last</tt> refers
      to the last cell in a linked list, and that <tt>cell</tt> refers
      to a <b>LinkedListCell&lt;T&gt;</b> that we want to insert at
      the end.  Suppose further that the linked list is not empty
      (that will be a special case that we'll need to handle).  Thus,
      we have the following:
</p>
<img src="linked-list-insert-end-1.jpg"
    alt="A cell to insert at the end of a linked list">
<p>
To insert this cell at the end of the linked list, we just need to
      copy the reference in <tt>cell</tt> to the <b>Next</b> property
      of the cell to which <tt>last</tt> refers:
</p>
<pre>
last.Next = cell;
</pre>
On the other hand, removing the last cell is problematic, even if we
    have a reference to it.  The problem is that in order to remove it
    from the linked list, we need to change the <b>Next</b> property
    of the preceding cell.  Unfortunately, the only way to obtain that
    cell is to start at the beginning of the list and work our way
    through it.  If the linked list is long, this could be quite
    inefficient.  Because we need to remove elements from the front of
    a queue, but not from the back, we conclude that it will work best
    to make the beginning of the linked list the front of the queue.
    We therefore need the following <b>private</b> fields to implement
    a generic queue <b>Queue&lt;T&gt;</b>:
<ul>
<li> A <b>LinkedListCell&lt;T&gt;</b> giving the element at the front
	of the queue.  This will be the beginning of the linked list
	of queue elements. </li>
<li> A <b>LinkedListCell&lt;T&gt;</b> giving the element at the back
	of the queue.  This will be the last cell in the linked list
	of queue elements. </li>
</ul>
As we mentioned earlier, adding an element to an empty queue is a
    special case that we will need to handle separately.  For this
    reason, it doesn't matter what values the two
    <b>LinkedListCell&lt;T&gt;</b> fields contain when the queue is
    empty - we can always detect when the queue is empty by checking
    the <b>Count</b>.  The initialization of the two
    <b>LinkedListCell&lt;T&gt;</b> fields is therefore unimportant.
    It is easiest to just leave them <b>null</b>.
<p>
Let us now consider the implementation of the <b>Enqueue</b> method.
      We need to consider two cases.  We'll first consider the case in
      which the queue is empty.  In this case, we need to build the
      following linked list:
</p>
<img src="one-cell-queue.jpg" 
    alt="A queue containing a single linked list cell">
<p>
We therefore need to:
</p>
<ol>
<li> Construct a new <b>LinkedListCell&lt;T&gt;</b>; </li>
<li> Assign it to the field denoting the front of the queue; </li>
<li> Assign it to the field denoting the back of the queue; </li>
<li> Store the given element in its <b>Data</b> property; and </li>
<li> Update the <b>Count</b>. </li>
</ol>
If the queue is nonempty, the only step that changes is Step 2.
    Because the queue is nonempty, we don't want to make the new cell
    the front 
    of the queue; instead, we need to insert it at the end of the
    linked list, as
    outlined above.
<p>
    The implementations of the <b>Peek</b> and <b>Dequeue</b> methods
    are essentially the 
    same as the implementations of the <b>Peek</b> and <b>Pop</b>
    methods, respectively, for a stack.
</p>
The implementations described in this section are simpler than the
    implementations using arrays, mainly due to the fact that we don't
    need to rebuild the structure when we fill up the space available.
    While these implementations are also pretty efficient, it turns
    out that the array-based implementations tend to out-perform the
    linked-list-based implementations.  This might be counterintuitive
    at first because rebuilding the structures when the array is
    filled is expensive.  However, due to the fact that we double the
    size of the array each time we need a new one, this rebuilding is
    done so rarely in practice that it ends up having minimal impact
    on performance.  Due to hardware and low-level software issues,
    the overhead involved in using arrays usually ends up being less.

<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/sieve-eratosthenes">Next:
      Finding Prime Numbers
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-list-intro">Previous:
      Introduction to Linked Lists
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-lists">Up: Linked
      Lists 
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Wed Feb  7 11:27:14 CST 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2015, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
