<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Implementing a Dictionary with a Linked List</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/dictionary-class">Previous:
      The <b>Dictionary&lt;TKey,&nbsp;TValue&gt;</b> Class
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-lists">Up: Linked Lists
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

    <h1>Implementing a Dictionary with a Linked List</h1>

    One way of implementing a dictionary is to store all the keys and
    values in a linked list.  We want to do this in such a way that a
    key is stored together with its associated value.  To facilitate
    this, the .NET Framework provides a structure <a
    href="https://msdn.microsoft.com/en-us/library/5tbh8a42.aspx"><b>KeyValuePair&lt;TKey,&nbsp;TValue&gt;</b></a>
    in the <b>System.Collections.Generic</b> namespace.  This
    structure is used simply for storing a key and a value.  The type
    parameter <b>TKey</b> is used to define the type of the keys, and the
    other type parameter <b>TValue</b> is used to define the type of
    the values.  It has two <b>public</b> properties:
    <ul>
      <li>
	<b><a
	href="https://msdn.microsoft.com/en-us/library/ms224760.aspx">Key</a></b>,
	which gets the key stored; and
      </li>
      <li>
	<a
	href="https://msdn.microsoft.com/en-us/library/ms224761.aspx"><b>Value</b></a>,
	  which gets the value stored.
      </li>
    </ul>
    Note that neither of these properties can be set; i.e., the
    structure is immutable.  In order to set the key and value, we
    need to construct a new instance using its <a 
    href="https://msdn.microsoft.com/en-us/library/3db765db.aspx">2-parameter
    constructor</a>.  The first parameter to this constructor is the
    key, and the second is the value.
    <p>
      Now that we have a way of storing keys and values together, we
      can implement a <b>Dictionary&lt;TKey,&nbsp;TValue&gt;</b> with
      a linked list comprised of instances of
      <b>LinkedListCell&lt;KeyValuePair&lt;TKey,&nbsp;TValue&gt;&gt;</b>.
      Thus, each cell of the list stores as its <b>Data</b> a
      <b>KeyValuePair&lt;TKey,&nbsp;TValue&gt;</b> containing a key
      and its associated value.  To add a key and a value, we first
      need to search the list for a cell containing that key.  If we
      find such a cell, we either replace the <b>KeyValuePair</b> in
      that cell with a new <b>KeyValuePair</b> containing the given
      key and value, or we throw an exception, depending on the
      specific behavior required.  If we don't find such a cell, we
      insert a new cell containing the given key and value.  Because
      it doesn't matter where we insert it, we might as well insert it
      at the beginning of the list, as that is the easiest way.  We
      can remove a key using techniques described in "<a
      href="http://people.cs.ksu.edu/~rhowell/DataStructures/redirect/sieve-eratosthenes">Finding
      Prime Numbers"</a>.
    </p>
    The main disadvantage to this approach is that searching for a key
    is expensive.  For example, to search for a key that is not in the
    dictionary, we need to examine every key in the dictionary.  We
    would like to improve on this performance.
    <p>
      One way of improving the performance of searching is to store
      the keys in increasing order.  Then as we search, if we see a
      key that is larger than the key we are looking for, we can
      stop.  However, recall that keys can be of any type.  For some
      types of keys, "increasing order" and "larger than" make no sense.
    </p>
    C# does provide a way to restrict the types that can be passed as
    type parameters to generic types.  Specifically, we can restrict
    the type <b>TKey</b> by writing the <b>class</b> statement as
    follows:
    <pre>
public class Dictionary&lt;TKey, TValue&gt; where TKey : IComparable&lt;TKey&gt;
    </pre>
    The <b>where</b> clause in this statement constrains <b>TKey</b>
    to be a subtype of <a
    href="https://msdn.microsoft.com/en-us/library/4d7sx9hd.aspx"><b>IComparable&lt;TKey&gt;</b></a>.
    Each subtype 
    of <b>IComparable&lt;TKey&gt;</b> contains a method <a href="https://msdn.microsoft.com/en-us/library/43hc6wht.aspx"><b>public int
      CompareTo(TKey x)</b></a>.  If <code>a</code> and
    <code>b</code> 
    are of type <b>TKey</b>, then <code>a.CompareTo(b)</code> returns:
    <ul>
      <li>
	A negative number if <code>a</code> is considered to be less
	than <code>b</code>;
      </li>
      <li>
	0 if <code>a</code> is considered to be equal to
	<code>b</code>; or
      </li>
      <li>
	A positive number if <code>a</code> is considered to be
	greater than <code>b</code>.
      </li>
    </ul>
    We can therefore use this <b>CompareTo</b> method to keep the list
    in increasing order.
    <p>
      Note that by constraining the key type in this way, we are
      making the <b>Dictionary&lt;TKey,&nbsp;TValue&gt;</b> less
      general, as we may sometimes want to use a key type that can't
      be ordered.  On the other hand, there are times when not only do
      we have a key type that can be ordered, but also we need to
      access the keys in increasing order (for example, to print an
      ordered list of keys with their values).  In such cases, what we
      actually need is an <i>ordered dictionary</i>, which both
      restricts the keys in this way and provides a means of accessing
      them in increasing order.  While we won't consider the full
      implementation of an ordered dictionary here, it is worth
      considering how we can improve performance by keeping the keys
      in increasing order.
    </p>
    Let's now consider how to add a key and value to a linked list
    storing keys in increasing order.  We first need to find where the
    key belongs in the
    ordering.  Specifically, the cell whose <b>Next</b> property needs
    to be changed (assuming the key is not already in the list) is the
    one that must precede the new cell.  We therefore need to find the
    last cell whose key is less than the key we need to add.  Note
    also that when we are removing a key, the cell whose <b>Next</b>
    property needs to be changed is the last cell whose key is less
    than the key we are removing.  Furthermore, if we are looking up a
    key, we need to look in the cell that follows the last cell whose
    key is less than the key we are looking for.  This suggests that
    we should provide a <b>private</b> method to find the last cell
    whose key is less than a given key.
    <p>
    </p>
    Before we can write such a method, however, we first need to
    address a problem that occurs if we are trying to add, remove, or
    look up a key that is smaller than all other keys in the list.  In
    this case, there are no cells containing keys smaller than the
    given key.
    <p>
      We can avoid needing a special case to deal with this problem
      if we include a special <i>header cell</i> at the beginning of
      our linked list.  This cell will not contain any meaningful
      data, but it will always be present.  If we consider that its
      key is less than any other key (though we will never actually
      examine its key), then there will always be at least one key
      less than or equal to any given key.  We can obtain this
      header cell by initializing the linked list to contain a new
      cell, rather than to <b>null</b>.
    </p>
    A method to find the last cell containing a key less than a given
    key is now straightforward.  We initialize a variable to the
    first cell (i.e., the header cell), and set up a loop that
    iterates as long as the <i>next</i> cell is non-<b>null</b> and
    contains a key less than the given key.  Each iteration advances
    to the next cell.  When the loop terminates, we return the cell we
    have reached.
    <p>
      To look up a key, we use the above method to find the last cell
      containing a key less than the key we are looking for.  If the
      next cell is non-<b>null</b> and contains the key we are looking
      for, then we have found it; otherwise, it cannot be in the
      list.  To add a key and value, we first need to look up the key
      in the same way.  If we don't find it, we insert a new cell
      containing this key and value following the last cell containing
      a key less than this key.  To remove a key, we proceed in a
      similar way, but if we find the key, we remove this cell from
      the list.
    </p>
    While keeping the keys in increasing order improves the
    performance of many searches, the overall performance is still
    unsatisfactory for even data sets of moderate size.  In subsequent
    sections, we will explore ways of improving this performance using
    various data structures.
    
<p></p>
<div class="NAVBAR">
<a href="/~rhowell/DataStructures/redirect/dictionary-class">Previous:
      The <b>Dictionary&lt;TKey,&nbsp;TValue&gt;</b> Class
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/linked-lists">Up: Linked Lists
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Mon Feb 19 10:20:29 CST 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
