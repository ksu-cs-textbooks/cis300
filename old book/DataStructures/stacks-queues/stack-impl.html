<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Implementing a Stack</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Implementing a Stack</h1>

This section gives an overview of perhaps the most common way to
    implement a stack.  For example, the implementations of both
    <b>System.Collections.Stack</b> and
    <b>System.Collections.Generic.Stack&lt;T&gt;</b> use this
    technique.  This implementation uses an array to store the 
    elements of the stack, and is quite similar to the <a href="/~rhowell/DataStructures/redirect/stringbuilder-impl"><b>StringBuilder</b>
    implementation</a> we described in the last chapter.  We have
    discussed two kinds of stacks in this chapter - stacks of
    <b>object</b>s and generic stacks.  We will focus on implementing
    a generic stack in this section, as it is easy to modify such an
    implementation to be non-generic.
<p>
<a name="generic"></a>
We first need to consider how to define a generic class.  In the
      simplest case, we simply add a type parameter to the
      <b>class</b> statement, as follows:
<pre>
public class Stack&lt;T&gt;
{
    . . .
}
</pre>
Within this <b>class</b> definition, <b>T</b> is treated like
    any other type, except that the compiler knows nothing about it.
    We can declare fields, parameters, and local variables to be of
    type <b>T</b>.  Even though the compiler knows nothing about
    <b>T</b>, it will still do type checking - you cannot assign an
    expression of any other type to a variable of type <b>T</b>, and
    you can only assign an expression of type <b>T</b> to variables of
    either type <b>T</b> or type <b>object</b> (because any type is a
    subtype of <b>object</b>).  In general, we can define generic data
    types with any number of type parameters if more that one generic type is
    needed by the data structure.  To do this, we would
    list the type parameters, separated by commas, between the '&lt;'
    and '&gt;' symbols of the generic 
    <b>class</b> definition.  Each of the type parameters is then
    treated as a type 
    within the <b>class</b> definition.  We will show how the types
    passed as type parameters can be restricted in <a href="/~rhowell/DataStructures/redirect/where">a later
    section</a>.
<p>
For the class <b>Stack&lt;T&gt;</b>, only one type parameter is
      needed.  The type parameter <b>T</b>
      denotes the type of the values that are stored in the stack.
      Therefore, the array in which we will store the elements will be
      of type <b>T[Â ]</b>.  As in the <a href="/~rhowell/DataStructures/redirect/stringbuilder-impl"><b>StringBuilder</b>
      implementation</a>, we will need a <b>private</b> field for this
      array.  This field can be initialized in a
      manner similar to the <b>StringBuilder</b> implementation;
      hence, we don't need to write a constructor.
</p>
A stack has a <b>public</b> read-only property, <b>Count</b>, which
    gets the number of elements in the stack (as an <b>int</b>).  We
    can define this property to use the default implementation with a
    <b>private</b> set accessor, as outlined in the section, "<a href="/~rhowell/DataStructures/redirect/properties">Properties</a>".
<p>
Before we can delve any further into the implementation, we need to
      decide how we are going to arrange the elements in the array.
      Because all of our accesses will be to the top of
      the stack, it makes sense to keep the bottom element of the stack
      at location 0, and as we go up the stack, keep each successive
      element in the next location:  
</p>
<img alt="The arrangement of stack elements in the array." src="stack-impl.jpg"/>
<p>
This arrangement makes sense because unless all of the array locations
      are being used, there is room to push a
      new element on top of the stack without having to move any
      pre-existing elements out of its way.  
</p>
Note the similarity of this arrangement to the <a href="/~rhowell/DataStructures/redirect/stringbuilder-impl">implementation
      of a <b>StringBuilder</b></a>.  Given this similarity, we can
      implement the <b>Push</b> method in a similar way to how we
      implemented the <b>Append</b> method for a
      <b>StringBuilder</b>.  Instead of taking a <b>char</b>
      parameter, the <b>Push</b> method takes a <b>T</b> parameter,
      but this is the type that we can store in the array.  The
      biggest difference in these two methods is that while
      <b>Append</b> returns a <b>StringBuilder</b>, <b>Push</b>
      returns nothing.
<p>
We now need to implement the <b>public</b> methods that retrieve
      elements from the stack.  We will start with the <b>Peek</b>
      method, which takes no parameters and returns a <b>T</b>.  This
      method needs to begin with some error checking: if there are no
      elements in the stack, it needs to throw an
      <b>InvalidOperationException</b>.  We can do this by
      constructing such an exception and throwing it with the
      <b>throw</b> keyword:
</p>
<pre>
throw new InvalidOperationException();
</pre>
If there are elements in the stack, we need to return the one at the
    top.  Note from the figure above that the top element is at the
    location preceding the location indexed by <b>Count</b>.
<p>
The other <b>public</b> method to retrieve an element is the
      <b>Pop</b> method.  This method also takes no parameters and
      returns a <b>T</b>.  Part of what it does we have already
      implemented in the <b>Peek</b> method.  In order to avoid
      duplicating code, we can retrieve the top element using the
      <b>Peek</b> method, and save it in a local variable so that we
      can return it when we are finished with this method (avoiding
      code duplication improves maintainability, as there are fewer
      places that might need to be modified later).  Note that by
      using the <b>Peek</b> method, we are taking advantage of the
      fact that it checks whether the stack is empty; hence, there is
      no need to do that here.  Before we can return the value we
      retrieved, we need to update <b>Count</b> to reflect
      the fact that we are removing one element.
</p>
While what we have described in the preceding paragraph is sufficient
    for correct functioning, there is one issue we need to address.
    Note that we have done nothing to the array location that stored
    the value we popped - it still stores that value.  This fact does
    not impact correctness, however, because after we update the
    number of elements, we are no longer considering that location to
    be storing a stack element - its contents are irrelevant.
    However, there is a performance issue here.  If <b>T</b> is a <a href="/~rhowell/DataStructures/redirect/reference-value">reference
    type</a>, then the reference stored in this location may refer to
    a large data structure that is no longer needed by the program.
    However, because this array still stores a reference to it, the
    garbage collector cannot tell that it is no longer in use, and
    consequently, it cannot reclaim the storage.
<p>
It therefore makes sense to remove what is stored in this array
      location.  However, we run into a difficulty when we try to do
      this.  We can't simply assign <b>null</b> to this location
      because <b>T</b> might be a value type;
      hence, the compiler will not allow such an assignment.  In order
      to address this problem, C# has the keyword, <b>default</b>,
      which can be used to get the default value for a given type.
      Thus, if <b>T</b> is a reference type, <b>default(T)</b> will
      give us <b>null</b>, but if <b>T</b> is a value type, it will
      give us the value whose binary representation is all 0s.  In
      order to free up any memory we might no longer need, it
      therefore makes sense to assign <b>default(T)</b> to an array
      location after we are no longer using it.
</p>
Finally, we can implement a <b>public Clear</b> method.  This method
    takes no parameters and returns nothing.  One way to implement it
    would be to pop all of the elements, one by one, from the stack.
    However, this could be very inefficient if the stack contains a
    lot of elements.  A better way is simply to change <b>Count</b> to
    0; however, this way prevents the garbage collector 
    from reclaiming storage we no longer need.  In order to allow this
    storage to be reclaimed, we should also replace our array with a
    new array of the size we used when we initialized this field (note
    that this is more efficient than replacing every element with the
    default element of the appropriate type).
    Because we are no longer using the old array, the garbage
    collector can reclaim it, along with any otherwise unused data it
    might refer to.
<p>
Due to the similarities between this implementation and the <a href="/~rhowell/DataStructures/redirect/stringbuilder-impl"><b>StringBuilder</b>
	implementation</a>, the two data structures have similar
	performance characteristics.  In fact, it is possible to show
	that any sequence of <i>n</i> operations on an initially empty
	<b>Stack&lt;T&gt;</b> is done in <i>O</i>(<i>n</i>) time -
	i.e., in time proportional to <i>n</i>.
</p>
<p></p>
<p>
</p>
<p></p>
</p></body>
</html>
