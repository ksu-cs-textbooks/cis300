<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Introduction to Graphs</title>
<link href="/~rhowell/style.css" rel="STYLESHEET"/>
</head>
<body>
<h1>Introduction to Graphs</h1>

There are two kinds of graphs: undirected and directed.  An
    <i>undirected graph</i> consists of:
<ul>
<li> a finite set of <i>nodes</i>; and</li>
<li> a finite set of <i>edges</i>, which are 2-element subsets of the
	nodes.</li>
</ul>
The fact that edges are 2-element sets means that the nodes that
    comprise an edge must be distinct.  Furthermore, within a set,
    there is no notion of a "first" element or a "second" element -
    there are just two elements.  Thus, an edge expresses some
    symmetric relationship between two nodes; i.e., if
    {<i>u</i>,Ã‚Â <i>v</i>} is an edge then node <i>u</i> is
    <i>adjacent</i> to node <i>v</i>, and node <i>v</i> is adjacent to
    node <i>u</i>.  We also might
    associate some data, such as a label or a length, with an edge.
<p>
We can think of an edge as "connecting" the two nodes that comprise
    it.  We can then draw an undirected graph using circles for the
    nodes and lines connecting two distinct nodes for the edges.
    Following is an example of an undirected graph with numeric values
    associated with the edges:
</p>
<img alt="An undirected graph" src="undirected-graph.jpg"/>
<p>
A <i>directed graph</i> is similar to an undirected graph, but
      the edges are ordered pairs of distinct nodes rather than
      2-element sets.  Within an ordered pair, there is a
      first element and a second element.  We call the first node of
      an edge its <i>source</i> and the second node its
      <i>destination</i>.  Thus, an edge in a directed
      graph expresses an asymmetric relationship between two nodes;
      i.e., if (<i>u</i>,Ã‚Â <i>v</i>) is an edge, then <i>v</i> is
      adjacent to <i>u</i>, but <i>u</i> is not adjacent to
      <i>v</i> unless (<i>v</i>,Ã‚Â <i>u</i>) is also an edge in the
      graph.  As with undirected graphs, we might associate data with
      an edge in a directed graph.
</p>
We can draw directed graphs like we draw undirected graphs, except
    that we use an arrow to distinguish between the source and the
    destination of an edge.  Specifically, the arrows point from the
    source to the destination.  If we have edges
    (<i>u</i>,Ã‚Â <i>v</i>) and (<i>v</i>,Ã‚Â <i>u</i>), and if
    these edges have the same data associated with them, we might
    simplify the drawing by using a single line with arrows in both
    directions.  Following is an example of a directed graph with
    numeric values associated with the edges:
<p>
<img alt="A directed graph" src="directed-graph.jpg"/>
</p>
<a href="Ksu.Cis300.Graphs.dll">This DLL</a> contains the definition
    of a namespace <b>Ksu.Cis300.Graphs</b> containing a class
    <b>DirectedGraph&lt;TNode,Ã‚Â TEdgeData&gt;</b> and a structure
    <b>Edge&lt;TNode,Ã‚Â TEdgeData&gt;</b>.  The class
    <b>DirectedGraph&lt;TNode,Ã‚Â TEdgeData&gt;</b> 
    implements a directed graph whose nodes are of type <b>TNode</b>,
    which must be a type suitable for hashing.  The edges each store a
    data item of type <b>TEdgeData</b>, which may be any type.   These
    edges can be represented using instances of the
    <b>Edge&lt;TNode,Ã‚Â TEdgeData&gt;</b> structure.  We also
    can use the <b>DirectedGraph&lt;TNode,Ã‚Â TEdgeData&gt;</b>
    class to represent undirected graphs - we simply make
    sure that whenever there is an edge (<i>u</i>,Ã‚Â <i>v</i>),
    there is also an edge (<i>v</i>,Ã‚Â <i>u</i>) containing the
    same data.  
<p>
The <b>Edge&lt;TNode,Ã‚Â TEdgeData&gt;</b> structure contains the
      following <b>public</b> members:
</p>
<ul>
<li> <b>Edge(TNode source, TNode dest, TEdgeData data)</b>: This
      constructor constructs an edge leading from <b>source</b> to 
      <b>dest</b> and having <b>data</b> as its data item.</li>
<li> <b>TNode Source</b>: This property gets the source node for the
      edge.</li>
<li> <b>TNode Destination</b>: This property gets the destination node
      for the edge.</li>
<li> <b>TEdgeData Data</b>: This property gets the data associated
      with the edge.</li>
</ul>
<p>
Note that because no <b>public</b> members change the structure, it is
      immutable.
</p>
The <b>DirectedGraph&lt;TNode,Ã‚Â TEdgeData&gt;</b> class contains
    the following <b>public</b> members:
<ul>
<li> <b>DirectedGraph()</b>: This constructor constructs a directed
	graph with no nodes or edges.</li>
<li> <b>void AddNode(TNode node)</b>: This method adds the given node
	to the graph.  If this node already is in the graph, it throws
	an <b>ArgumentException</b>.  If <tt>node</tt> is
	<b>null</b>, it throws an <b>ArgumentNullException</b>.</li>
<li> <b>void AddEdge(TNode source, TNode dest, TEdgeData value)</b>: This
	method adds a new edge from <tt>source</tt> to <tt>dest</tt>,
	with <tt>value</tt> as its associated value.  If either
	<tt>source</tt> or <tt>dest</tt> is not already 
	in the graph, it is automatically added.  If <tt>source</tt>
	and <tt>dest</tt> are the same node, or if there is already an
	edge from <tt>source</tt> to <tt>dest</tt>, it throws an
	<b>ArgumentException</b>.  If either <tt>source</tt> or
	<tt>dest</tt> is <b>null</b>, it throws an
	<b>ArgumentNullException</b>.</li>
<li> <b>bool TryGetEdge(TNode source, TNode dest, out TEdgeData
	  value)</b>:  This method tries to get the value associated
	  with the edge from <tt>source</tt> to
	  <tt>dest</tt>.  If this edge exists, it sets
	  <tt>value</tt> to the value associated with this edge and
	  returns <b>true</b>; otherwise, it sets <tt>value</tt> to
	  the default value for the <b>TEdge</b> type and returns
	  <b>false</b>.</li>
<li> <b>int NodeCount</b>: This property gets the number of nodes in
	the graph.</li>
<li> <b>int EdgeCount</b>: This property gets the number of edges in
	the graph.</li>
<li> <b>bool ContainsNode(TNode node)</b>:  This method returns
	whether the graph contains the given node.  If <tt>node</tt>
	is <b>null</b>, it throws an
	<b>ArgumentNullException</b>.</li>
<li> <b>bool ContainsEdge(TNode source, TNode dest)</b>:  This method
	returns whether the graph contains an edge from
	<tt>source</tt> to <tt>dest</tt>.</li>
<li> <b>IEnumerable&lt;TNode&gt; Nodes</b>:  This property gets an
	  enumerable collection of the nodes in the graph.</li>
<li> <b>IEnumerable&lt;Edge&lt;TNode,Ã‚Â TEdgeData&gt;&gt;
	  OutgoingEdges(TNode source)</b>: This method gets an
	  enumerable collection of the outgoing edges from the given
	  node.  If <tt>source</tt> is not a node in the graph, it
	  throws an <b>ArgumentException</b>.  If <tt>source</tt> is
	  <b>null</b>, it throws an <b>ArgumentNullException</b>.
	  Otherwise, each edge in the collection returned is
	  represented by an
	  <b>Edge&lt;TNode,Ã‚Â TEdgeData&gt;</b></li>
</ul>
This implementation is somewhat limited in its utility, as nodes or
    edges cannot be removed, and values associated with edges cannot
    be changed.  However, it will be sufficient for our purposes.  We
    will examine its implementation details in <a href="/~rhowell/DataStructures/redirect/graph-impl">a later
    section</a>.  For now, we will examine how it can be used.
<p>
Building a graph is straightforward using the constructor and the
      <b>AddNode</b> and/or <b>AddEdge</b> methods.  Note that because
      the <b>AddEdge</b> method will automatically add given nodes
      that are not already in the graph, the <b>AddNode</b> method is
      only needed when we need to add a node that may have no incoming
      or outgoing edges.
<p>
For many graph algorithms, we need to process all of the edges in some
      way.  Often the order in which we process them is important, but
      not in all cases.  If we simply need to process all of the edges
      in some order we can use <b>foreach</b> loops with the last two
      properties listed above to accomplish this:
</p>
<ul>
<li> For each node in the graph:
<ul>
<li> For each outgoing edge from that node:
<ul>
<li> Process this edge.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p>
<p>
</p>
<p></p>
</p></body>
</html>
