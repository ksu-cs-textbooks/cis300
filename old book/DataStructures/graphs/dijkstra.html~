<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Shortest Paths</title>
<link rel=STYLESHEET href="/~rhowell/style.css">

</head>

<body>
<div class="NAVBAR">
<a
      href="/~rhowell/DataStructures/redirect/unweighted-shortest-paths">Next:
      Unweighted Shortest Paths
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/graph-intro">Previous:
      Introduction to Graphs
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/graphs">Up: Graphs
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<h1>Shortest Paths</h1>

In this section, we will consider a common graph problem - that of
    finding a shortest path from a node <i>u</i> to a node <i>v</i> in
    a directed graph.  We will assume that each edge contains as its
    data a nonnegative number.  This number may represent a physical
    distance or some other cost, but for simplicity, we will refer to
    this value as the <i>length</i> of the edge.  We can then define
    the length of a path to be the sum of the lengths of all the edges
    along that path.  A shortest path from <i>u</i> to <i>v</i> is
    then a path from <i>u</i> to <i>v</i> with minimum length.  Thus,
    for example, the shortest path from <i>a</i> to <i>h</i> in the
    graph below is <i>a</i>-<i>c</i>-<i>g</i>-<i>f</i>-<i>h</i>, and
    its length is 
    4.8&nbsp;+&nbsp;6.4&nbsp;+&nbsp;4.9&nbsp;+&nbsp;3.2&nbsp;=&nbsp;19.3. 
<p>
<img src="directed-graph.jpg" alt="A directed graph">
</p>
The biggest challenge in finding an algorithm for this problem is that
    the number of paths in a graph can be huge, even for relatively
    small graphs.  For example, a directed graph with 15 nodes might
    contain over 10 billion paths from a node <i>u</i> to a node
    <i>v</i>.  Clearly, an algorithm that simply checks all paths
    would be impractical for solving a problem such as finding the
    shortest route between two given points in the US.  In what
    follows, we will present a much more efficient algorithm due to
    Edsger W. Dijkstra.  
<p>
First, it helps to realize that when we are looking for a shortest
      path from <i>u</i> to <i>v</i>, we are likely to find other
      shortest paths along the way.  Specifically, if node <i>w</i> is
      on the shortest path from <i>u</i> to <i>v</i>, then taking that
      same path but stopping at <i>w</i> gives us a shortest path from
      <i>u</i> to <i>w</i>.  Returning to the above example, the
      shortest path from <i>a</i> to <i>h</i> also gives us shortest
      paths from <i>a</i> to each of the nodes <i>c</i>, <i>g</i>, and
      <i>f</i>.  For this reason, we will generalize the problem to
      that of finding the shortest paths from a given node <i>u</i> to
      each of the nodes in the graph.  This problem is known as the
      <i>single-source shortest paths</i> problem.  This problem is a
      bit easier to think about because we can use shortest path
      information that we have already computed to find additional
      shortest path information.  Then once we have an
      algorithm for this problem, we can easily modify it so that as
      soon as it finds the shortest path to our actual goal node
      <i>v</i>, we terminate it.
</p>
Dijkstra's algorithm progresses by finding a shortest path to one node
    at a time.  Let <i>S</i> denote the set of nodes to which it has
    found a shortest path.  Initially, <i>S</i> will contain only
    <i>u</i>, as the shortest path from <i>u</i> to <i>u</i> is the
    empty path.  At each step, it finds a shortest path that begins at
    <i>u</i> and ends at a node outside of <i>S</i>.
    Let's call the last node in this path <i>x</i>.  Certainly, if
    this path to <i>x</i> is the shortest to <i>any</i> node outside
    of <i>S</i>, it is also the shortest to <i>x</i>.  The algorithm
    therefore adds <i>x</i> to <i>S</i>, and continues to the next
    step.
    <p>
      What makes Dijkstra's algorithm efficient is the way in which it
    finds each of the paths described above.  Recall that each edge
    has a nonnegative length.  Hence, once a given path reaches some
    node outside of <i>S</i>, we cannot make the path any shorter by
    extending it further.  We therefore only need to consider
    paths that remain in <i>S</i> until the last edge, which goes from
    a node in <i>S</i> to a node outside of <i>S</i>.  We will refer
    to such edges as <i>eligible</i>.  We are therefore looking for a
    shortest path whose last edge is eligible.
    </p>
    Suppose (<i>w</i>, <i>x</i>) is an eligible edge; i.e., <i>w</i>
    is in <i>S</i>, but <i>x</i> is not.  Because <i>w</i> is in
    <i>S</i>, we know the length of the shortest path to <i>w</i>.
    The length of a shortest path ending in (<i>w</i>, <i>x</i>) is
    simply the length of the shortest path to <i>w</i>, plus the
    length of (<i>w</i>, <i>x</i>).
    <p>
      Let us therefore assign to each eligible edge (<i>w</i>,
      <i>x</i>) a priority equal to the length of the shortest path to
      <i>w</i>, plus the length of (<i>w</i>, <i>x</i>).  A shortest
      path ending in an eligible edge therefore has a length equal to
      the minimum priority of any eligible edge.  Furthermore, if the
      eligible edge with minimum priority is (<i>w</i>, <i>x</i>),
      then the shortest path to <i>x</i> is the shortest path to
	<i>w</i>, followed by (<i>w</i>, <i>x</i>).
    </p>

    We can efficiently find an eligible edge with minimum priority if
      we store all eligible edges in a
      <b>MinPriorityQueue&lt;TEdgeData, Edge&lt;TNode,
      TEdgeData&gt;&gt;</b>.  Note however, that when we include
      <i>x</i> in <i>S</i> as a result of removing (<i>w, x</i>)
      from the queue, it will cause any other eligible edges leading
      to <i>x</i> to become ineligible, as <i>x</i> will no longer be
      outside of <i>S</i>.  Because removing these edges from the
      min-priority queue is difficult,
      we will simply leave them in the queue, and discard them whenever
      they have minimum priority.  This min-priority queue
      will therefore contain all eligible edges, plus some edges whose
      endpoints are both in <i>S</i>.
<p>
      We also need a data structure
      to keep track of the shortest paths we have found.  A convenient
      way to do this is, for each node to which we have found a
      shortest path, to keep track of this node's predecessor on this
      path.  This will allow us to retrieve a shortest path to a node
      <i>v</i> by starting at <i>v</i> and tracing the path backwards
      using the predecessor of each node until we reach <i>u</i>.
      A <b>Dictionary&lt;TNode,&nbsp;TNode&gt;</b> is an
      ideal choice for this data structure.  The keys in the
      dictionary will be the nodes in <i>S</i>, and the value
      associated with a key will be that key's 
      predecessor on a shortest path.  For node <i>u</i>, which is in
      <i>S</i> but has no predecessor on its shortest path, we can
      associate a value of <i>u</i> itself.
</p>
<p>
The algorithm begins by adding the key <i>u</i> with the value
      <i>u</i> to a new dictionary.  Because all of the outgoing edges
      from <i>u</i> are now eligible, it then places each of these
      edges into the min-priority queue.  Because <i>u</i> is the
      source node of each of these edges, and the shortest path from
      <i>u</i> to <i>u</i> has length 0, the priority of each of these
      edges will simply be its length.
</p>
Once the above initialization is done, the algorithm enters a loop
    that iterates as long as the min-priority queue is nonempty.  An
    iteration begins by obtaining the minimum priority <i>p</i> from
    the min-priority queue, then removing an edge
    (<i>w</i>,&nbsp;<i>x</i>) with minimum priority.  If <i>x</i> is a
    key in the dictionary, we can ignore this edge and go on to the
    next iteration.  Otherwise, we add to the dictionary the key
    <i>x</i> with a value of <i>w</i>.  Because we now have a shortest
    path to <i>x</i>, there may be more eligible edges that we need to
    add to the min-priority queue.  These edges will be edges from
    <i>x</i> that lead to nodes that are not keys in the dictionary;
    however, because the min-priority queue can contain edges to nodes
    that are already keys, we can simply add all outgoing edges from
    <i>x</i>.  Because the length of the shortest path to <i>x</i> is
    <i>p</i>, the priority of each of these edges is <i>p</i> plus the
    length of the edge.
<p>
Note that an edge is added to the min-priority queue only when its
      source is added as a key to the dictionary.  Because we can only
      add a key once, each edge is added to the min-priority queue at
      most once.  Because each iteration removes an edge from the
      min-priority queue, the min-priority queue must eventually
      become empty, causing the loop to terminate.  When the
      min-priority queue becomes empty, there can be no eligible
      edges; hence, when the loop terminates, the algorithm has found
      a shortest path to every reachable node.
</p>
We can now modify the above algorithm so that it finds a shortest path
    from <i>u</i> to a given node <i>v</i>.  Each time we add a new
    key to the dictionary, we check to see if this key is <i>v</i>; if
    so, we return the dictionary immediately.  We might also want to
    return this path's length, which is the priority of the edge
    leading to <i>v</i>.  In this case, we could return the
    dictionary as an <b>out</b> parameter.  Doing this would allow us
    to return a special value (e.g., a negative number) if we get
    through the loop without adding <i>v</i>, as this would indicate
    that <i>v</i> is unreachable.  This modified algorithm
    is therefore as follows:
<ul>
<li> Construct a new dictionary and a new min-priority queue.</li>
<li> Add to the dictionary the key <i>u</i> with value <i>u</i>.</li>
<li> If <i>u</i>&nbsp;=&nbsp;<i>v</i>, return 0.</li>
<li> For each outgoing edge (<i>u</i>,&nbsp;<i>w</i>) from <i>u</i>:
<ul>
<li> Add (<i>u</i>,&nbsp;<i>w</i>) to the min-priority queue with a
	    priority of the length of this edge.</li>
</ul>
</li>
<li> While the min-priority queue is nonempty:
<ul>
<li> Get the minimum priority <i>p</i> from the min-priority
	    queue.</li>
<li> Remove an edge (<i>w</i>,&nbsp;<i>x</i>) with minimum priority
	    from the min-priority queue.</li>
<li> If <i>x</i> is not a key in the dictionary:
<ul>
<li> Add to the dictionary the key <i>x</i> with a value of
		<i>w</i>.</li>
<li> If <i>x</i>&nbsp;=&nbsp;<i>v</i>, return <i>p</i>.</li>
<li> For each outgoing edge (<i>x</i>,&nbsp;<i>y</i>) from <i>x</i>:
<ul>
<li> Add (<i>x</i>,&nbsp;<i>y</i>) to the min-priority queue with
		    priority <i>p</i> plus the length of
		    (<i>x</i>,&nbsp;<i>y</i>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li> Return a negative value.
</ul>
The above algorithm computes all of the path information we need, but
    we still need to extract from the dictionary the shortest path
    from <i>u</i> to <i>v</i>.  Because the value for each key is that
    key's predecessor, we can walk backward through this path,
    starting with <i>v</i>.  To get the path in the proper order, we
    can push the nodes onto a stack; then we can remove them in the
    proper order.  Thus, we can extract the shortest path as follows:
<ul>
<li> Construct a new stack.</li>
<li> Set the current node to <i>v</i>.
<li> While the current node is not <i>u</i>:
<ul>
<li> Push the current node onto the stack.</li>
<li> Set the current node to its value in the
	    dictionary.</li>
</ul>
</li>
<li> Process <i>u</i>.</li>
<li> While the stack is not empty:
<ul>
<li> Pop the top node from the stack and process it.</li>
</ul>
</li>
</ul>

<p></p>
<div class="NAVBAR">
<a
      href="/~rhowell/DataStructures/redirect/unweighted-shortest-paths">Next:
      Unweighted Shortest Paths
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/graph-intro">Previous:
      Introduction to Graphs
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/redirect/graphs">Up: Graphs
      </a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a
      href="/~rhowell/DataStructures/">Top</a>
</div>

<p>
<small>
<!-- hhmts start -->
Last modified: Fri Apr 13 14:04:08 CDT 2018
<!-- hhmts end -->
</small>
</p>
<small>
    <i> &copy; Copyright 2014, 2016, 2018, <a
    href="/~rhowell/">Rod Howell</a>. All
    rights reserved.</i> 
</small>

<p></p>

<table border=0 cellpadding=2 summary="This table is used for layout
purposes only.">
<tr>
<td align=center>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="/~rhowell/valid-html401.gif"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
</td>
<tr>
<td>
<a href="http://jigsaw.w3.org/css-validator/check/referer">
             <img border="0"
                  src="/~howell/vcss.gif" 
                  alt="Valid CSS!" height="31" width="88">
            </a>
</td>
</table>

</body>

</html>
