<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Implementing a Dictionary with an Array-Like Structure In the previous section, we discussed how linked lists could be used to implement a dictionary. An alternative to a linked list would be an array. A couple of other alternatives are the non-generic System.Collections.ArrayList or the generic System.Collections.Generic.List<T>. These classes are similar to singly-dimensioned arrays, but they can grow as needed. In this respect, they are like a StringBuilder, but instead of storing chars, an ArrayList stores object?s and a List<T> stores instances of the type parameter T. Elements can be retrieved from instances of these classes using indexing, just like retrieving an element from an array."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><meta name=twitter:description content="Implementing a Dictionary with an Array-Like Structure In the previous section, we discussed how linked lists could be used to implement a dictionary. An alternative to a linked list would be an array. A couple of other alternatives are the non-generic System.Collections.ArrayList or the generic System.Collections.Generic.List<T>. These classes are similar to singly-dimensioned arrays, but they can grow as needed. In this respect, they are like a StringBuilder, but instead of storing chars, an ArrayList stores object?s and a List<T> stores instances of the type parameter T. Elements can be retrieved from instances of these classes using indexing, just like retrieving an element from an array."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/dictionaries/binary-search/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><meta property="og:description" content="Implementing a Dictionary with an Array-Like Structure In the previous section, we discussed how linked lists could be used to implement a dictionary. An alternative to a linked list would be an array. A couple of other alternatives are the non-generic System.Collections.ArrayList or the generic System.Collections.Generic.List<T>. These classes are similar to singly-dimensioned arrays, but they can grow as needed. In this respect, they are like a StringBuilder, but instead of storing chars, an ArrayList stores object?s and a List<T> stores instances of the type parameter T. Elements can be retrieved from instances of these classes using indexing, just like retrieving an element from an array."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Dictionaries"><meta property="article:modified_time" content="2023-06-02T14:36:07-05:00"><meta itemprop=name content="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><meta itemprop=description content="Implementing a Dictionary with an Array-Like Structure In the previous section, we discussed how linked lists could be used to implement a dictionary. An alternative to a linked list would be an array. A couple of other alternatives are the non-generic System.Collections.ArrayList or the generic System.Collections.Generic.List<T>. These classes are similar to singly-dimensioned arrays, but they can grow as needed. In this respect, they are like a StringBuilder, but instead of storing chars, an ArrayList stores object?s and a List<T> stores instances of the type parameter T. Elements can be retrieved from instances of these classes using indexing, just like retrieving an element from an array."><meta itemprop=dateModified content="2023-06-02T14:36:07-05:00"><meta itemprop=wordCount content="1119"><title>Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/dictionaries/binary-search/ rel=canonical type=text/html title="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><link href=/cis300/dictionaries/binary-search/index.xml rel=alternate type=application/rss+xml title="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><link href=/cis300/dictionaries/binary-search/index.print.html rel=alternate type=text/html title="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><link href=/cis300/dictionaries/binary-search/embed.html rel=alternate type=text/html title="Implementing a Dictionary with an Array-Like Structure :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1768892168 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1768892168 defer></script><script src=/cis300/js/search-lunr.min.js?1768892168 defer></script><script src=/cis300/js/search.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1768892168"</script><script src=/cis300/js/lunr/lunr.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1768892168 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1768892168 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1768892168 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1768892168 rel=stylesheet><link href=/cis300/css/theme.min.css?1768892168 rel=stylesheet><link href=/cis300/css/format-html.min.css?1768892168 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/dictionaries/binary-search/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1768892168 rel=stylesheet></head><body class="mobile-support html" data-url=/cis300/dictionaries/binary-search/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable dictionaries" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-dictionary-with-an-array-like-structure>Implementing a Dictionary with an Array-Like Structure</h1></div><h2 id=implementing-a-dictionary-with-an-array-like-structure>Implementing a Dictionary with an Array-Like Structure</h2><p>In <a href=/cis300/dictionaries/linked-list-impl/>the previous
section</a>,
we discussed how linked lists could be used to implement a dictionary.
An alternative to a linked list would be an array. A couple of other
alternatives are the non-generic
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist?view=net-6.0" rel=external target=_blank><strong>System.Collections.ArrayList</strong></a>
or the generic
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0" rel=external target=_blank><strong>System.Collections.Generic.List&lt;T></strong></a>.
These classes are similar to singly-dimensioned arrays, but they can
grow as needed. In this respect, they are like a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0" rel=external target=_blank><strong>StringBuilder</strong></a>,
but instead of storing <strong>char</strong>s, an <strong>ArrayList</strong> stores <strong>object?</strong>s
and a <strong>List&lt;T></strong> stores instances of the type parameter <strong>T</strong>.
Elements can be retrieved from instances of these classes using
indexing, just like retrieving an element from an array.</p><p>Assuming we restrict the keys to be non-nullable sub-types of
<strong>IComparable&lt;TKey></strong>, where <strong>TKey</strong> is the key type, we can store
the keys in order in any of these data structures. We can then search
for a key in the same way as we described for a linked list. However,
such a search can be expensive - to search for a key that is larger than
any key in the dictionary, we need to examine all of the keys. We say
that the performance of this sequential search is in <span class="math align-center">$ O(n) $</span>, where <span class="math align-center">$ n $</span>
is the number of keys in the dictionary. This means that as <span class="math align-center">$ n $</span> grows,
the time required for the search is at worst proportional to <span class="math align-center">$ n $</span>.</p><p>We can improve this performance dramatically for an array or array-like
structure such as an <strong>ArrayList</strong> or a <strong>List&lt;T></strong> using a technique
called <em>binary search</em> (there isn&rsquo;t much we can do to improve the
performance of searching a linked list, as its structure restricts us to
traversing it sequentially). The idea is similar to what humans do when
looking for something in an ordered list such as a dictionary or an
index of a book. Rather than looking sequentially through the sequence,
we first look in the middle and narrow our search space depending on how
what we are looking for compares with what we are looking at. For
example, if we are looking for &ldquo;Les Miserables&rdquo;, we first look in the
middle of the sequence, where we might see &ldquo;Othello&rdquo;. Because &ldquo;Les
Miserables&rdquo; is alphabetically less than &ldquo;Othello&rdquo;, we can narrow the
search space to those titles less than &ldquo;Othello&rdquo;. In the middle of this
search space, we might find the title, &ldquo;Great Expectations&rdquo;. Because
&ldquo;Les Miserables&rdquo; is alphabetically greater than &ldquo;Great Expectations&rdquo;, we
narrow the search space to those titles greater than &ldquo;Great
Expectations&rdquo; and less than &ldquo;Othello&rdquo;. We continue narrowing in this way
until either we find &ldquo;Les Miserables&rdquo; or the search space becomes empty,
implying that the data set does not contain this title.</p><p>In a binary search, each lookup is as nearly as possible in the center
of the search space. This means that each time we look at an entry, we
either find what we are looking for, or we decrease the size of the
search space to at most half its previous size. For large data sets the
search space therefore shrinks rapidly. For example, if we start with
1,000,000 elements and repeatedly reduce the search space to at most
half its previous size, after 20 such reductions, we are left with
nothing. Likewise, if we start with 1,000,000,000 elements, 30 such
reductions in size lead to an empty search space.</p><p>To implement this algorithm, we need to keep track of the search space.
We will use two <strong>int</strong> variables, <code>start</code> and <code>end</code>. <code>start</code> will keep
track of the first index in the search space, while <code>end</code> will keep
track of the first index <em>past</em> the search space, as follows:</p><p><a href=#R-image-377693bb4b1795fcf3ff472fe218fe5e class=lightbox-link><img alt="The search space for binary search" class="border lazy lightbox figure-image" loading=lazy src=/cis300/dictionaries/binary-search/binary-search-space.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-377693bb4b1795fcf3ff472fe218fe5e><img alt="The search space for binary search" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/dictionaries/binary-search/binary-search-space.jpg></a></p><p>The way we have defined <code>end</code> may seem unnatural at first, but because
it simplifies various calculations, it is a common way of describing a
search space. For example, the number of elements in such a search space
is simply the difference between <code>end</code> and <code>start</code>, and to describe an
entire array, we can initialize <code>start</code> to 0 and <code>end</code> to the array&rsquo;s
length.</p><p>We then need a loop to iterate as long as this search space is nonempty
(we can return from inside this loop if we find what we are looking
for). On each iteration, we need to find the midpoint of the search
space. This midpoint is simply the average of <code>start</code> and <code>end</code> - i.e.,
their sum divided by 2. We need to be a bit careful here because we are
doing integer division, which may involve truncation. As a result, we may
not get exactly the average. In any case, we need to ensure that the
index we compute is within the search space - otherwise, we may not
reduce the search space, and an infinite loop will result. Because the
search space is nonempty, <code>start</code> &lt; <code>end</code>; hence, the true
average is strictly between <code>start</code> and <code>end</code>. If this average is not an
integer, the result will be rounded down to the next smaller integer.
Because <code>start</code> is an integer, this result will be no less than <code>start</code>,
but less than <code>end</code>; hence it will be in the search space.</p><p>Once we have computed this midpoint, we need to compare the key of the
element at that location with the key we are looking for. Recall that we
use the <strong>CompareTo</strong> method to do this comparison. Note that for large
key types, the <strong>CompareTo</strong> method can be expensive. For this reason,
it is best to call the <strong>CompareTo</strong> method only once for a given pair
of keys, and if necessary, save the result it returns in order to make
more than one comparison between this result and 0.</p><p>Thus, once we have obtained the result of the <strong>CompareTo</strong> method, we
need to determine which of the three cases we have. If the keys are
equal, we should be able to return. If the key we are looking for is
less than the key at the midpoint, we need to adjust <code>end</code>. Otherwise,
we need to adjust <code>start</code>. We are then ready for the next iteration of
the loop.</p><p>If the loop finishes without returning, then the search space is empty;
hence, the key we are looking for is not in the data set. However,
<code>start</code> will end up at the point at which this key could be inserted;
hence, the binary search can be used for both lookups and insertions.</p><p>Binary search is a very efficient way to search an ordered array-like
structure. In particular, it always makes no more than <span class="math align-center">$ O(\log n) $</span>
comparisons, where <span class="math align-center">$ n $</span> is the number of elements in the data set. The
<span class="math align-center">$ \log $</span> function grows very slowly - much more slowly than <span class="math align-center">$ n $</span>.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1768892168></script><script src=/cis300/js/clipboard/clipboard.min.js?1768892168 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1768892168 defer></script><script src=/cis300/js/theme.min.js?1768892168 defer></script></div><script src=/cis300/js/tele-scroll.min.js?1768892168 defer></script></body></html>