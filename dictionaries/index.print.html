<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by ."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dictionaries :: Data Structures in C#"><meta name=twitter:description content="Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by ."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/dictionaries/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Dictionaries :: Data Structures in C#"><meta property="og:description" content="Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by ."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Dictionaries :: Data Structures in C#"><meta itemprop=description content="Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by ."><meta itemprop=dateModified content="2023-06-02T14:36:07-05:00"><meta itemprop=wordCount content="98"><title>Dictionaries :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723838946 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723838946 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723838946 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723838946 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723838946 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723838946 rel=stylesheet><link href=/cis300/css/fonts.css?1723838946 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723838946 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723838946 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723838946 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723838946 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723838946 rel=stylesheet><link href=/cis300/css/print.css?1723838946 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723838946 rel=stylesheet><script src=/cis300/js/variant.js?1723838946></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723838946 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/dictionaries/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Dictionaries</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/linked-lists/sieve-eratosthenes/ title="Finding Prime Numbers (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/dictionaries/dictionary-tkey-tvalue/ title="The Dictionary<TKey, TValue> Class (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=dictionaries>Dictionaries</h1></div><h2 id=dictionaries>Dictionaries</h2><p>A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique <em>key</em>. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by .NET. We will then consider two ways of implementing dictionaries. Later chapters will examine improvements over these implementations.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Dictionaries</h1><article class=default><header class=headline></header><div hidden><h1 id=the-dictionary-class>The Dictionary&lt;TKey, TValue> Class</h1></div><h2 id=the-dictionarytkeytvalue-class>The <strong>Dictionary&lt;TKey, TValue></strong> Class</h2><p>In this section, we will discuss the use of the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-6.0" rel=external target=_blank><strong>Dictionary&lt;TKey, TValue></strong></a>
class, which implements a dictionary. In <a href=/cis300/dictionaries/linked-list-impl/>the next
section</a>, we
will discuss how this data structure can be implemented using a linked
list. In subsequent sections, we will consider alternative
implementations.</p><p>Note that the <strong>Dictionary&lt;TKey, TValue></strong> type has two type parameters,
<strong>TKey</strong> and <strong>TValue</strong>. <strong>TKey</strong> is the type of the keys, and
<strong>TValue</strong> is the type of the values (i.e., the data elements associated
with the keys). Keys must always be non-<strong>null</strong> &mdash; any attempt to use a
<strong>null</strong> key will result in an <strong>ArgumentNullException</strong>. A
<strong>Dictionary&lt;TKey, TValue></strong>&rsquo;s most basic <strong>public</strong> methods are:</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.add?view=net-6.0#system-collections-generic-dictionary-2-add(-0-1)" rel=external target=_blank><strong>void Add(TKey key, TValue
value)</strong></a>:
Associates the given value with the given key. If there is already a
value associated with the given key, it throws an
<strong>ArgumentException</strong>.</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.remove?view=net-6.0#system-collections-generic-dictionary-2-remove(-0-1@)" rel=external target=_blank><strong>bool Remove(TKey
key)</strong></a>:
Removes the given key and its associated value from the dictionary,
and returns whether the key was found.</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.trygetvalue?view=net-6.0#system-collections-generic-dictionary-2-trygetvalue(-0-1@)" rel=external target=_blank><strong>bool TryGetValue(TKey key, out TValue?
value)</strong></a>:
Returns whether the given key is in the dictionary. If so, the
<a href=/cis300/appendix/syntax/out-ref/><strong>out</strong>
parameter</a>
<code>value</code> is assigned the value associated with <code>key</code>; otherwise,
<code>value</code> is assigned the <a href=/cis300/stacks-queues/stack-impl/#default-value>default
value</a> for its
type.</li></ul><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>The type of the <code>value</code> parameter for <strong>TryGetValue</strong> is actually <strong>TValue</strong>, not <strong>TValue?</strong>. Another kind of annotation is used to indicate that this <strong>out</strong> parameter may be <strong>null</strong> only when the method returns <strong>false</strong>. Because such annotations are beyond the scope of CIS 300, we will treat this parameter as if it were simply defined as being nullable.</p></div></div><p>The above methods can be used for building and updating a
<strong>Dictionary</strong>, as well as for looking up values by their keys. It is
also possible to do updates and lookups using indexing. Specifically, a
key may be used as an index in a <strong>Dictionary</strong>, as if the
<strong>Dictionary</strong> were an array. For example, suppose that <code>dictionary</code> is
a <strong>Dictionary&lt;TKey, TValue></strong>, <code>k</code> is a <strong>TKey</strong>, and <code>v</code> is a
<strong>TValue</strong>. We can then do the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>dictionary</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=p>=</span> <span class=n>v</span><span class=p>;</span></span></span></code></pre></div><p>This will associate the value <code>v</code> with the key <code>k</code>, as the <strong>Add</strong>
method does; however, its behavior is slightly different if <code>k</code> already
has a value associated with it. Whereas the <strong>Add</strong> method would throw
an exception in this case, using the indexer will simply replace the
value previously associated with <code>k</code> by the new value <code>v</code>. Thus, we use
the <strong>Add</strong> method when we expect the key to be a new key for the
dictionary, but we use the indexer when we want to associate the value
with the key, regardless of whether the key is already in the
dictionary.</p><p>Likewise, we can use the indexer to look up a key:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>v</span> <span class=p>=</span> <span class=n>dictionary</span><span class=p>[</span><span class=n>k</span><span class=p>];</span></span></span></code></pre></div><p>Again, the behavior is similar to the <strong>TryGetValue</strong> method, but
slightly different, as there is no <strong>bool</strong> in the above statement. When
using the indexer, if the key is not in the dictionary, it will throw a
<strong>KeyNotFoundException</strong>. Thus, we use the indexer when we expect the
key to be in the dictionary, but we use the <strong>TryGetValue</strong> method when
we don&rsquo;t know if the key is in the dictionary.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-dictionary-with-a-linked-list>Implementing a Dictionary with a Linked List</h1></div><h2 id=implementing-a-dictionary-with-a-linked-list>Implementing a Dictionary with a Linked List</h2><p>One way of implementing a dictionary is to store all the keys and values
in a linked list. We want to do this in such a way that a key is stored
together with its associated value. To facilitate this, .NET
provides a structure
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2?view=net-6.0" rel=external target=_blank><strong>KeyValuePair&lt;TKey, TValue></strong></a>
in the <strong>System.Collections.Generic</strong> namespace. This structure is used
simply for storing a key and a value. The type parameter <strong>TKey</strong> is
used to define the type of the keys, and the other type parameter
<strong>TValue</strong> is used to define the type of the values. It has two
<strong>public</strong> properties:</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.key?view=net-6.0#system-collections-generic-keyvaluepair-2-key" rel=external target=_blank><strong>Key</strong></a>,
which gets the key stored; and</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.value?view=net-6.0#system-collections-generic-keyvaluepair-2-value" rel=external target=_blank><strong>Value</strong></a>,
which gets the value stored.</li></ul><p>Note that neither of these properties can be set; i.e., the structure is
immutable. In order to set the key and value, we need to construct a new
instance using its <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.keyvaluepair-2.-ctor?view=net-6.0#system-collections-generic-keyvaluepair-2-ctor(-0-1)" rel=external target=_blank>2-parameter
constructor</a>.
The first parameter to this constructor is the key, and the second is
the value.</p><p>Now that we have a way of storing keys and values together, we can
implement a <strong>Dictionary&lt;TKey, TValue></strong> with a linked list
comprised of instances of
<strong>LinkedListCell&lt;KeyValuePair&lt;TKey, TValue>></strong>. Thus, each
cell of the list stores as its <strong>Data</strong> a
<strong>KeyValuePair&lt;TKey, TValue></strong> containing a key and its
associated value. To add a key and a value, we first need to search the
list for a cell containing that key. If we find such a cell, we either
replace the <strong>KeyValuePair</strong> in that cell with a new <strong>KeyValuePair</strong>
containing the given key and value, or we throw an exception, depending
on the specific behavior required. If we don&rsquo;t find such a cell, we
insert a new cell containing the given key and value. Because it doesn&rsquo;t
matter where we insert it, we might as well insert it at the beginning
of the list, as that is the easiest way. We can remove a key using
techniques described in &ldquo;<a href=/cis300/linked-lists/sieve-eratosthenes/>Finding Prime
Numbers&rdquo;</a>.</p><p>The main disadvantage to this approach is that searching for a key is
expensive. For example, to search for a key that is not in the
dictionary, we need to examine every key in the dictionary. We would
like to improve on this performance.</p><p>One way of improving the performance of searching is to store the keys
in increasing order. Then as we search, if we see a key that is larger
than the key we are looking for, we can stop. However, recall that keys
can be of any type. For some types of keys, &ldquo;increasing order&rdquo; and
&ldquo;larger than&rdquo; make no sense.</p><p><span id=where></span> C# does provide a way to restrict the types
that can be passed as type parameters to generic types. Specifically, we
can restrict the type <strong>TKey</strong> by writing the <strong>class</strong> statement as
follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Dictionary</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>,</span> <span class=n>TValue</span><span class=p>&gt;</span> <span class=k>where</span> <span class=n>TKey</span> <span class=p>:</span> <span class=n>notnull</span><span class=p>,</span> <span class=n>IComparable</span><span class=p>&lt;</span><span class=n>TKey</span><span class=p>&gt;</span>   </span></span></code></pre></div><p>The <strong>where</strong> clause in this statement constrains <strong>TKey</strong> in two ways:</p><ul><li><p><code>notnull</code> constrains it to be a <a href=/cis300/appendix/syntax/reference-value/#nullable-types>non-nullable</a> type. The compiler doesn&rsquo;t actually enforce this constraint, but will give a warning if a nullable type is used for <strong>TKey</strong>.</p></li><li><p><code>IComparable&lt;TKey></code> constrains it to be a
subtype of
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1?view=net-6.0" rel=external target=_blank><strong>IComparable&lt;TKey></strong></a>.
Each subtype of <strong>IComparable&lt;TKey></strong> contains a method <a href="https://learn.microsoft.com/en-us/dotnet/api/system.icomparable-1.compareto?view=net-6.0#system-icomparable-1-compareto(-0)" rel=external target=_blank><strong>public int
CompareTo(TKey?
x)</strong></a>. If <code>a</code>
and <code>b</code> are of type <strong>TKey</strong>, then <code>a.CompareTo(b)</code> returns:</p><ul><li>A negative number if <code>a</code> is considered to be less than <code>b</code>;</li><li>0 if <code>a</code> is considered to be equal to <code>b</code>; or</li><li>A positive number if <code>a</code> is considered to be greater than <code>b</code> or if <code>b</code> is <strong>null</strong>.</li></ul></li></ul><p>We can therefore use this <strong>CompareTo</strong> method to keep the list in
increasing order.</p><p>Note that by constraining the key type in this way, we are making the
<strong>Dictionary&lt;TKey, TValue></strong> less general, as we may sometimes want
to use a key type that can&rsquo;t be ordered. On the other hand, there are
times when not only do we have a key type that can be ordered, but also
we need to access the keys in increasing order (for example, to print an
ordered list of keys with their values). In such cases, what we actually
need is an <em>ordered dictionary</em>, which both restricts the keys in this
way and provides a means of accessing them in increasing order. While we
won&rsquo;t consider the full implementation of an ordered dictionary here, it
is worth considering how we can improve performance by keeping the keys
in increasing order.</p><p>Let&rsquo;s now consider how to add a key and value to a linked list storing
keys in increasing order. We first need to find where the key belongs in
the ordering. Specifically, the cell whose <strong>Next</strong> property needs to be
changed (assuming the key is not already in the list) is the one that
must precede the new cell. We therefore need to find the last cell whose
key is less than the key we need to add. Note also that when we are
removing a key, the cell whose <strong>Next</strong> property needs to be changed is
the last cell whose key is less than the key we are removing.
Furthermore, if we are looking up a key, we need to look in the cell
that follows the last cell whose key is less than the key we are looking
for. This suggests that we should provide a <strong>private</strong> method to find
the last cell whose key is less than a given key, provided such a cell exists.</p><p>Before we can write such a method, however, we first need to address a
problem that occurs if we are trying to add, remove, or look up a key
that is smaller than all other keys in the list. In this case, there are
no cells containing keys smaller than the given key.</p><p>We can avoid needing a special case to deal with this problem if we
include a special <em>header cell</em> at the beginning of our linked list.
This cell will not contain any meaningful data, but it will always be
present. If we consider that its key is less than any other key (though
we will never actually examine its key), then there will always be at
least one key less than any given key. We can obtain this
header cell by initializing the linked list to contain a new cell containing the <a href=/cis300/stacks-queues/stack-impl/#default-value>default</a> key-value pair,
rather than to <strong>null</strong>. Note that because the linked list will always contain at least the header cell, the reference to it should <em>not</em> be nullable.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Setting the data in the header cell to the default key-value pair means that if the key type and/or the value type is a reference type, then it will be <strong>null</strong> in this pair, even if the type isn&rsquo;t nullable. There is no way to avoid this, as the only key and value objects that we know of are the default values, which may be <strong>null</strong>. However, it doesn&rsquo;t make sense to use <strong>KeyValuePair&lt;TKey?, TValue?></strong> as the type of the data items within the linked list just because of the header cell, whose data we don&rsquo;t intend to use. Furthermore, the compiler won&rsquo;t generate a warning when <strong>KeyValuePair&lt;TKey, TValue></strong> is used. We should therefore use this latter type, and be sure not to use the data stored in the header cell. We should also include a warning of possible null values in a comment when we initialize the header cell.</p></div></div><p>A method to find the last cell containing a key less than a given key is
now straightforward. We initialize a variable to the first cell (i.e.,
the header cell), and set up a loop that iterates as long as the <em>next</em>
cell is non-<strong>null</strong> and contains a key less than the given key. Each
iteration advances to the next cell. When the loop terminates, we return
the cell we have reached.</p><p>To look up a key, we use the above method to find the last cell
containing a key less than the key we are looking for. If the next cell
is non-<strong>null</strong> and contains the key we are looking for, then we have
found it; otherwise, it cannot be in the list. To add a key and value,
we first need to look up the key in the same way. If we don&rsquo;t find it,
we insert a new cell containing this key and value following the last
cell containing a key less than this key. To remove a key, we proceed in
a similar way, but if we find the key, we remove this cell from the
list.</p><p>While keeping the keys in increasing order improves the performance of
many searches, the overall performance is still unsatisfactory for even
data sets of moderate size. In subsequent sections, we will explore ways
of improving this performance using various data structures.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-dictionary-with-an-array-like-structure>Implementing a Dictionary with an Array-Like Structure</h1></div><h2 id=implementing-a-dictionary-with-an-array-like-structure>Implementing a Dictionary with an Array-Like Structure</h2><p>In <a href=/cis300/dictionaries/linked-list-impl/>the previous
section</a>,
we discussed how linked lists could be used to implement a dictionary.
An alternative to a linked list would be an array. A couple of other
alternatives are the non-generic
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist?view=net-6.0" rel=external target=_blank><strong>System.Collections.ArrayList</strong></a>
or the generic
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-6.0" rel=external target=_blank><strong>System.Collections.Generic.List&lt;T></strong></a>.
These classes are similar to singly-dimensioned arrays, but they can
grow as needed. In this respect, they are like a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder?view=net-6.0" rel=external target=_blank><strong>StringBuilder</strong></a>,
but instead of storing <strong>char</strong>s, an <strong>ArrayList</strong> stores <strong>object?</strong>s
and a <strong>List&lt;T></strong> stores instances of the type parameter <strong>T</strong>.
Elements can be retrieved from instances of these classes using
indexing, just like retrieving an element from an array.</p><p>Assuming we restrict the keys to be non-nullable sub-types of
<strong>IComparable&lt;TKey></strong>, where <strong>TKey</strong> is the key type, we can store
the keys in order in any of these data structures. We can then search
for a key in the same way as we described for a linked list. However,
such a search can be expensive - to search for a key that is larger than
any key in the dictionary, we need to examine all of the keys. We say
that the performance of this sequential search is in
<span class="math align-center">$ O(n) $</span>, where
<span class="math align-center">$ n $</span>
is the number of keys in the dictionary. This means that as
<span class="math align-center">$ n $</span> grows,
the time required for the search is at worst proportional to
<span class="math align-center">$ n $</span>.</p><p>We can improve this performance dramatically for an array or array-like
structure such as an <strong>ArrayList</strong> or a <strong>List&lt;T></strong> using a technique
called <em>binary search</em> (there isn&rsquo;t much we can do to improve the
performance of searching a linked list, as its structure restricts us to
traversing it sequentially). The idea is similar to what humans do when
looking for something in an ordered list such as a dictionary or an
index of a book. Rather than looking sequentially through the sequence,
we first look in the middle and narrow our search space depending on how
what we are looking for compares with what we are looking at. For
example, if we are looking for &ldquo;Les Miserables&rdquo;, we first look in the
middle of the sequence, where we might see &ldquo;Othello&rdquo;. Because &ldquo;Les
Miserables&rdquo; is alphabetically less than &ldquo;Othello&rdquo;, we can narrow the
search space to those titles less than &ldquo;Othello&rdquo;. In the middle of this
search space, we might find the title, &ldquo;Great Expectations&rdquo;. Because
&ldquo;Les Miserables&rdquo; is alphabetically greater than &ldquo;Great Expectations&rdquo;, we
narrow the search space to those titles greater than &ldquo;Great
Expectations&rdquo; and less than &ldquo;Othello&rdquo;. We continue narrowing in this way
until either we find &ldquo;Les Miserables&rdquo; or the search space becomes empty,
implying that the data set does not contain this title.</p><p>In a binary search, each lookup is as nearly as possible in the center
of the search space. This means that each time we look at an entry, we
either find what we are looking for, or we decrease the size of the
search space to at most half its previous size. For large data sets the
search space therefore shrinks rapidly. For example, if we start with
1,000,000 elements and repeatedly reduce the search space to at most
half its previous size, after 20 such reductions, we are left with
nothing. Likewise, if we start with 1,000,000,000 elements, 30 such
reductions in size lead to an empty search space.</p><p>To implement this algorithm, we need to keep track of the search space.
We will use two <strong>int</strong> variables, <code>start</code> and <code>end</code>. <code>start</code> will keep
track of the first index in the search space, while <code>end</code> will keep
track of the first index <em>past</em> the search space, as follows:</p><p><a href=#R-image-9d5e45cb2657bbc1b9c58dc1d857813c class=lightbox-link><img alt="The search space for binary search" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/dictionaries/binary-search/binary-search-space.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-9d5e45cb2657bbc1b9c58dc1d857813c><img alt="The search space for binary search" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/dictionaries/binary-search/binary-search-space.jpg></a></p><p>The way we have defined <code>end</code> may seem unnatural at first, but because
it simplifies various calculations, it is a common way of describing a
search space. For example, the number of elements in such a search space
is simply the difference between <code>end</code> and <code>start</code>, and to describe an
entire array, we can initialize <code>start</code> to 0 and <code>end</code> to the array&rsquo;s
length.</p><p>We then need a loop to iterate as long as this search space is nonempty
(we can return from inside this loop if we find what we are looking
for). On each iteration, we need to find the midpoint of the search
space. This midpoint is simply the average of <code>start</code> and <code>end</code> - i.e.,
their sum divided by 2. We need to be a bit careful here because we are
doing integer division, which may involve truncation. As a result, we may
not get exactly the average. In any case, we need to ensure that the
index we compute is within the search space - otherwise, we may not
reduce the search space, and an infinite loop will result. Because the
search space is nonempty, <code>start</code> &lt; <code>end</code>; hence, the true
average is strictly between <code>start</code> and <code>end</code>. If this average is not an
integer, the result will be rounded down to the next smaller integer.
Because <code>start</code> is an integer, this result will be no less than <code>start</code>,
but less than <code>end</code>; hence it will be in the search space.</p><p>Once we have computed this midpoint, we need to compare the key of the
element at that location with the key we are looking for. Recall that we
use the <strong>CompareTo</strong> method to do this comparison. Note that for large
key types, the <strong>CompareTo</strong> method can be expensive. For this reason,
it is best to call the <strong>CompareTo</strong> method only once for a given pair
of keys, and if necessary, save the result it returns in order to make
more than one comparison between this result and 0.</p><p>Thus, once we have obtained the result of the <strong>CompareTo</strong> method, we
need to determine which of the three cases we have. If the keys are
equal, we should be able to return. If the key we are looking for is
less than the key at the midpoint, we need to adjust <code>end</code>. Otherwise,
we need to adjust <code>start</code>. We are then ready for the next iteration of
the loop.</p><p>If the loop finishes without returning, then the search space is empty;
hence, the key we are looking for is not in the data set. However,
<code>start</code> will end up at the point at which this key could be inserted;
hence, the binary search can be used for both lookups and insertions.</p><p>Binary search is a very efficient way to search an ordered array-like
structure. In particular, it always makes no more than
<span class="math align-center">$ O(\log n) $</span>
comparisons, where
<span class="math align-center">$ n $</span> is the number of elements in the data set. The
<span class="math align-center">$ \log $</span> function grows very slowly - much more slowly than
<span class="math align-center">$ n $</span>.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Rod Howell
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/82b49dc44407dc20da5b3346d3cc9ddb1a0b642d>Jun 2, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723838946 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723838946 defer></script><script>function useMathJax(e){window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},e)}useMathJax(JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1723838946></script><script src=/cis300/js/theme.js?1723838946 defer></script></body></html>