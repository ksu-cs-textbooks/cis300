[
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/",
	"title": "C# Syntax",
	"tags": [],
	"description": "",
	"content": "C# Syntax This chapter discusses various C# features that are either unavailable in Java or are unlikely to have been covered in an introductory Java programming class. No attempt has been made to be exhaustive. Instead, we focus mainly on those features that are likely to be needed in CIS 300. In addition, the following topics are covered in the main text, rather than in this appendix:\n Generic Types Interfaces Overriding virtual Methods Operator Overloading The using Statement Equality Type Casting  For more information on C#, see the C# Reference manual and the C# Programming Guide.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/reference-value/",
	"title": "Reference Types and Value Types",
	"tags": [],
	"description": "",
	"content": "Reference Types and Value Types Data types in C# come in two distinct flavors: value types and reference types. In order to understand the distinction, it helps to consider how space is allocated in C#. Whenever a method is called, the space needed to execute that method is allocated from a data structure known as the call stack. The space for a method includes its local variables, including its parameters (except for out or ref parameters). The organization of the call stack is shown in the following figure:\nWhen the currently-running method makes a method call, space for that method is taken from the beginning of the unused stack space. When the currently-running method returns, its space is returned to the unused space. Thus, the call stack works like the array-based implementation of a stack, and this storage allocation is quite efficient.\nWhat is stored in the space allocated for a variable depends on whether the variable is for a value type or a reference type. For a value type, the value of the variable is stored directly in the space allocated for it. There are two kinds of value types: structures and enumerations. Examples of structures include numeric types such as int, double, and char. An example of an enumeration is DialogResult (see \u0026quot;MessageBoxes\u0026quot; and “File Dialogs”).\nBecause value types are stored directly in variables, whenever a value is assigned to a variable of a value type, the entire value must be written to the variable. For performance reasons, value types therefore should be fairly small.\nFor reference types, the values are not stored directly into the space allocated for the variable. Instead, the variable stores a reference, which is like an address where the value of the variable can actually be found. When a reference type is constructed with a new expression, space for that instance is allocated from a large data structure called the heap (which is unrelated to a heap used to implement a priority queue). Essentially, the heap is a large pool of available memory from which space of different sizes may be allocated at any time. We will not go into detail about how the heap is implemented, but suffice it to say that it is more complicated and less efficient than the stack. When space for a reference type is allocated from the heap, a reference to that space is stored in the variable. Larger data types are more efficiently implemented as reference types because an assignment to a variable of a reference type only needs to write a reference, not the entire data value.\nThere are three kinds of reference types: classes, interfaces, and delegates. Delegates are used to represent individual methods, and are beyond the scope of this course.\nVariables of a reference type do not need to refer to any data value. In this case, they store a value of null (variables of a value type cannot store null). Any attempt to access a method, property, or other member of a null or to apply an index to it will result in a NullReferenceException.\nThe fields of classes or structures are stored in a similar way, depending on whether the field is a value type or a reference type. If it is a value type, the value is stored directly in the field, regardless of whether that field belongs to an object allocated from the stack or the heap. If it is a reference type, it stores either null or a reference to an object allocated from the heap.\nThe difference between value types and reference types can be illustrated with the following code example:\nprivate int[] DoSomething(int i, int j) { Point a = new Point(i, j); Point b = a; a.X = i + j; int[] c = new int[10]; int[] d = c; c[0] = b.X; return d; } Suppose this method is called as follows:\nint[] values = DoSomething(1, 2); The method contains six local variables: i, j, a, b, c, and d. int is a structure, and hence a value type. Point is a structure (and hence a value type) containing public int properties X and Y, each of which can be read or modified. int[ ], however, is a reference type. Space for all six of these variables is allocated from the stack, and the space for the two Points includes space to store two int fields for each. The values 1 and 2 passed for i and j, respectively, are stored directly in these variables.\nThe constructor in the first line of the method above sets the X property of a to 1 and the Y property of a to 2. The next statement simply copies the value of a - i.e., the point (1, 2) - to b. Thus, when the X property of a is then changed to 3, b is unchanged - it still contains the point (1, 2).\nOn the other hand, consider what happens when something similar is done with array variables. When c is constructed, it is assigned a new array allocated from the heap and containing 10 locations. These 10 locations are automatically initialized to 0. However, because an array is a reference type, the variable c contains a reference to the actual array object, not the array itself. Thus, when c is copied to d, the array itself is not copied - the reference to the array is copied. Consequently, d and c now refer to the same array object, not two different arrays that look the same. Hence, after we assign c[0] a value of 1, d[0] will also contain a value of 1 because c and d refer to the same array object. (If we want c and d to refer to different array objects, we need to construct a new array for each variable and make sure each location of each array contains the value we want.) The array returned therefore resides on the heap, and contains 1 at index 0, and 0 at each of its other nine locations. The six local variables are returned to unused stack space; however, because the array was allocated from the heap, the calling code may continue to use it.\nBecause classes are reference types, it is possible for the definition of a class C to contain one or more fields of type C; for example:\npublic class C { private C _nextC; . . . } Such circularity would be impossible for a value type because there would not be room for anything else if we tried to include a value of type C within a value of type C. However, because C is a class, and hence a reference type, _nextC simply contains a reference to some object of type C. When the runtime system constructs an instance of type C, it just needs to make it large enough to hold a reference, along with any other fields defined within C. Such recursive definitions are a powerful way to link together many instances of a type. See \u0026ldquo;Linked Lists\u0026rdquo; and \u0026ldquo;Trees\u0026rdquo; for more information.\nBecause all types in C# are subtypes of object, which is a reference type, every value type is a subtype of at least one reference type (however, value types cannot themselves have subtypes). It is therefore possible to assign an instance of a value type to a variable of a reference type; for example:\nobject x = 3; When this is done, a boxed version of the value type is constructed, and the value copied to it. The boxed version of the value type is just like the original value type, except that it is allocated from the heap and accessed by reference, not by value. A reference to this boxed version is then assigned to the variable of the reference type. Note that multiple variables of the reference type may refer to the same boxed instance of the value type. Note that boxing may also occur when passing parameters. For example, suppose we have a method:\nprivate object F(object x) { } If we call F with a parameter of 3, then 3 will need to be copied to a boxed int, and a reference to this boxed int will be assigned to x within F.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/enumerations/",
	"title": "Enumerations",
	"tags": [],
	"description": "",
	"content": "Enumerations An enumeration is a value type containing a set of named constants. An example of an enumeration is DialogResult (see \u0026quot;MessageBoxes\u0026quot; and “File Dialogs”). The DialogResult type contains the following members:\n DialogResult.Abort DialogResult.Cancel DialogResult.Ignore DialogResult.No DialogResult.None DialogResult.OK DialogResult.Retry DialogResult.Yes  Each of the above members has a different constant value. In many cases, we are not interested in the specific value of a given member. Instead, we are often only interested in whether two expressions of this type have the same value. For example, the following code fragment is given in the \u0026quot;MessageBoxes\u0026quot; section:\nDialogResult result = MessageBox.Show(\u0026#34;The file is not saved. Really quit?\u0026#34;, \u0026#34;Confirm Quit\u0026#34;, MessageBoxButtons.YesNo); if (result == DialogResult.Yes) { Application.Exit(); } In the if-statement above, we are only interested in whether the user closed the MessageBox with the \u0026ldquo;Yes\u0026rdquo; button; i.e., we want to know whether the Show method returned the same value as DialogResult.Yes. For this purpose, we don\u0026rsquo;t need to know anything about the value of DialogResult.Yes or any of the other DialogResult members.\nHowever, there are times when it is useful to know that the values in an enumeration are always integers. Using a cast, we can assign a member of an enumeration to an int variable or otherwise use it as we would an int; for example, after the code fragment above, we can write:\nint i = (int)result; As a more involved example, we can loop through the values of an enumeration:\nfor (DialogResult r = 0; (int)r \u0026lt; 8; r++) { MessageBox.Show(r.ToString()); } The above loop will display 8 MessageBoxes in sequence, each displaying the name of a member of the enumeration (i.e., \u0026ldquo;None\u0026rdquo;, \u0026ldquo;OK\u0026rdquo;, etc.).\nVariables of an enumeration type may be assigned any value of the enumeration\u0026rsquo;s underlying type (usually int, as we will discuss below). For example, if we had used the condition (int)r \u0026lt; 10 in the above for statement, the loop would continue two more iterations, showing 8 and 9 in the last two MessageBoxes.\nAn enumeration is defined using an enum statement, which is similar to a class statement except that in the simplest case, the body of an enum is simply a listing of the members of the enumeration. For example, the DialogResult enumeration is defined as follows:\npublic enum DialogResult { None, OK, Cancel, Abort, Retry, Ignore, Yes, No } This definition defines DialogResult.None as having the value 0, DialogResult.OK as having the value 1, etc.\nAs mentioned above, each enumeration has underlying type. By default, this type is int, but an enum statement may specify another underlying type, as follows:\npublic enum Beatles : byte { John, Paul, George, Ringo } The above construct defines the underlying type for the enumeration Beatles to be byte; thus, a variable of type Beatles may be assigned any byte value. The following integer types may be used as underlying types for enumerations:\n byte (0 through 255) sbyte (-128 through 127) short (-32,768 through 32,767) ushort (0 through 65,535) int (-2,147,483,648 through 2,147,483,647) uint (0 through 4,294,967,295) long (-9,223,372,036,854,775,808 through 9,223,372,036,854,775,807) ulong (0 through 18,446,744,073,709,551,615)  It is also possible to define members of an enumeration so that they are not simply the values 0, 1, etc. For example, we might alter the Beatles enumeration as follows:\npublic enum Beatles : byte { John = 1, Paul, George = 5, Ringo } This defines the following values for the members:\n Beatles.John: 1 Beatles.Paul: 2 Beatles.George: 5 Beatles.Ringo: 6  Thus, if a value is explicitly assigned to a member, that member takes on that value; otherwise, that member takes on the next value greater than the previous member listed, or 0 if that member is the first listed. Note that using this technique, it is possible to define two members with the same value, although this is usually undesirable. If assigning values in this way would lead to a value outside the range of the underlying type, a syntax error results (for example, if George were assigned 255 in the above definition).\nOne reason we might want to define explicit values for members of an enumeration is if we want to use the members as flags. For example, one of the MessageBox.Show methods takes as one of its parameters a MessageBoxOptions, which is an enumeration containing the following members:\n MessageBoxOptions.DefaultDesktopOnly MessageBoxOptions.RightAlign MessageBoxOptions.RtlReading MessageBoxOptions.ServiceNotification  The meaning of each of these members is unimportant for the purposes of this discussion. The point is that the values of these members are chosen in such a way that more than one of them can be combined into a single value. The way this is done is to define each member as a different power of 2. The binary representation of a power of 2 contains exactly one bit with a value of 1. Thus, these values can be combined using a logical OR operator, and the original values can be retrieved using a logical AND operator.\nFor example, suppose the MessageBoxOptions enumeration is defined as follows:\npublic enum MessageBoxOptions { DefaultDesktopOnly = 1, RightAlign = 2, RtlReading = 4, ServiceNotification = 8 }  Note\nThe definition in the .NET Framework uses different powers of 2, but the priciple is the same.\n Now suppose we want to create a MessageBox that will be displayed on the default desktop with right-aligned text. We can combine these options using the expression\nMessageBoxOptions.DefaultDesktopOnly | MessageBoxOptions.RightAlign This expression combines corresponding bits of the two operands using a logical OR. Recall that the logical OR of two bits is 1 if at least one of the two bits is 1. If both operands are 0, the result is 0. In this example, the operands have a 1 in different bit locations. When we combine them using logical OR, both of these bit positions will contain a 1:\n 0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0010 --------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0011  We can therefore specify both of these options to the Show method as folows:\nMessageBox.Show(\u0026#34;Hello\\nworld!\u0026#34;, \u0026#34;Hello\u0026#34;, MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, MessageBoxOptions.DefaultDesktopOnly | MessageBoxOptions.RightAlign); The \\n in the above example specifies the end of a line; hence, \u0026ldquo;Hello\u0026rdquo; and \u0026ldquo;world!\u0026rdquo; will be displayed on separate lines, aligned on the right:\nThe Show method determines which bits are 1 in the MessageBoxOptions parameter using a logical AND. Recall that a logical AND of two bits is 1 only if both bits are 1. In all othercases, the result is 0. Suppose, then, that options is a MessageBoxOptions variable with an unknown value. Because each named member of the MessageBoxOptions enumeration (e.g., MessageBoxOptions.RightAlign) has exactly one bit with a value of 1, an expression like\noptions \u0026amp; MessageBoxOptions.RightAlign can have only two possible values:\n If the bit position containing the 1 in MessageBoxOptions.RightAlign also contains a 1 in options, then the expression\u0026rsquo;s value is MessageBoxOptions.RightAlign. Otherwise, the expression\u0026rsquo;s value is 0.  Thus, the Show method can use code like:\nif ((options \u0026amp; MessageBoxOptions.RightAlign) == MessageBoxOptions.RightAlign) { // Code to right-align the text } else { // Code to left-align the text } Defining enumerations to be used as flags in this way can be made easier by writing the powers of 2 in hexadecimal, or base 16. Each hex digit contains one of 16 possible values: the ten digits 0-9 or the six letters a-f (in either lower or upper case). A hex digit is exactly four bits; hence, the hex values containing one occurrence of either 1, 2, 4, or 8, with all other digits 0, are exactly the powers of 2. To write a number in hex in a C# program, start with 0x, then give the hex digits. For example, we can define the following enumeration to represent the positions a baseball player is capable of playing:\npublic enum Positions { Pitcher = 0x1, Catcher = 0x2, FirstBase = 0x4, SecondBase = 0x8, ThirdBase = 0x10, Shortstop = 0x20, LeftField = 0x40, CenterField = 0x80, RightField = 0x100 } We can then encode that a player is capable of playing 1st base, left field, center field, or right field with the expression:\nPositions.FirstBase | Positions.LeftField | Positions.CenterField | Positions.RightField This expression would give a value having four bit positions containing 1:\n 0000 0000 0000 0000 0000 0001 1100 0100  For more information on enumerations, see the section, Enumeration Types in the C# Reference.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/",
	"title": "Visual Studio Enterprise 2019",
	"tags": [],
	"description": "",
	"content": "Visual Studio Enterprise 2019 This chapter will guide you through the use of Visual Studio 2019 and GitHub to obtain start code for your assignments, build, test, and debug graphical applications and class libraries, and submit assignment solutions. No attempt is meant to be exhaustive, as many of the features of Visual Studio are beyond the scope of CIS 300.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/homework/jjfhhsduuerqo1239jas/",
	"title": "CIS 300 Homework 2",
	"tags": [],
	"description": "",
	"content": "Homework 2: Connect Four  Homework Requirements (html) Homework Requirements (html-dark mode) Homework Requirements (PDF) Homework Requirements (Markdown)  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/homework/needsmorecoffee44123/",
	"title": "CIS 300 Homework 4",
	"tags": [],
	"description": "",
	"content": "Homework 4: vEB Trees  Homework Requirements (html) Homework Requirements (html-dark mode) Homework Requirements (PDF) Homework Requirements (Markdown)  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/homework/",
	"title": "CIS 300",
	"tags": [],
	"description": "",
	"content": "CIS 300 Homework  Homework 2 - Connect Four Homework 4 - vEB Trees  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/simple/",
	"title": "A Simple Hash Table Implementation",
	"tags": [],
	"description": "",
	"content": "A Simple Hash Table Implementation In this section, we will look at a simple hash table implementation using a fixed-length table. In subsequent sections, we will consider how to adjust the table size for better performance, as well as how to implement enumerators for iterating through the keys and/or values.\nAt the core of our implementation is the computation of the hash function. Recall that the implementation of the hash function computation is divided into two parts. The first part of the computation is implemented within the definition of the key type via its GetHashCode method. We will discuss this part of the computation in the section, “Hash Codes”. Here, we will focus on the second step, converting the int hash code returned by the key\u0026rsquo;s GetHashCode method to a table location.\nOne common technique, which is used in the .NET implementation of the Dictionary\u0026lt;TKey, TValue\u0026gt; class, is called the division method. This technique consists of the following:\n Reset the sign bit of the hash code to 0. Compute the remainder of dividing this value by the length of the table.  If p is a nonnegative int and q is a positive int, then p % q gives a nonnegative value less than q; hence, if q is the table length, p % q is a location within the table. Furthermore, this calculation often does a good job of distributing hash code values among the different table locations, but this depends on how the hash codes were computed and what the length of the table is.\nFor example, suppose we use a size $2^k$ for some positive integer $k$. In this case, the above computation can be simplified, as the values formed by $k$ bits are $0$ through $2^k - 1$, or all of the locations in the table. We can therefore simply use the low-order $k$ bits of the hash code as the table location. However, it turns out that using the division method when the table size is a power of $2$ can lead to poor key distribution for some common hash code schemes. To avoid these problems, a prime number should be used as the table length. When a prime number is used, the division method tends to result in a good distribution of the keys.\nThe reason we need to reset the sign bit of the hash code to 0 is to ensure that the first operand to the % operator is nonnegative, and hence that the result is nonnegative. Furthermore, simply taking the absolute value of the hash code won\u0026rsquo;t always work because $-2^{31}$ can be stored in an int, but $2^{31}$ is too large. Resetting the sign bit to 0 is a quick way to ensure we have a nonnegative value without losing any additional information.\nWe can do this using a bitwise AND operator, denoted by a single ampersand (\u0026amp;). This operator operates on the individual bits of an integer type such as int. The logical AND of two 1 bits is 1; all other combinations result in 0. Thus, if we want to set a bit to 0, we AND it with 0, and ANDing a bit with 1 will leave it unchanged. The sign bit is the high-order bit; hence, we want to AND the hash code with an int whose first bit is 0 and whose remaining bits are 1. The easiest way to write this value is using hexadecimal notation, as each hex digit corresponds to exactly four bits. We begin writing a hexadecimal value with 0x. The first four bits need to be one 0, followed by three 1s. These three 1 are in the $1$, $2$, and $4$ bit positions of the first hex digit; hence, the value of this hex digit should be 7. We then want seven more hex digits, each containing four 1s. An additional 1 in the $8$ position gives us a sum of $15$, which is denoted as either f or F in hex. We can therefore reset the sign bit of an int i as follows:\ni = i \u0026amp; 0x7fffffff; Now let\u0026rsquo;s consider how we would look up a key. First, we need to obtain the key\u0026rsquo;s hash code by calling its GetHashCode method. From the hash code, we use the division method to compute the table location where it belongs. We then search the linked list for that key.\nAdding a key and a value is done similarly. We first look for the key as described above. If we find it, we either replace its KeyValuePair with a new one containing the new value, or we throw an exception, depending on how we want this method to behave. If we don\u0026rsquo;t find it, we add a new cell containing the given key and value to the beginning of the list we searched.\nNote that looking up a key or adding a key and a value as described above can be implemented using either methods or indexers (the .NET Framework uses both). See the section, “Indexers” for details on how to implement an indexer.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/bst/binary-trees/",
	"title": "Binary Trees",
	"tags": [],
	"description": "",
	"content": "Binary Trees A binary tree is a tree in which each node has exactly two children, either of which may be empty. For example, the following is a binary tree:\nNote that some of the nodes above are drawn with only one child or no children at all. In these cases, one or both children are empty. Note that we always draw one child to the left and one child to the right. As a result, if one child is empty, we can always tell which child is empty and which child is not. We call the two children the left child and the right child.\nWe can implement a single node of a binary tree as a data structure and use it to store data. The implementation is simple, like the implementation of a linked list cell. Let\u0026rsquo;s call this type BinaryTreeNode\u0026lt;T\u0026gt;, where T will be the type of data we will store in it. We need three public properties:\n a Data property of type T; a LeftChild property of type BinaryTreeNode\u0026lt;T\u0026gt;; and a RightChild property of type BinaryTreeNode\u0026lt;T\u0026gt;.  We can define both get and set accessors using the default implementation for each of these properties. However, it is sometimes advantageous to make this type immutable. In such a case, we would not define any set accessors, but we would need to be sure to define a constructor that takes three parameters to initialize these three properties. While immutable nodes tend to degrade the performance slightly, they also tend to be easier to work with. For example, with immutable nodes it is impossible to build a structure with a cycle in it.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/formatting/",
	"title": "General Formatting",
	"tags": [],
	"description": "",
	"content": "General Formatting All programming will be done using either Microsoft Visual Studio® Community 2022 or Microsoft Visual Studio Enterprise 2019. This integrated development environment (IDE) does a certain amount of formatting automatically. All code formatting should be consistent with what the IDE does automatically, including how it formats code stubs that it inserts. Specifically, all braces should occur on lines by themselves, vertically aligned so that matching braces occupy the same column. (An exception to this rule can be made when the braces enclose a single statement or a part of a statement, and they occur on the same line; however, if it is possible to omit the braces, as in an if statement, this is preferable to placing them on the same line.) Furthermore, blocks of code enclosed by braces should be indented one tab stop inside the braces.\nTip\nAn easy way to format a file consistently (after removing any syntax errors) is to select from the \u0026ldquo;Edit\u0026rdquo; menu, \u0026ldquo;Advanced -\u0026gt; Format Document\u0026rdquo;.\n Warning\nDon\u0026rsquo;t change the formatting defaults in the IDE.\n "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/heaps/",
	"title": "Heaps",
	"tags": [],
	"description": "",
	"content": "Heaps A common structure for implementing a priority queue is known as a heap. A heap is a tree whose nodes contain elements with priorities that can be ordered. Furthermore, if the heap is nonempty, its root contains the maximum priority of any node in the heap, and each of its children is also a heap. Note that this implies that, in any subtree, the maximum priority is at the root. We define a min-heap similarly, except that the minimum priority is at the root. Below is an example of a min-heap with integer priorities (the data elements are not shown \u0026mdash; only their priorities):\nNote that this structure is different from a binary search tree, as there are elements in the left child that have larger priorities than the root. Although some ordering is imposed on the nodes (i.e., priorities do not decrease as we go down a path from the root), the ordering is less rigid than for a binary search tree. As a result, there is less overhead involved in maintaining this ordering; hence, a min-heap tends to give better performance than an AVL tree, which could also be used to implement a min-priority queue. Although the definition of a heap does not require it, the implementations we will consider will be binary trees, as opposed to trees with an arbitrary number of children.\nNote\nThe heap data structure is unrelated to the pool of memory from which instances of reference types are constructed \u0026mdash; this also, unfortunately, is called a heap.\n One advantage to using a min-heap to implement a min-priority queue is fairly obvious \u0026mdash; an element with minimum priority is always at the root if the min-heap is nonempty. This makes it easy to find the minimum priority and an element with this priority. Let\u0026rsquo;s consider how we might remove an element with minimum priority. Assuming the min-heap is nonempty, we need to remove the element at the root. Doing so leaves us with two min-heaps (either of which might be empty). To complete the removal, we need a way to merge two min-heaps into one. Note that if we can do this, we also have a way of adding a new element: we form a 1-node min-heap from the new element and its priority, then merge this min-heap with the original one.\nLet us therefore consider the problem of merging two min-heaps into one. If either min-heap is empty, we can simply use the other one. Suppose that both are nonempty. Then the minimum priority of each is located at its root. The minimum priority overall must therefore be the smaller of these two priorities. Let s denote the heap whose root has the smaller priority and b denote the heap whose root has the larger priority. Then the root of s should be the root of the resulting min-heap.\nNow that we have determined the root of the result, let\u0026rsquo;s consider what we have left. s has two children, both of which are min-heaps, and b is also a min-heap. We therefore have three min-heaps, but only two places to put them - the new left and right children of s. To reduce the number of min-heaps to two, we can merge two of them into one. This is simply a recursive call.\nWe have therefore outlined a general strategy for merging two min-heaps. There two important details that we have omitted, though:\n Which two min-heaps do we merge in the recursive call? Which of the two resulting min-heaps do we make the new left child of the new root?  There are various ways these questions can be answered. Some ways lead to efficient implementations, whereas others do not. For example, if we always merge the right child of s with b and make the result the new right child of the new root, it turns out that all of our min-heaps will have empty left children. As a result, in the worst case, the time needed to merge two min-heaps is proportional to the total number of elements in the two min-heaps. This is poor performance. In the next section we will consider a specific implementation that results in a worst-case running time proportional to the logarithm of the total number of nodes.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/",
	"title": "Input/Output",
	"tags": [],
	"description": "",
	"content": "Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event. A method in the program then responds to that event by reading information that the user has typed into various controls on the GUI, and processes that information. It may then provide output to the user by writing results to various controls on the GUI.\nSuch a simple presentation of input/output (or I/O) is far too limiting, however. For example, other mechanisms such as dialogs - secondary windows designed for exchanging specific information - may be used to avoid cluttering the main window. In other cases, the amount of data that needs to be exchanged is too large to be transferred through a GUI. In such cases, the program may need to read and/or write a file. This chapter addresses these more advanced I/O mechanisms.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/installing-vs/",
	"title": "Installing Visual Studio",
	"tags": [],
	"description": "",
	"content": "Installing Visual Studio Visual Studio Enterprise 2019 is available on the machines we use for CIS 300 labs. Students can also connect to these machines remotely \u0026mdash; see the CS Department Support Wiki for details. However, if you are enrolled in CIS 300, you have free access to this software to install on your own PC for your own personal use. This section provides instructions for obtaining this software from the Azure Portal and installing it on your PC.\nVisual Studio requires a Microsoft operating system such as Windows 10. If you don\u0026rsquo;t have a Microsoft operating system, you can obtain one for free from the Azure Portal using the same process as for obtain Visual Studio, as described below. You will need to install the operating system either on a separate bootable partition or using an emulator such as VMware Fusion. VMware Fusion is also available for free through the VMware Academic Program \u0026mdash; see the CS Department Support Wiki for details.\nTo download Visual Studio Enterprise 2019, go to Microsoft Azure Dev Tools for Teaching, and click the \u0026ldquo;Sign In\u0026rdquo; button. Then sign in to your Microsoft account using your KSU email address.\nNote\nIf you don\u0026rsquo;t have a Microsoft account, you can create one using the \u0026ldquo;Create one!\u0026rdquo; link. Be sure to use your KSU email address.\n Note\nIf you get a message resembing the following, select the option labeled \u0026ldquo;Work or school account created by your IT department\u0026rdquo;:\n Once you have logged in, click on the \u0026ldquo;Software\u0026rdquo; link on the left. Then type \u0026ldquo;Visual\u0026rdquo; into the search box below the \u0026ldquo;Education | Software\u0026rdquo; heading. \u0026ldquo;Visual Studio Enterprise 2019\u0026rdquo; should then appear in the list below the search box \u0026mdash; click this link. This should bring up a window containing three buttons: \u0026ldquo;View Key\u0026rdquo;, \u0026ldquo;Download\u0026rdquo;, and \u0026ldquo;Cancel\u0026rdquo;. Before downloading the software, click \u0026ldquo;View Key\u0026rdquo; button, and copy the key to a file so that you can retrieve it later.\nTip\nCopying the key is not strictly necessary at this point, as you can always come back to this page. However, you will need the key to be able to use the software for more than 30 days, and the installation process will require your PC to restart. It therefore makes sense to copy the key while you are here.\n Once you have copied the key, click the \u0026ldquo;Download\u0026rdquo; button to begin downloading the installer. When the download has completed, run the file you downloaded. This will start the installation process.\nAs the installation is beginning, you will be shown a window asking for the components to be installed. Click the \u0026ldquo;Workloads\u0026rdquo; tab in this window, and select \u0026ldquo;.NET desktop development\u0026rdquo; (under \u0026ldquo;Desktop \u0026amp; Mobile\u0026rdquo;). You can select other workloads or components if you wish, but this workload will install all you need for CIS 300.\nThe first time you run Visual Studio, you will be asked to sign in to your Microsoft account. You can either do this or skip it by clicking, \u0026ldquo;Not now, maybe later.\u0026rdquo; You will then be shown a window resembling the following:\nNext to \u0026ldquo;Development Settings:\u0026rdquo;, select \u0026ldquo;Visual C#\u0026rdquo;. You can select whichever color scheme you prefer.\nOnce Visual Studio has started, you should enter the product key (if you didn\u0026rsquo;t save it when you downloaded the software, go back to Microsoft Azure Dev Tools for Teaching and find it. Then in Visual Studio, go to the \u0026ldquo;Help\u0026rdquo; menu and select \u0026ldquo;Register Product\u0026rdquo;. Then enter your product key.\nAt this point, Visual Studio should be fully installed and ready to use.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/installing-vs/",
	"title": "Installing Visual Studio",
	"tags": [],
	"description": "",
	"content": "Installing Visual Studio Visual Studio Community 2022 is available on the machines we use for CIS 300 labs, as well as on machines in other lab classrooms. Students can also access Visual Studio via a remote desktop server \u0026mdash; see the CS Department Support Wiki for details. This edition of Visual Studio is also freely available for installation on your own PC for your personal and classroom use. This section provides instructions for obtaining this software from Microsoft and installing it on your PC.\nWhile Microsoft also produces a version of Visual Studio for Mac, we recommend the Windows version. If you don\u0026rsquo;t have a Microsoft operating system, you can obtain one for free from the Azure Portal \u0026mdash; see the CS Department Support Wiki for details. You will need to install the operating system either on a separate bootable partition or using an emulator such as VMware Fusion. VMware Fusion is also available for free through the VMware Academic Program \u0026mdash; see the CS Department Support Wiki for details.\nTo download Visual Studio Community 2022, go to Microsoft’s Visual Studio Site, and from the \u0026ldquo;Download Visual Studio\u0026rdquo; dropdown, select \u0026ldquo;Community 2022\u0026rdquo;. This should normally begin downloading an installation file; if not, click the \u0026ldquo;click here to retry\u0026rdquo; link near the top of the page. When the download has completed, run the file you downloaded. This will start the installation process.\nAs the installation is beginning, you will be shown a window asking for the components to be installed. Click the \u0026ldquo;Workloads\u0026rdquo; tab in this window, and select \u0026ldquo;.NET desktop development\u0026rdquo; (under \u0026ldquo;Desktop \u0026amp; Mobile\u0026rdquo;). You can select other workloads or components if you wish, but this workload will install all you need for CIS 300.\nThe first time you run Visual Studio, you will be asked to sign in to your Microsoft account. You can either do this or skip it by clicking, \u0026ldquo;Not now, maybe later.\u0026rdquo; You will then be shown a window resembling the following:\nNext to \u0026ldquo;Development Settings:\u0026rdquo;, select \u0026ldquo;Visual C#\u0026rdquo;. You can select whichever color scheme you prefer. At this point, Visual Studio should be fully installed and ready to use.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/graphs/intro/",
	"title": "Introduction to Graphs",
	"tags": [],
	"description": "",
	"content": "Introduction to Graphs There are two kinds of graphs: undirected and directed. An undirected graph consists of:\n a finite set of nodes; and a finite set of edges, which are 2-element subsets of the nodes.  The fact that edges are 2-element sets means that the nodes that comprise an edge must be distinct. Furthermore, within a set, there is no notion of a \u0026ldquo;first\u0026rdquo; element or a \u0026ldquo;second\u0026rdquo; element \u0026mdash; there are just two elements. Thus, an edge expresses some symmetric relationship between two nodes; i.e., if $\\{u, v\\}$ is an edge then node $u$ is adjacent to node $v$, and node $v$ is adjacent to node $u$. We also might associate some data, such as a label or a length, with an edge.\nWe can think of an edge as \u0026ldquo;connecting\u0026rdquo; the two nodes that comprise it. We can then draw an undirected graph using circles for the nodes and lines connecting two distinct nodes for the edges. Following is an example of an undirected graph with numeric values associated with the edges:\nA directed graph is similar to an undirected graph, but the edges are ordered pairs of distinct nodes rather than 2-element sets. Within an ordered pair, there is a first element and a second element. We call the first node of an edge its source and the second node its destination. Thus, an edge in a directed graph expresses an asymmetric relationship between two nodes; i.e., if $(u, v)$ is an edge, then $v$ is adjacent to $u$, but $u$ is not adjacent to $v$ unless $(v, u)$ is also an edge in the graph. As with undirected graphs, we might associate data with an edge in a directed graph.\nWe can draw directed graphs like we draw undirected graphs, except that we use an arrow to distinguish between the source and the destination of an edge. Specifically, the arrows point from the source to the destination. If we have edges $(u, v)$ and $(v, u)$, and if these edges have the same data associated with them, we might simplify the drawing by using a single line with arrows in both directions. Following is an example of a directed graph with numeric values associated with the edges:\nThis DLL contains the definition of a namespace Ksu.Cis300.Graphs containing a class DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; and a structure Edge\u0026lt;TNode, TEdgeData\u0026gt;. The class DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; implements a directed graph whose nodes are of type TNode, which must be a type suitable for hashing. The edges each store a data item of type TEdgeData, which may be any type. These edges can be represented using instances of the Edge\u0026lt;TNode, TEdgeData\u0026gt; structure. We also can use the DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; class to represent undirected graphs \u0026mdash; we simply make sure that whenever there is an edge $(u, v)$, there is also an edge $(v, u)$ containing the same data.\nThe Edge\u0026lt;TNode, TEdgeData\u0026gt; structure contains the following public members:\n Edge(TNode source, TNode dest, TEdgeData data): This constructor constructs an edge leading from source to dest and having data as its data item. TNode Source: This property gets the source node for the edge. TNode Destination: This property gets the destination node for the edge. TEdgeData Data: This property gets the data associated with the edge.  Note that because no public members change the structure, it is immutable.\nThe DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; class contains the following public members:\n DirectedGraph(): This constructor constructs a directed graph with no nodes or edges. void AddNode(TNode node): This method adds the given node to the graph. If this node already is in the graph, it throws an ArgumentException. If node is null, it throws an ArgumentNullException. void AddEdge(TNode source, TNode dest, TEdgeData value): This method adds a new edge from source to dest, with value as its associated value. If either source or dest is not already in the graph, it is automatically added. If source and dest are the same node, or if there is already an edge from source to dest, it throws an ArgumentException. If either source or dest is null, it throws an ArgumentNullException. bool TryGetEdge(TNode source, TNode dest, out TEdgeData value): This method tries to get the value associated with the edge from source to dest. If this edge exists, it sets value to the value associated with this edge and returns true; otherwise, it sets value to the default value for the TEdge type and returns false. int NodeCount: This property gets the number of nodes in the graph. int EdgeCount: This property gets the number of edges in the graph. bool ContainsNode(TNode node): This method returns whether the graph contains the given node. If node is null, it throws an ArgumentNullException. bool ContainsEdge(TNode source, TNode dest): This method returns whether the graph contains an edge from source to dest. IEnumerable\u0026lt;TNode\u0026gt; Nodes: This property gets an enumerable collection of the nodes in the graph. IEnumerable\u0026lt;Edge\u0026lt;TNode, TEdgeData\u0026gt;\u0026gt; OutgoingEdges(TNode source): This method gets an enumerable collection of the outgoing edges from the given node. If source is not a node in the graph, it throws an ArgumentException. If source is null, it throws an ArgumentNullException. Otherwise, each edge in the collection returned is represented by an Edge\u0026lt;TNode, TEdgeData\u0026gt;  This implementation is somewhat limited in its utility, as nodes or edges cannot be removed, and values associated with edges cannot be changed. However, it will be sufficient for our purposes. We will examine its implementation details in a later section. For now, we will examine how it can be used.\nBuilding a graph is straightforward using the constructor and the AddNode and/or AddEdge methods. Note that because the AddEdge method will automatically add given nodes that are not already in the graph, the AddNode method is only needed when we need to add a node that may have no incoming or outgoing edges.\nFor many graph algorithms, we need to process all of the edges in some way. Often the order in which we process them is important, but not in all cases. If we simply need to process all of the edges in some order we can use foreach loops with the last two properties listed above to accomplish this:\n For each node in the graph:  For each outgoing edge from that node:  Process this edge.      "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/linked-lists/intro/",
	"title": "Introduction to Linked Lists",
	"tags": [],
	"description": "",
	"content": "Introduction to Linked Lists To build a linked list, we first need to define a simple class, which we will call LinkedListCell\u0026lt;T\u0026gt;. Instances of this class will be the individual building blocks that we will chain together to form linked lists. T will be the type of the data item we will store in each cell - i.e., the type of the data items that we will store in the linked list.\nA LinkedListCell\u0026lt;T\u0026gt; will have as its only members two public properties, which can each be implemented using the default implementation:\n The Data property gets or sets the data item (of type T) stored in the cell. The Next property gets or sets the next LinkedListCell\u0026lt;T\u0026gt; in the linked list.  Because this is a class, it is a reference type; hence, the Next property will store a reference to another LinkedListCell\u0026lt;T\u0026gt;.\nAlthough the LinkedListCell\u0026lt;T\u0026gt; class is simple, we can use its Next property to chain together long sequences of its instances:\nIn the above figure, p is a LinkedListCell\u0026lt;string\u0026gt; variable. Each box in the figure represents an instance of LinkedListCell\u0026lt;string\u0026gt;. The boxes are each divided into two regions to indicate the two public properties for each cell. Because string is a reference type, we have shown each Data property as a reference to a string. The rightmost arrow that is bent downward is used to represent null. The entire sequence of **LinkedListCell\u0026lt;string\u0026gt;**s is called a linked list. Given this linked list:\n p.Data is \u0026ldquo;Now\u0026rdquo;; p.Next.Data is \u0026ldquo;is\u0026rdquo;; p.Next.Next.Data is \u0026ldquo;the\u0026rdquo;; p.Next.Next.Next.Data is \u0026ldquo;time\u0026rdquo;; and p.Next.Next.Next.Next is null (if we try to get its Data property, we will get a NullReferenceException).  Tip\nWhen writing code for using and manipulating linked lists, it is helpful to draw pictures of the lists, as we do throughout this chapter.\n Suppose we want to insert the string \u0026ldquo;Notice:\u0026rdquo; at the beginning of this linked list. Because we have not defined a constructor for the LinkedListCell\u0026lt;T\u0026gt; class, it has a default constructor that we can use to construct a new instance:\nLinkedListCell\u0026lt;string\u0026gt; cell = new LinkedListCell\u0026lt;string\u0026gt;(); We can then set its Data property to \u0026ldquo;Notice:\u0026quot;:\ncell.Data = \u0026#34;Notice:\u0026#34;; This gives us the following:\nWe have the cell we need, but it\u0026rsquo;s not linked into the linked list. We can accomplish this by changing the cell\u0026rsquo;s Next property:\ncell.Next = p; This yields the following:\nThis is what we want, unless we want p to refer to the beginning of the linked list. We can take care of this by copying the value of cell to p:\np = cell; This yields the following (we are not showing cell because we are no longer interested in it, but it still refers to the same cell):\nWe can also undo the above statement by copying into p the reference in the Next property of the cell to which p refers:\np = p.Next; This yields the following:\nThis has the effect of removing \u0026ldquo;Notice:\u0026rdquo; from the linked list to which p refers. Though we haven\u0026rsquo;t shown it, cell still refers to the cell containing \u0026ldquo;Notice:\u0026quot;; hence, we still have access to the linked list beginning with this cell. However, if the program had no references remaining to this cell, we would have no way to retrieve it, and it would be available for garbage collection. This illustrates how we must take care not to lose a part of a linked list (unless we are finished with it) when we are manipulating it.\nWith a little more work, cells can be inserted into or removed from arbitrary locations in a linked list. We will discuss how to do this in subsequent sections. For now let us simply observe that linked lists do not always continue until they reach a null - they can contain cycles, as follows:\nThis is occasionally what we want, but more often, this is a programming error that leads to an infinite loop.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stacks/",
	"title": "Introduction to Stacks",
	"tags": [],
	"description": "",
	"content": "Introduction to Stacks A stack provides last-in-first-out (LIFO) access to data items. We usually think of a stack as arranging data items vertically, like a stack of trays in a cafeteria. Access is normally provided only at the top of the stack; hence, if we want to add an item, we push it onto the top, and if we want to remove an item, we pop it from the top. Because we only access the top of the stack, the item that we pop is always the remaining item that we had pushed the most recently.\nThe .NET Framework provides two kinds of stacks. One is the Stack class found in the System.Collections namespace. This class provides a stack of objects. Because every type in C# is a subtype of object, we can push any data items we want onto a Stack. The most commonly-used public members of this class are:\n A constructor that takes no parameters and constructs an empty stack. A Count property, which gets the number of elements on the Stack as an int. A Push method, which takes a single parameter of type object, and pushes it onto the top of the Stack. A Peek method, which takes no parameters and returns the element at the top of the Stack (as an object) without changing the Stack\u0026rsquo;s contents. If the Stack is empty, this method throws an InvalidOperationException. A Pop method, which takes no parameters, and removes and returns the element at the top of the Stack (as an object). If the Stack is empty, this method throws an InvalidOperationException.  As we mentioned above, because the Push method takes an object as its parameter, we can push any data elements we want onto a Stack. What this means, however, is that the compiler can\u0026rsquo;t determine the type of these elements when we retrieve them; i.e., both the Peek and Pop methods return objects. Thus, for example, the following code will not compile:\nStack s = new Stack(); s.Push(7); int n = s.Pop() + 1; The problem is that the Pop method returns an object, and we can\u0026rsquo;t add an int to an object. Although it\u0026rsquo;s pretty easy to see from this code that Pop will return 7, in many cases it\u0026rsquo;s impossible to know at compile time the exact type of the element returned (for example, the Stack may be a parameter to a method, and that method may be called by code that has not yet been written). Consequently, the compiler simply uses the return type of Pop - it doesn\u0026rsquo;t even try to figure out the type any more precisely.\n If you want to use the value returned by Pop or Peek as something other than an object, you need to tell the compiler what its type actually is. You do this with a cast:\nint n = (int)s.Pop() + 1; This tells the compiler to assume that the value returned by Pop is an int. The type is still checked, but now it is checked at run time, rather than at compile time. If the runtime environment detects that the value is not, in fact, an int it will throw an InvalidCastException.\n Often when we need a stack, the data items that we wish to store are all of the same type. In such a case, it is rather awkward to include a cast whenever we retrieve an item from the stack. In order to avoid this casting, the .NET Framework provides a generic stack, Stack\u0026lt;T\u0026gt;, found in the System.Collections.Generic namespace. The T within angle brackets is a type parameter - we may replace it with any type we want. This type tells what type of elements may be placed in this stack. For example, if we want a stack that will only contain ints, we can write:\nStack\u0026lt;int\u0026gt; s = new Stack\u0026lt;int\u0026gt;(); This class has members similar to those listed above for the non-generic Stack class, except that the Push method takes a parameter of type T (i.e., whatever type we placed within the angle brackets in the type declaration and constructor call), and the Peek and Pop methods each return a value of type T. As a result, the following is now legal code:\nStack\u0026lt;int\u0026gt; s = new Stack\u0026lt;int\u0026gt;(); s.Push(7); int n = s.Pop() + 1; We will show how you can define your own generic types in \u0026ldquo;Implementing a Stack\u0026rdquo;. First, however, we want to work through two example applications of stacks. We will do that in the next two sections.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/intro/",
	"title": "Introduction to Trees",
	"tags": [],
	"description": "",
	"content": "Introduction to Trees A tree is a mathematical structure having a hierarchical nature. A tree may be empty, or it may consist of:\n a root, and zero or more children, each of which is also a tree.  Consider, for example, a folder (or directory) in a Windows file system. This folder and all its sub-folders form a tree \u0026mdash; the root of the tree is the folder itself, and its children are the folders directly contained within it. Because a folder (with its sub-folders) forms a tree, each of the sub-folders directly contained within the folder are also trees. In this example, there are no empty trees \u0026mdash; an empty folder is a nonempty tree containing a root but no children.\nNote\nWe are only considering actual folders, not shortcuts, symbolic links, etc.\n We have at least a couple of ways of presenting a tree graphically. One way is as done within Windows Explorer:\nHere, children are shown in a vertically-aligned list, indented under the root. An alternative depiction is as follows:\nHere, children are shown by drawing lines to them downward from the root.\nOther examples of trees include various kinds of search spaces. For example, for a chess-playing program, the search for a move can be performed on a game tree whose root is a board position and whose children are the game trees formed from each board position reachable from the root position by a single move. Also, in the sections that follow, we will consider various data structures that form trees.\nThe .NET Framework provides access to the folders in a file system tree via the DirectoryInfo class, found in the System.IO namespace. This class has a constructor that takes as its only parameter a string giving the path to a folder (i.e., a directory) and constructs a DirectoryInfo describing that folder. We can obtain such a string from the user using a FolderBrowserDialog. This class is similar to a file dialog and can be added to a form in the Design window in the same way. If uxFolderBrowser is a FolderBrowserDialog, we can use it to obtain a DirectoryInfo for a user-selected folder as follows:\nif (uxFolderBrowser.ShowDialog() == DialogResult.OK) { DirectoryInfo folder = new DirectoryInfo(uxFolderBrowser.SelectedPath); // Process the folder } Various properties of a DirectoryInfo give information about the folder; for example:\n Name gets the name of the folder as a string. FullName gets the full path of the folder as a string. Parent gets the parent folder as a DirectoryInfo.  In addition, its GetDirectories method takes no parameters and returns a DirectoryInfo[ ] whose elements describe the contained folders (i.e., the elements of the array are the children of the folder). For example, if d refers to a DirectoryInfo for the folder Ksu.Cis300.HelloWorld from the figures above, then d.GetDirectories() would return a 3-element array whose elements describe the folders bin, obj, and Properties. The following method illustrates how we can write the names of the folders contained within a given folder to a StreamWriter:\n/// \u0026lt;summary\u0026gt; /// Writes the names of the directories contained in the given directory /// (excluding their sub-directories) to the given StreamWriter. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;dir\u0026#34;\u0026gt;The directory whose contained directories are to /// be written.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;output\u0026#34;\u0026gt;The output stream to write to.\u0026lt;/param\u0026gt; private void WriteSubDirectories(DirectoryInfo dir, StreamWriter output) { foreach (DirectoryInfo d in dir.GetDirectories()) { output.WriteLine(d.Name); } } For a more interesting problem, suppose we want to write to a StreamWriter the structure of an entire folder, as follows:\n Ksu.Cis300.HelloWorld bin Debug Release obj Debug TempPE Properties  We can break this task into the following steps:\n  Write the name of the folder:\nKsu.Cis300.HelloWorld   Write the structure of each child folder, indented one level (i.e., two spaces):\n  First child:\n bin Debug Release    Second child:\n obj Debug TempPE    Third child:\n Properties       Note that writing the structure of a child folder is an instance of the original problem that we want to solve - i.e., writing the structure of a folder. The only difference is that the folders are different and the amount of indentation is different. We can solve such a problem using a technique called recursion. Recursion involves a method calling itself. Because of the recursive nature of a tree (i.e., each child of a tree is also a tree), recursion is commonly used in processing trees.\nIn order to use recursion, we first must define precisely what we want our method to accomplish, wherever it might be called. For this problem, we want to write to a given StreamWriter a list of all the folders contained within a given folder, including the given folder itself and all sub-folders in the entire tree, where each folder is indented two spaces beyond its parent\u0026rsquo;s indentation. Furthermore, the entire tree below a given folder (i.e., excluding the folder itself) should be listed below that folder, but before any folders that are outside that folder. In order to write such a method, we need three parameters:\n a DirectoryInfo giving the root folder; a StreamWriter where the output is to be written; and an int giving the level of indentation for the root folder, where each level of indentation is two spaces.  Because the root folder must be written first, we begin there. We first must write two blanks for every level of indentation, then write the name of the root folder:\n/// \u0026lt;summary\u0026gt; /// Writes the directory structure for the given root directory to the /// given StreamWriter, indenting all entries to the given indentation /// level (incomplete). /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;The root directory.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;output\u0026#34;\u0026gt;The output stream to which to write\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;level\u0026#34;\u0026gt;The current indentation level.\u0026lt;/param\u0026gt; private void WriteTree(DirectoryInfo root, StreamWriter output, int level) { for (int i = 0; i \u0026lt; level; i++) { output.Write(\u0026#34; \u0026#34;); } output.WriteLine(root.Name); // We now need to write the sub-directories . . .  } We can get the children using root.GetDirectories(). Each of the elements of the array this method returns will be a DirectoryInfo whose structure we want to write. Looking back at how we described what we want the WriteTree method to accomplish, we see that it is exactly what we want to do for each child. We can therefore make a recursive call for each child, specifying that the indentation level should be one deeper than the level for root:\n/// \u0026lt;summary\u0026gt; /// Writes the directory structure for the given root directory to the /// given StreamWriter, indenting all entries to the given indentation /// level (incomplete). /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;The root directory.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;output\u0026#34;\u0026gt;The output stream to which to write\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;level\u0026#34;\u0026gt;The current indentation level.\u0026lt;/param\u0026gt; private void WriteTree(DirectoryInfo root, StreamWriter output, int level) { for (int i = 0; i \u0026lt; level; i++) { output.Write(\u0026#34; \u0026#34;); } output.WriteLine(root.Name); foreach (DirectoryInfo d in root.GetDirectories()) { WriteTree(d, output, level + 1); } } This method accomplishes the desired task, provided the directory tree does not contain symbolic links or anything similar that might be represented using a DirectoryInfo, but is not an actual folder. While it is possible to detect these and avoid following them, we will not consider that here.\nThere is something that may seem mysterious about what we have done. In order to convince ourselves that this method is written correctly, we need to know that the recursive calls work correctly; however, the recursive calls are to the same method. Our reasoning therefore seems circular. However, we are actually using a mathematical principle from the discipline of formally proving software correctness: in order to prove that a recursive method meets its specification we may assume that any recursive calls meet that same specification, provided that these recursive calls are all on smaller problem instances.\nThe restriction that recursive calls are on smaller problem instances is what avoids circular reasoning regarding recursion. We associate with each problem instance a nonnegative integer describing its size. For a problem involving a tree, this size is typically the number of nodes in the tree, where a node is a root of some subtree. Because every node in a child is also in the tree containing the child, but the root of the containing tree is not in the child, a child is always smaller, provided the tree is finite. (For directory trees, if the underlying file system is a Windows system, the tree will be finite; however if it is a non-Windows system, the trees may appear to Windows as being infinite - the above method actually will not work in such cases.)\nThe validity of this strategy is based on the fact that for any method, the following three statements cannot be simultaneously true:\n All of the method\u0026rsquo;s recursive calls (if there are any) are on inputs of smaller size, where the size is defined to be a nonnegative integer. When the method is given any input, if all of the method\u0026rsquo;s recursive calls produce correct results, then the method itself produces a correct result. There is at least one input for which the method does not produce a correct result.  Thus, if we can ensure that Statements 1 and 2 are true, then Statement 3 must be false; i.e., the method will be correct. To ensure Statement 2, we only need to concern ourselves with cases in which all recursive calls produce correct results; hence, we simply assume that each recursive call produces correct results.\nTo see why the three statements above cannot be simultaneously true, let\u0026rsquo;s first suppose Statement 3 is true. Let S be the set of all inputs for which the method does not produce a correct result. Then because Statement 3 is true, this set is nonempty. Because each input in S has a nonnegative integer size, there is an input I in S with smallest size. Now suppose Statement 1 is true. Then when the method is run on input I, each of the recursive calls is given an input smaller than I; hence, because I is a smallest input in S, none of these inputs is in S. Therefore, each of the recursive calls produces a correct result. We therefore have an input, I on which all of the method\u0026rsquo;s recursive calls produce correct results, but the method itself does not produce a correct result. Statement 2 is therefore false.\nOnce we understand this strategy, recursion is as easy to use as calling a method written by someone else. In fact, we should treat recursive calls in exactly the same way \u0026mdash; we need to understand what the recursive call is supposed to accomplish, but not necessarily how it accomplishes it. Furthermore, because processing trees typically involves solving the same problem for multiple nodes in the tree, recursion is the natural technique to use.\nA recursive method for processing a tree will break down into cases, each fitting into one of the following categories:\n A base case is a case that is simple enough that a recursive call is not needed. Empty trees are always base cases, and sometimes other trees are as well. A recursive case is a case that requires one or more recursive calls to handle it.  A recursive method will always contain cases of both these types. If there were no base cases, the recursion would never terminate. If there were no recursive cases, the method wouldn\u0026rsquo;t be recursive. Most recursive methods are, in fact, structured as an if-statement, with some cases being base cases and some cases being recursive cases. However, for some recursive methods, such as WriteTree above, the base cases aren\u0026rsquo;t as obvious. Note that in that method, the recursive call appears in a loop; hence, if the loop doesn\u0026rsquo;t iterate (because the array returned is empty), no recursive calls are made. Furthermore, if the directory tree is finite, there must be some sub-directories that have no children. When the GetDirectories method is called for such a directory, it returns an empty array. These directories are therefore the base cases.\nThe WriteTree method above is actually an example of processing an entire tree using a preorder traversal. In a preorder traversal, the root of the tree is processed first, then each of the children is processed using a recursive call. This results in each node\u0026rsquo;s being processed prior to any node contained in any of its children. For the WriteTree method, this means that the name of any folder is written before any folders contained anywhere within it.\nWhen debugging a recursive method, we should continue to think about it in the same way \u0026mdash; that is, assume that all recursive calls work correctly. In order to isolate an error, we need to find an instance that causes an error, but whose recursive calls all work correctly. It will almost always be possible to find such a case that is small \u0026mdash; in fact, small cases tend to be the most likely ones to fit this description. When debugging, it therefore makes sense to start with the smallest cases, and slowly increase their size until one is found that causes an error. When using the debugger to step through code, first delete all breakpoints from this method, then use Step Over to step over the recursive calls. If a recursive call doesn\u0026rsquo;t work correctly, you have found a smaller instance that causes an error \u0026mdash; work on that instance instead. Otherwise, you can focus on the top-level code for the instance you are debugging. This is much easier to think about that trying to work through different levels of recursion.\nThere are times when it is useful to know exactly what happens when a recursive call (or any method call, for that matter) is made. Prior to transferring control to the top of the method being called, all local variables and the address of the current code location are pushed onto the call stack. This call stack is just like any other stack, except that it has a smaller amount of space available to it. You can, in fact, examine the call stack when debugging \u0026mdash; from the \u0026ldquo;Debug\u0026rdquo; menu, select \u0026ldquo;Windows -\u0026gt; Call Stack\u0026rdquo;. This will open a window showing the contents of the call stack. The line on top shows the line of code currently ready for execution. Below it is the line that called the current method, and below that line is the line that called that method, etc. By double-clicking on an entry in the call stack, you can use the other debugging tools to examine the values of the local variables for the method containing that line of code. If this method is recursive, the values displayed for the local variables are their values at that level of recursion.\nNote\nThis only applies to the values stored in local variables - in particular, if a local variable is a reference type, the value of the object to which it refers will not revert to its earlier state. For example, if a local variable is an array, the debugger will show the value of this variable to refer to the array that it referred to at that point, but the values shown in that array will be its current values.\n Once consequence of method calls using a call stack with limited space available is that moderately deep recursion can fill up the call stack. If this happens, a StackOverflowException will be thrown. Thus, infinite recursion will always throw this exception, as will recursion that is nested too deeply. For this reason, it is usually a bad idea to use recursion on a linked list - if the list is very long, the recursion will be nested too deeply. We must also take care in using recursion with trees, as long paths in a tree can lead to a StackOverflowException. Due to the branching nature of trees, however, we can have very large trees with no long paths. In fact, there are many cases in which we can be sure that a tree doesn\u0026rsquo;t contain any long paths. In such cases, recursion is often a useful technique.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/tries/intro/",
	"title": "Introduction to Tries",
	"tags": [],
	"description": "",
	"content": "Introduction to Tries A trie is a nonempty tree storing a set of words in the following way:\n Each child of a node is labeled with a character. Each node contains a boolean indicating whether the labels in the path from the root to that node form a word in the set.  The word, \u0026ldquo;trie\u0026rdquo;, is taken from the middle of the word, \u0026ldquo;retrieval\u0026rdquo;, but to avoid confusion, it is pronounced like \u0026ldquo;try\u0026rdquo; instead of like \u0026ldquo;tree\u0026rdquo;.\nSuppose, for example, that we want to store the following words:\n ape apple cable car cart cat cattle curl far farm  A trie storing these words (where we denote a value of true for the boolean with a *) is as follows:\nThus, for example, if we follow the path from the root through the labels \u0026lsquo;c\u0026rsquo;, \u0026lsquo;a\u0026rsquo;, and \u0026lsquo;r\u0026rsquo;, we reach a node with a true boolean value (shown by the * in the above picture); hence, \u0026ldquo;car\u0026rdquo; is in this set of words. However, if we follow the path through the labels \u0026lsquo;c\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, and \u0026lsquo;r\u0026rsquo;, the node we reach has a false boolean; hence, \u0026ldquo;cur\u0026rdquo; is not in this set. Likewise, if we follow the path through \u0026lsquo;a\u0026rsquo;, we reach a node from which there is no child labeled \u0026lsquo;c\u0026rsquo;; hence, \u0026ldquo;ace\u0026rdquo; is not in this set.\nNote that each subtree of a trie is also a trie, although the \u0026ldquo;words\u0026rdquo; it stores may begin to look a little strange. For example if we follow the path through \u0026lsquo;c\u0026rsquo; and \u0026lsquo;a\u0026rsquo; in the above figure, we reach a trie that contains the following \u0026ldquo;words\u0026rdquo;:\n \u0026ldquo;ble\u0026rdquo; \u0026ldquo;r\u0026rdquo; \u0026ldquo;rt\u0026rdquo; \u0026ldquo;t\u0026rdquo; \u0026ldquo;ttle\u0026rdquo;  These are actually the completions of the original words that begin with the prefix \u0026ldquo;ca\u0026rdquo;. Note that if, in this subtree, we take the path through \u0026rsquo;t', we reach a trie containing the following completions:\n \u0026quot;\u0026quot; [i.e., the empty string] \u0026ldquo;tle\u0026rdquo;  In particular, the empty string is a word in this trie. This motivates an alternative definition of the boolean stored in each node: it indicates whether the empty string is stored in the trie rooted at this node. This definition may be somewhat preferable to the one given above, as it does not depend on any context, but instead focuses entirely on the trie rooted at that particular node.\nOne of the main advantages of a trie over an AVL tree is the speed with which we can look up words. Assuming we can quickly find the child with a given label, the time we need to look up a word is proportional to the length of the word, no matter how many words are in the trie. Note that in looking up a word that is present in an AVL tree, we will at least need to compare the given word with its occurrence in the tree, in addition to any other comparisons done during the search. The time it takes to do this one comparison is proportional to the length of the word, as we need to verify each character (we actually ignored the cost of such comparisons when we analyzed the performance of AVL trees). Consequently, we can expect a significant performance improvement by using a trie if our set of words is large.\nLet\u0026rsquo;s now consider how we can implement a trie. There are various ways that this can be done, but we\u0026rsquo;ll consider a fairly straightforward approach in this section (we\u0026rsquo;ll improve the implementation in the next section). We will assume that the words we are storing are comprised of only the 26 lower-case English letters. In this implementation, a single node will contain the following private fields:\n A bool storing whether the empty string is contained in the trie rooted at this node (or equivalently, whether this node ends a word in the entire trie). A 26-element array of tries storing the children, where element 0 stores the child labeled \u0026lsquo;a\u0026rsquo;, element 1 stores the child labeled \u0026lsquo;b\u0026rsquo;, etc. If there is no child with some label, the corresponding array element is null.  Note that in this implementation, no chars or strings are actually stored. We can see if a node has a child labeled by a given char by finding the difference between that char and \u0026lsquo;a\u0026rsquo;, and using that difference as the array index. For example, suppose the array field is named _children, and suppose label is a char variable containing a lower-case letter. Because char is technically a numeric type, we can perform arithmetic with chars; thus, we can obtain the child labeled by label by retrieving _children[label - 'a']. More specifically, if label contains \u0026rsquo;d', then the difference, label - 'a' will be 3; hence, the child with label \u0026rsquo;d' will be stored at index 3. We have therefore achieved our goal of providing quick access to a child with a given label.\nLet\u0026rsquo;s now consider how to implement a lookup. We can define a public method for this purpose within the class implementing a trie node:\npublic bool Contains(string s) { . . . }  Note\nThis method does not need a trie node as a parameter because the method will belong to a trie node. Thus, the method will be able to access the node as this, and may access its private fields directly by their names.\n The method consists of four cases:\n s is the empty string. In this case the bool stored in this node indicates whether it is a word in this trie; hence, we can simply return this bool. The first character of s is not a lower-case English letter (i.e., it is less than \u0026lsquo;a\u0026rsquo; or greater than \u0026lsquo;z\u0026rsquo;). Then s can\u0026rsquo;t be stored in this trie. In this case, we can return false. The child labeled with the first character of s (obtained as described above) is missing (i.e., is null). Then s isn\u0026rsquo;t stored in this trie. Again, we return false. The child labeled with the first character of s is present (i.e., non-null). In this case, we need to determine whether the substring following the first character of s is in the trie rooted at the child we retrieved. This can be found using a recursive call to this method within the child trie node. We return the result of this recursive call.  In order to be able to look up words, we need to be able to build a trie to look in. We therefore need to be able to add words to a trie. It\u0026rsquo;s not practical to make a trie node immutable, as there is too much information that would need to be copied if we need to replace a node with a new one (we would need to construct a new node for each letter of each word we added). We therefore should provide a public method within the trie node class for the purpose of adding a word to the trie rooted at this node:\npublic void Add(string s) { . . . } This time there are three cases:\n s is the empty string. Then we can record this word by setting the bool in this node to true. The first character of s is not a lower-case English letter. Then we can\u0026rsquo;t add the word. In this case, we\u0026rsquo;ll need to throw an exception. The first character is a lower-case English letter. In this case, we need to add the substring following the first character of s to the child labeled with the first letter. We do this as follows:  If the child labeled with the first letter of the word is missing (i.e., null), we construct a new trie node and place it in the array location for this child. Now that we have a child labeled with the first letter, we can add the substring following the first letter to this child by making a recursive call.    "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/select/",
	"title": "Select Sorts",
	"tags": [],
	"description": "",
	"content": "Select Sorts A select sort operates by repeatedly selecting the smallest data element of an unsorted portion of the array and moving it to the end of a sorted portion. Thus, at each step, the data items will be arranged into two parts:\n A sorted part; and An unsorted part in which each element is at least as large as all elements in the sorted part.  The following figure illustrates this arrangement.\nInitially, the sorted part will be empty. At each step, the unsorted part is rearranged so that its smallest element comes first. As a result, the sorted part can now contain one more element, and the unsorted part one fewer element. After $n - 1$ steps, where $n$ is the number of elements in the array, the sorted part will have all but one of the elements. Because the one element in the unsorted part must be at least as large as all elements in the sorted part, the entire array will be sorted at this point.\nThe approach outlined above can be implemented in various ways. The main difference in these implementations is in how we rearrange the unsorted part to bring its smallest element to the beginning of that part. The most straightforward way to do this is to find the smallest element in this part, then swap it with the first element in this part. The resulting algorithm is called selection sort. It requires nested loops. The outer loop index keeps track of how many elements are in the sorted part. The unsorted part then begins at this index. The inner loop is responsible for finding the smallest element in the unsorted part. Once the inner loop has finished, the smallest element is swapped with the first element in the unsorted part.\nNote that the inner loop in selection sort iterates once for every element in the unsorted part. On the first iteration of the outer loop, the unsorted part contains all $n$ elements. On each successive iteration, the unsorted part is one element smaller, until on the last iteration, it has only $2$ elements. If we add up all these values, we find that the inner loop iterates a total of exactly $(n - 1)(n + 2)/2$ times. This value is proportional to $n^2$ as $n$ increases; hence, the running time of the algorithm is in $O(n^2)$. Furthermore, this performance occurs no matter how the data items are initially arranged.\nAs we will see in what follows, $O(n^2)$ performance is not very good if we want to sort a moderately large data set. For example, sorting $10,000$ elements will require about $5$ billion iterations of the inner loop. On the positive side, the only time data items are moved is when a swap is made at the end of the outer loop; hence, this number is proportional to $n$. This could be advantageous if we are sorting large value types, as we would not need to write these large data elements very many times. However, for general performance reasons, large data types shouldn\u0026rsquo;t be value types \u0026mdash; they should be reference types to avoid unnecessary copying of the values. For this reason, selection sort isn\u0026rsquo;t a particularly good sorting algorithm.\n Performance issues aside, however, there is one positive aspect to selection sort. This aspect has to do with sorting by keys. Consider, for example, the rows of a spreadsheet. We often want to sort these rows by the values in a specific column. These values are the sort keys of the elements. In such a scenario, it is possible that two data elements are different, but their sort keys are the same. A sorting algorithm might reverse the order of these elements, or it might leave their order the unchanged. In some cases, it is advantageous for a sorting algorithm to leave the order of these elements unchanged. For example, if we sort first by a secondary key, then by a primary key, we would like for elements whose primary keys are equal to remain sorted by their secondary key. Therefore, a sorting algorithm that always maintains the original order of equal keys is said to be stable. If we are careful how we implement the inner loop of selection sort so that we always select the first instance of the smallest key, then this algorithm is stable.\n Another implementation of a select sort is bubble sort. It rearranges the unsorted part by swapping adjacent elements that are out of order. It starts with the last two elements (i.e., the elements at locations $n - 1$ and $n - 2$), then the elements at locations $n - 2$ and $n - 3$, etc. Proceeding in this way, the smallest element in the unsorted part will end up at the beginning of the unsorted part. While the inner loop is doing this, it keeps track of whether it has made any swaps. If the loop completes without having made any swaps, then the array is sorted, and the algorithm therefore stops.\nLike selection sort, bubble sort is stable. In the worst case, however, the performance of bubble sort is even worse than that of selection sort. It is still in $O(n^2)$, but in the worst case, its inner loop performs the same number of iterations, but does a lot more swaps. Bubble sort does outperform selection sort on some inputs, but describing when this will occur isn\u0026rsquo;t easy. For example, in an array in which the largest element occurs in the first location, and the remaining locations are sorted, the performance ends up being about the same as selection sort \u0026mdash; even though this array is nearly sorted. Like selection sort, it is best to avoid bubble sort.\n A select sort that significantly outperforms selection sort is known as heap sort. This algorithm is based on the idea that a priority queue can be used to sort data \u0026mdash; we first place all items in a priority queue, using the values themselves as priorities (if we are sorting by keys, then we use the keys as priorities). We then repeatedly remove the element with largest priority, filling the array from back to front with these elements.\nWe can optimize the above algorithm by using a priority queue implementation called a binary heap, whose implementation details we will only sketch. The basic idea is that we can form a binary tree from the elements of an array by using their locations in the array. The first element is the root, its children are the next two elements, their children are the next four elements, etc. Given an array location, we can then compute the locations of its parent and both of its children. The priorities are arranged so that the root of each subtree contains the maximum priority in that subtree. It is possible to arrange the elements of an array into a binary heap in $O(n)$ time, and to remove an element with maximum priority in $O(\\lg n)$ time.\nHeap sort then works by pre-processing the array to arrange it into a binary heap. The binary heap then forms the unsorted part, and it is followed by the sorted part, whose elements are all no smaller than any element in the unsorted part. While this arrangement is slightly different from the arrangement for the first two select sorts, the idea is the same. To rearrange the unsorted part, it:\n Copies the first (i.e., highest-priority) element to a temporary variable. Removes the element with maximum priority (i.e., the first element). Places the copy of the first element into the space vacated by its removal at the beginning of the sorted part.  Heap sort runs in $O(n \\lg n)$ time in the worst case. Information theory can be used to prove that any sorting algorithm that sorts by comparing elements must make at least $\\lg(n!)$ comparisons on some arrays of size $n$. Because $\\lg(n!)$ is proportional to $n \\lg n$, we cannot hope to do any better than $O(n \\lg n)$ in the worst case. While this performance is a significant improvement over selection sort and bubble sort, we will see in a later section that there is an algorithm (quick sort) that does even better in practice. Furthermore, heap sort is not stable.\nOn the other hand, we will also see that in spite of the fact that quick sort usually outperforms heap sort, there are rare cases that cause it to perform badly. In order to avoid this bad behavior, a hybrid algorithm using both quick sort and heap sort has been developed. We will examine this approach in \u0026ldquo;Hybrid Sorts\u0026rdquo;.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/strings/strings/",
	"title": "strings",
	"tags": [],
	"description": "",
	"content": "strings Instances of the string class are immutable sequences of characters. Because string is a class, it is a reference type. Because instances are immutable, once they are constructed, their contents cannot change. Note that this does not mean that string variables cannot change - we can assign a string variable s the value \u0026ldquo;abc\u0026rdquo; and later assign it the value \u0026ldquo;xyz\u0026rdquo;. These assignments simply assign to s references to different instances of the string class. What immutability does mean is that there is no way to change any of the characters in either of these instances (i.e., in either \u0026ldquo;abc\u0026rdquo; or \u0026ldquo;xyz\u0026rdquo;). As a result, it is safe to copy a string by simply assigning the value of one string variable to another; for example, if s is a string variable, we can write:\nstring t = s; Note that this is not safe when dealing with mutable reference types, such as arrays. For example, let a be an int[ ] with at least one element, and consider the following code sequence:\nint[ ] b = a; b[0]++; Because a and b refer to the same array, a[0] is incremented as well. This danger is absent for strings because they are immutable.\nWe access individual characters in a string by indexing; i.e., if s is a string variable, then s[0] retrieves its first character, s[1] retrieves its second character, etc. For example, if s refers to the string, \u0026ldquo;abc\u0026rdquo;, then after executing\nchar c = s[1]; c will contain \u0026lsquo;b\u0026rsquo;. Note that a statement like\ns[0] = \u0026#39;x\u0026#39;; is prohibited in order to enforce immutability.\nWe obtain the number of characters in a string using its Length property; for example:\nint len = s.Length;  Note\nA string may have a length of 0. This means that it is the empty string, denoted by \u0026ldquo;\u0026rdquo;. Note that \u0026quot;\u0026quot; is different from a null reference - for example, if s refers to \u0026ldquo;\u0026rdquo;, then s.Length has a value of 0, but if s is null, then this expression will throw a NullReferenceException.\n We can concatenate two strings using the + operator. For example, if s refers to the string \u0026ldquo;abc\u0026rdquo; and t refers to the string \u0026ldquo;xyz\u0026rdquo;, then\nstring u = s + t; will assign the string \u0026ldquo;abcxyz\u0026rdquo; to u.\nBecause strings are immutable, building long strings directly from many small pieces is very inefficient. Suppose, for example, that we want to convert all the lower-case characters in the string text to upper-case, and to convert all upper-case letters in text to lower-case. All other characters we will leave unchanged. We can do this with the following code:\nstring result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; text.Length; i++) { char c = text[i]; if (Char.IsLower(c)) { result += Char.ToUpper(c); } else if (Char.IsUpper(c)) { result += Char.ToLower(c); } else { result += c; } } Now suppose that text contains 100,000 characters. Each iteration of the loop executes one of the three branches of the if-statement, each of which concatenates one character to the string accumulated so far. Because strings are immutable, this concatenation must be done by copying all the characters in result, along with the concatenated character, to a new string. As a result, if we were to add up the total number of characters copied over the course of the entire loop, we would come up with 5,000,050,000 character copies done. This may take a while. In general, we say that this code runs in O(n2) time, where n is the length of text. This means that as n increases, the running time of the code is at worst proportional to n2. In the next section, we will see how we can do this much more efficiently using another data structure.\nstrings have many other methods to allow various kinds of manipulation - see the documentation for the string class for details.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/dictionaries/dictionary-tkey-tvalue/",
	"title": "The Dictionary&lt;TKey, TValue&gt; Class",
	"tags": [],
	"description": "",
	"content": "The Dictionary\u0026lt;TKey, TValue\u0026gt; Class A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. The .NET Framework provides the Dictionary\u0026lt;TKey, TValue\u0026gt; class for this purpose. In this section, we will discuss the use of this class. In the next section, we will discuss how this data structure can be implemented using a linked list. In subsequent sections, we will consider alternative implementations.\nNote that the Dictionary\u0026lt;TKey, TValue\u0026gt; has two type parameters, TKey and TValue. TKey is the type of the keys, and TValue is the type of the values (i.e., the data elements associated with the keys). Keys must always be non-null \u0026mdash; any attempt to use a null key will result in an ArgumentNullException. A Dictionary\u0026lt;TKey, TValue\u0026gt;\u0026rsquo;s most basic public methods are:\n void Add(TKey key, TValue value): Associates the given value with the given key. If there is already a value associated with the given key, it throws an ArgumentException. bool Remove(TKey key): Removes the given key and its associated value from the dictionary, and returns whether the key was found. bool TryGetValue(TKey key, out TValue value): Returns whether the given key is in the dictionary. If so, the out parameter value is assigned the value associated with key; otherwise, value is assigned the default value for its type.  The above methods can be used for building and updating a Dictionary, as well as for looking up values by their keys. It is also possible to do updates and lookups using indexing. Specifically, a key may be used as an index in a Dictionary, as if the Dictionary were an array. For example, suppose that dictionary is a Dictionary\u0026lt;TKey, TValue\u0026gt;, k is a TKey, and v is a TValue. We can then do the following:\ndictionary[k] = v; This will associate the value v with the key k, as the Add method does; however, its behavior is slightly different if k already has a value associated with it. Whereas the Add method would throw an exception in this case, using the indexer will simply replace the value previously associated with k by the new value v. Thus, we use the Add method when we expect the key to be a new key for the dictionary, but we use the indexer when we want to associate the value with the key, regardless of whether the key is already in the dictionary.\nLikewise, we can use the indexer to look up a key:\nv = dictionary[k]; Again, the behavior is similar to the TryGetValue method, but slightly different, as there is no bool in the above statement. When using the indexer, if the key is not in the dictionary, it will throw a KeyNotFoundException. Thus, we use the indexer when we expect the key to be in the dictionary, but we use the TryGetValue method when we don\u0026rsquo;t know if the key is in the dictionary.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/",
	"title": "Visual Studio Community 2022",
	"tags": [],
	"description": "",
	"content": "Visual Studio Community 2022 This chapter will guide you through the use of Visual Studio 2022 and GitHub to obtain start code for your assignments, build, test, and debug graphical applications and class libraries, and submit assignment solutions. No attempt is meant to be exhaustive, as many of the features of Visual Studio are beyond the scope of CIS 300.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/",
	"title": "Programming Style Requirements",
	"tags": [],
	"description": "",
	"content": "Programming Style Requirements Software companies typically have programming style requirements to which their programmers must adhere. Many of these requirements have become industry standards. These requirements help to make the developed code more readable, portable, and maintainable. This appendix contains a short set (much shorter than what is typically found in industry) of programming style requirements for CIS 300. Most of these requirements are derived from a style guide posted at Pete Brown’s 10rem.net; that guide is consistent with Microsoft’s Naming Guidelines and de facto industry accepted practices. Other requirements are simplifications introduced due to the fact that this programming is for course assignments, rather than for distribution.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/access-modifiers/",
	"title": "Access Modifiers",
	"tags": [],
	"description": "",
	"content": "Access Modifiers C# provides 4 access modifiers for classes, fields, etc.: public, internal, protected, and private. For simplicity, however, we will not allow the use of the internal or protected access modifiers.\nWhen classes, fields, etc., are declared, C# does not require that an access modifier be used. If the access modifier is omitted, a default accessibility level will be used. However, the default depends on where it is being declared. For example, the default accessibility level of a top-level type is internal, whereas the default accessibility level of a class member is private. In order to avoid confusion, we will require that access modifiers (i.e., public or private) be used on all declarations except where C# does not allow them (C# does not allow access modifiers for namespaces, members of interfaces or enumerations, or local variables within methods). In particular, note that when Visual Studio® automatically generates a class statement, it does not always supply an access modifier. We require that public be explicitly inserted (C# does not allow private here).\nIn addition, fields within classes and structures should be declared private, unless they are also declared const. If you want to make a variable accessible to outside code, you can instead do something like the following:\npublic double Force { get; set; } Or if you want the outside code to be able to access it, but you don\u0026rsquo;t want it to change its value you can instead define it as:\npublic double Force { get; private set; } In these examples, Force is not a field, but a property. It can be used like a field, but defining it as a property makes it more maintainable (see “Properties” for more details).\nFor more information on access modifiers and accessibility levels, see the section on Accessibility Levels in the C# Reference.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/bst/",
	"title": "Binary Search Trees",
	"tags": [],
	"description": "",
	"content": "Binary Search Trees We motivated our discussion of trees by expressing a need for a linked data structure that supports a binary search or something similar. We will present such a data structure - a binary search tree - in this section. While it will support efficient lookups, insertions, and deletions for many applications, we will see that there are cases in which it performs no better than a linked list. In the next section, we will add some refinements that will guarantee good performance.\nBefore we can define a binary search tree, we need to define a more primitive structure, a binary tree. We will then use binary trees to define binary search trees, and show how to build them and search them. We will then show how to remove elements from them. We conclude this section by presenting the inorder traversal algorithm, which processes all the elements in a binary search tree in order.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/repos/",
	"title": "Git Repositories",
	"tags": [],
	"description": "",
	"content": "Git Repositories In CIS 300, start code for each assignment will be distributed via a Git repository. Git is a source control system integrated into Visual Studio 2019. Source control systems are powerful mechanisms for teams of programmers and other collaborators to manage multiple copies of various source files and other documents that all collaborators may be modifying. While CIS 300 does not involve teamwork, source control provides a convenient mechanism for distribution of code and submission of assignment solutions. In addition, as we will discuss later, source control provides mechanisms for accessing your code on multiple machines and for “checkpointing” your code.\nAt the heart of Git is the concept of a Git repository. A Git repository is essentially a folder on your local machine. As you make changes within this folder, Git tracks these changes. From time to time, you will commit these changes. If you see that you have gone down a wrong path, you can revert to an earlier commit. Git repositories may be hosted on a server such as GitHub. Various users may have copies of a Git repository on their own local machines. Git provides tools for synchronizing local repositories with the repository hosted on the server in a consistent way.\nNote\nThe above description is a bit of an oversimplification, as the folder comprising a local copy of a repository typically contains some files and/or folders that are not part of the repository. One example of such \u0026ldquo;extra\u0026rdquo; files might be executables that are generated whenever source code within the repository is compiled. However, when Visual Studio is managing a Git repository, it does a good job of including within the repository any files the user places within the folder comprising the repository.\n For each lab and homework assignment in CIS 300, you will be provided a URL that will create your own private Git repository on GitHub. The only people who will have access to your GitHub repositories are you, the CIS 300 instructors, and the CIS 300 lab assistants. These repositories will initially contain start code and perhaps data files for the respective assignments. You will copy the repository to your local machine by cloning it. When you are finished with the assignment, you will push the repository back to GitHub and submit its URL for grading. In what follows, we will explain how to create and clone a GitHub repository. Later in this chapter, we will explain how to commit changes, push a repository, and use some of the other features of Git.\nBefore you can access GitHub, you will need a GitHub account. If you don\u0026rsquo;t already have one, you can sign up for one at github.com. At some point after you have completed the sign-up process, GitHub will send you an email asking you to verify the email address you provided during the sign-up process. After you have done this, you will be able to set up GitHub repositories.\nFor each assignment in CIS 300, you will be given an invitation URL, such as:\n https://classroom.github.com/a/HPnOcv6d  Over the next few sections, we will be working through a simple example based on the above invitation link. If you wish to work through this example, click on the above link. You may be asked to sign in to GitHub, but once you are signed in, you will be shown a page asking you to accept the assignment. Clicking the \u0026ldquo;Accept this assignment\u0026rdquo; button will create a GitHub repository for you. You will be given a link that will take you to that repository. From that page you will be able to view all of the files in the repository.\nIn order to be able to use this repository, you will need to clone it to your local machine. To do this, first open Visual Studio 2019, and click on the \u0026ldquo;Clone a Repository\u0026rdquo; button on the right. In your web browser, navigate to the GitHub repository that you wish to clone, and click on the \u0026ldquo;Code\u0026rdquo; button. This will display a URL - click on the button to its right to copy this URL to your clipboard. Then go back to Visual Studio and paste this URL into the text box labeled, \u0026ldquo;Repository location\u0026rdquo;. In the text box below that, fill in a new folder you want to use for this repository on your machine, then click the \u0026ldquo;Clone\u0026rdquo; button (if you are asked for your GitHub login credentials, supply them). This will copy the Git repository from GitHub into the folder you selected, and open the solution it contains.\nTip\nIf you have a solution open in Visual Studio and want to clone another repository, you don\u0026rsquo;t have to restart Visual Studio. First find the Team Explorer (if you don\u0026rsquo;t see it, you can find it on the View menu), then click on the icon that looks like an electrical plug at the top. Scroll down to the section, \u0026ldquo;Local Git Repositories\u0026rdquo;, and click the \u0026ldquo;Clone\u0026rdquo; link. Enter the addresses of the GitHub repository and the local repository into the two text boxes, and click the \u0026ldquo;Clone\u0026rdquo; button. This will add the repository to the list of local repositories. To open the solution it contains, double-click the name of the repository, then double-click the solution it contains.\n The following sections give an overview of how to use Visual Studio to edit and debug an application, as well as how to use Git within Visual Studio to maintain the local Git repository and synchronize it with the GitHub repository.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/repos/",
	"title": "Git Repositories",
	"tags": [],
	"description": "",
	"content": "Git Repositories In CIS 300, start code for each assignment will be distributed via a Git repository. Git is a source control system integrated into Visual Studio 2022. Source control systems are powerful mechanisms for teams of programmers and other collaborators to manage multiple copies of various source files and other documents that all collaborators may be modifying. While CIS 300 does not involve teamwork, source control provides a convenient mechanism for distribution of code and submission of assignment solutions. In addition, as we will discuss later, source control provides mechanisms for accessing your code on multiple machines and for “checkpointing” your code.\nAt the heart of Git is the concept of a Git repository. A Git repository is essentially a folder on your local machine. As you make changes within this folder, Git tracks these changes. From time to time, you will commit these changes. If you see that you have gone down a wrong path, you can revert to an earlier commit. Git repositories may be hosted on a server such as GitHub. Various users may have copies of a Git repository on their own local machines. Git provides tools for synchronizing local repositories with the repository hosted on the server in a consistent way.\nNote\nThe above description is a bit of an oversimplification, as the folder comprising a local copy of a repository typically contains some files and/or folders that are not part of the repository. One example of such \u0026ldquo;extra\u0026rdquo; files might be executables that are generated whenever source code within the repository is compiled. However, when Visual Studio is managing a Git repository, it does a good job of including within the repository any files the user places within the folder comprising the repository.\n For each lab and homework assignment in CIS 300, you will be provided a URL that will create your own private Git repository on GitHub. The only people who will have access to your GitHub repositories are you, the CIS 300 instructors, and the CIS 300 lab assistants. These repositories will initially contain start code and perhaps data files for the respective assignments. You will copy the repository to your local machine by cloning it. When you are finished with the assignment, you will push the repository back to GitHub and submit its URL for grading. In what follows, we will explain how to create and clone a GitHub repository. Later in this chapter, we will explain how to commit changes, push a repository, and use some of the other features of Git.\nBefore you can access GitHub, you will need a GitHub account. If you don\u0026rsquo;t already have one, you can sign up for one at github.com. At some point after you have completed the sign-up process, GitHub will send you an email asking you to verify the email address you provided during the sign-up process. After you have done this, you will be able to set up GitHub repositories.\nFor each assignment in CIS 300, you will be given an invitation URL, such as:\n https://classroom.github.com/a/HPnOcv6d  Over the next few sections, we will be working through a simple example based on the above invitation link. If you wish to work through this example, click on the above link. You may be asked to sign in to GitHub, but once you are signed in, you will be shown a page asking you to accept the assignment. Clicking the \u0026ldquo;Accept this assignment\u0026rdquo; button will create a GitHub repository for you. You will be given a link that will take you to that repository. From that page you will be able to view all of the files in the repository.\nIn order to be able to use this repository, you will need to clone it to your local machine. To do this, first open Visual Studio 2022, and click on the \u0026ldquo;Clone a Repository\u0026rdquo; button on the right. In your web browser, navigate to the GitHub repository that you wish to clone, and click on the \u0026ldquo;Code\u0026rdquo; button. This will display a URL - click on the button to its right to copy this URL to your clipboard. Then go back to Visual Studio and paste this URL into the text box labeled, \u0026ldquo;Repository location\u0026rdquo;. In the text box below that, fill in a new folder you want to use for this repository on your machine, then click the \u0026ldquo;Clone\u0026rdquo; button (if you are asked to sign in to GitHub, click the link to sign in through your web browser). This will copy the Git repository from GitHub into the folder you selected, and open the solution it contains.\nThe following sections give an overview of how to use Visual Studio to edit and debug an application, as well as how to use Git within Visual Studio to maintain the local Git repository and synchronize it with the GitHub repository.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/dictionaries/linked-list-impl/",
	"title": "Implementing a Dictionary with a Linked List",
	"tags": [],
	"description": "",
	"content": "Implementing a Dictionary with a Linked List One way of implementing a dictionary is to store all the keys and values in a linked list. We want to do this in such a way that a key is stored together with its associated value. To facilitate this, the .NET Framework provides a structure KeyValuePair\u0026lt;TKey, TValue\u0026gt; in the System.Collections.Generic namespace. This structure is used simply for storing a key and a value. The type parameter TKey is used to define the type of the keys, and the other type parameter TValue is used to define the type of the values. It has two public properties:\n Key, which gets the key stored; and Value, which gets the value stored.  Note that neither of these properties can be set; i.e., the structure is immutable. In order to set the key and value, we need to construct a new instance using its 2-parameter constructor. The first parameter to this constructor is the key, and the second is the value.\nNow that we have a way of storing keys and values together, we can implement a Dictionary\u0026lt;TKey, TValue\u0026gt; with a linked list comprised of instances of LinkedListCell\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt;. Thus, each cell of the list stores as its Data a KeyValuePair\u0026lt;TKey, TValue\u0026gt; containing a key and its associated value. To add a key and a value, we first need to search the list for a cell containing that key. If we find such a cell, we either replace the KeyValuePair in that cell with a new KeyValuePair containing the given key and value, or we throw an exception, depending on the specific behavior required. If we don\u0026rsquo;t find such a cell, we insert a new cell containing the given key and value. Because it doesn\u0026rsquo;t matter where we insert it, we might as well insert it at the beginning of the list, as that is the easiest way. We can remove a key using techniques described in \u0026ldquo;Finding Prime Numbers”.\nThe main disadvantage to this approach is that searching for a key is expensive. For example, to search for a key that is not in the dictionary, we need to examine every key in the dictionary. We would like to improve on this performance.\nOne way of improving the performance of searching is to store the keys in increasing order. Then as we search, if we see a key that is larger than the key we are looking for, we can stop. However, recall that keys can be of any type. For some types of keys, \u0026ldquo;increasing order\u0026rdquo; and \u0026ldquo;larger than\u0026rdquo; make no sense.\n C# does provide a way to restrict the types that can be passed as type parameters to generic types. Specifically, we can restrict the type TKey by writing the class statement as follows:\npublic class Dictionary\u0026lt;TKey, TValue\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; The where clause in this statement constrains TKey to be a subtype of IComparable\u0026lt;TKey\u0026gt;. Each subtype of IComparable\u0026lt;TKey\u0026gt; contains a method public int CompareTo(TKey x). If a and b are of type TKey, then a.CompareTo(b) returns:\n A negative number if a is considered to be less than b; 0 if a is considered to be equal to b; or A positive number if a is considered to be greater than b.  We can therefore use this CompareTo method to keep the list in increasing order.\nNote that by constraining the key type in this way, we are making the Dictionary\u0026lt;TKey, TValue\u0026gt; less general, as we may sometimes want to use a key type that can\u0026rsquo;t be ordered. On the other hand, there are times when not only do we have a key type that can be ordered, but also we need to access the keys in increasing order (for example, to print an ordered list of keys with their values). In such cases, what we actually need is an ordered dictionary, which both restricts the keys in this way and provides a means of accessing them in increasing order. While we won\u0026rsquo;t consider the full implementation of an ordered dictionary here, it is worth considering how we can improve performance by keeping the keys in increasing order.\nLet\u0026rsquo;s now consider how to add a key and value to a linked list storing keys in increasing order. We first need to find where the key belongs in the ordering. Specifically, the cell whose Next property needs to be changed (assuming the key is not already in the list) is the one that must precede the new cell. We therefore need to find the last cell whose key is less than the key we need to add. Note also that when we are removing a key, the cell whose Next property needs to be changed is the last cell whose key is less than the key we are removing. Furthermore, if we are looking up a key, we need to look in the cell that follows the last cell whose key is less than the key we are looking for. This suggests that we should provide a private method to find the last cell whose key is less than a given key.\nBefore we can write such a method, however, we first need to address a problem that occurs if we are trying to add, remove, or look up a key that is smaller than all other keys in the list. In this case, there are no cells containing keys smaller than the given key.\nWe can avoid needing a special case to deal with this problem if we include a special header cell at the beginning of our linked list. This cell will not contain any meaningful data, but it will always be present. If we consider that its key is less than any other key (though we will never actually examine its key), then there will always be at least one key less than any given key. We can obtain this header cell by initializing the linked list to contain a new cell, rather than to null.\nA method to find the last cell containing a key less than a given key is now straightforward. We initialize a variable to the first cell (i.e., the header cell), and set up a loop that iterates as long as the next cell is non-null and contains a key less than the given key. Each iteration advances to the next cell. When the loop terminates, we return the cell we have reached.\nTo look up a key, we use the above method to find the last cell containing a key less than the key we are looking for. If the next cell is non-null and contains the key we are looking for, then we have found it; otherwise, it cannot be in the list. To add a key and value, we first need to look up the key in the same way. If we don\u0026rsquo;t find it, we insert a new cell containing this key and value following the last cell containing a key less than this key. To remove a key, we proceed in a similar way, but if we find the key, we remove this cell from the list.\nWhile keeping the keys in increasing order improves the performance of many searches, the overall performance is still unsatisfactory for even data sets of moderate size. In subsequent sections, we will explore ways of improving this performance using various data structures.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/linked-lists/stacks-queues/",
	"title": "Implementing Stacks and Queues with Linked Lists",
	"tags": [],
	"description": "",
	"content": "Implementing Stacks and Queues with Linked Lists Because linked lists store data elements in linear sequences, they can be used to give alternative implementations of stacks and queues. One advantage to using linked lists is that we don\u0026rsquo;t have to worry about filling up something like an array - we can just keep allocating cells as long as we need to (unless we run out of memory).\nImplementing a stack using a linked list is particularly easy because all accesses to a stack are at the top. One end of a linked list, the beginning, is always directly accessible. We should therefore arrange the elements so that the top element of the stack is at the beginning of the linked list, and the bottom element of the stack is at the end of the linked list. We can represent an empty stack with null.\nWe therefore need a private LinkedListCell\u0026lt;T\u0026gt; field to implement a generic stack Stack\u0026lt;T\u0026gt; using a linked list. This field will refer to the cell containing the data item at the top of the stack. A public Count property will be used to keep track of the number of elements in the stack.\nThe public methods Push, Peek, and Pop are then fairly straightforward to implement. For Push we need to add the given element to a new cell at the beginning of the linked list, as shown in the previous section, and update the Count. To implement Peek, if the stack is nonempty, we simply return the Data property of the cell at the beginning of the linked list; otherwise, we throw an InvalidOperationException. To implement Pop:\n Using Peek, obtain the element to be returned; Remove the first element from the linked list as shown in the previous section; Update the Count; and Return the retrieved value.  Implementing a queue is a little more involved because we need to operate at both ends of the linked list. For efficiency, we should keep a reference to the last cell in the linked list, as this will allow us to access both ends of the linked list directly. We will therefore have the following:\nWe now need to decide which end to make the front of the queue. As we saw in the previous section, both inserting and removing can be done efficiently at the beginning of a linked list. Likewise, it is easy to insert an element at the end if we have a reference to the last cell. Suppose, for example, that last refers to the last cell in a linked list, and that cell refers to a LinkedListCell\u0026lt;T\u0026gt; that we want to insert at the end. Suppose further that the linked list is not empty (that will be a special case that we\u0026rsquo;ll need to handle). Thus, we have the following:\nTo insert this cell at the end of the linked list, we just need to copy the reference in cell to the Next property of the cell to which last refers:\nlast.Next = cell; On the other hand, removing the last cell is problematic, even if we have a reference to it. The problem is that in order to remove it from the linked list, we need to change the Next property of the preceding cell. Unfortunately, the only way to obtain that cell is to start at the beginning of the list and work our way through it. If the linked list is long, this could be quite inefficient.\nNote\nIt doesn\u0026rsquo;t help any to keep a reference to the next-to-last cell, as we encounter the same problem when we need to update this reference after removing the last cell \u0026mdash; we don\u0026rsquo;t have a reference to its preceding cell.\n Because we need to remove elements from the front of a queue, but not from the back, we conclude that it will work best to make the beginning of the linked list the front of the queue. We therefore need the following private fields to implement a generic queue Queue\u0026lt;T\u0026gt;:\n A LinkedListCell\u0026lt;T\u0026gt; giving the element at the front of the queue. This will be the beginning of the linked list of queue elements. A LinkedListCell\u0026lt;T\u0026gt; giving the element at the back of the queue. This will be the last cell in the linked list of queue elements.  As we mentioned earlier, adding an element to an empty queue is a special case that we will need to handle separately. For this reason, it doesn\u0026rsquo;t matter what values the two LinkedListCell\u0026lt;T\u0026gt; fields contain when the queue is empty - we can always detect when the queue is empty by checking the Count. The initialization of the two LinkedListCell\u0026lt;T\u0026gt; fields is therefore unimportant. It is easiest to just leave them null.\nLet us now consider the implementation of the Enqueue method. We need to consider two cases. We\u0026rsquo;ll first consider the case in which the queue is empty. In this case, we need to build the following linked list:\nWe therefore need to:\n Construct a new LinkedListCell\u0026lt;T\u0026gt;; Assign it to the field denoting the front of the queue; Assign it to the field denoting the back of the queue; Store the given element in its Data property; and Update the Count.  If the queue is nonempty, the only step that changes is Step 2. Because the queue is nonempty, we don\u0026rsquo;t want to make the new cell the front of the queue; instead, we need to insert it at the end of the linked list, as outlined above.\nThe implementations of the Peek and Dequeue methods are essentially the same as the implementations of the Peek and Pop methods, respectively, for a stack.\nThe implementations described in this section are simpler than the implementations using arrays, mainly due to the fact that we don\u0026rsquo;t need to rebuild the structure when we fill up the space available. While these implementations are also pretty efficient, it turns out that the array-based implementations tend to out-perform the linked-list-based implementations. This might be counterintuitive at first because rebuilding the structures when the array is filled is expensive. However, due to the fact that we double the size of the array each time we need a new one, this rebuilding is done so rarely in practice that it ends up having minimal impact on performance. Due to hardware and low-level software issues, the overhead involved in using arrays usually ends up being less.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/insert/",
	"title": "Insert Sorts",
	"tags": [],
	"description": "",
	"content": "Insert Sorts An insert sort operates by repeatedly inserting an element into a sorted portion of the array. Thus, as for select sorts, at each step the data items will be arranged into a sorted part, followed by an unsorted part; however, for insert sorts, there is no restriction on how elements in the unsorted part compare to elements in the sorted part. The following figure illustrates this arrangement.\nInitially, the sorted part will contain the first element, as a single element is always sorted. At each step, the first element in the unsorted part is inserted into its proper location in the sorted part. As a result, the sorted part now contains one more element, and the unsorted part one fewer element. After $n - 1$ steps, where $n$ is the number of elements in the array, the sorted part will contain all the elements, and the algorithm will be done.\nAgain, this approach can be implemented in various ways. The main difference in these implementations is in how we insert an element. The most straightforward way is as follows:\n Copy the first element of the unsorted part to a temporary variable. Iterate from the location of the first element of the unsorted part toward the front of the array as long as we are at an index greater than 0 and the element to the left of the current index is greater than the element in the temporary variable. On each iteration:  Copy the element to the left of the current index to the current index.   Place the value in the temporary variable into the location at which the above loop stopped.  The algorithm that uses the above insertion technique is known as insertion sort. Like selection sort, it requires an outer loop to keep track of the number of elements in the sorted part. Each iteration of this outer loop performs the above insertion algorithm. It is not hard to see that this algorithm is stable.\nThe main advantage insertion sort has over selection sort is that the inner loop only iterates as long as necessary to find the insertion point. In the worst case, it will iterate over the entire sorted part. In this case, the number of iterations is the same as for selection sort; hence, the worst-case running time is in $O(n^2)$ \u0026mdash; the same as selection sort and bubble sort. At the other extreme, however, if the array is already sorted, the inner loop won\u0026rsquo;t need to iterate at all. In this case, the running time is in $O(n)$, which is the same as the running time of bubble sort on an array that is already sorted.\nUnlike bubble sort, however, insertion sort has a clean characterization of its performance based on how sorted the array is. This characterization is based on the notion of an inversion, which is a pair of array locations $i \\lt j$ such that the value at location $i$ is greater than the value at location $j$; i.e., these two values are out of order with respect to each other. A sorted array has no inversions, whereas in an array of distinct elements in reverse order, every pair of locations is an inversion, for a total of $n(n - 1)/2$ inversions. In general, we can say that the fewer inversions an array has, the more sorted it is.\nThe reason why inversions are important to understanding the performance of insertion sort is that each iteration of the inner loop (i.e., step 2 of the insertion algorithm above) removes exactly one inversion. Consequently, if an array initially has $k$ inversions, the inner loop will iterate a total of $k$ times. If we combine this with the $n - 1$ iterations of the outer loop, we can conclude that the running time of insertion sort is in $O(n + k)$. Thus, if the number of inversions is relatively small in comparison to $n$ (i.e., the array is nearly sorted), insertion sort runs in $O(n)$ time. (By contrast, $n - 2$ inversions can be enough to cause the inner loop of bubble sort to iterate its worst-case number of times.) For this reason, insertion sort is the algorithm of choice when we expect the data to be nearly sorted \u0026mdash; a scenario that occurs frequently in practice. This fact is exploited by an efficient hybrid algorithm that combines insertion sort with two other sorting algorithms - see \u0026ldquo;Hybrid Sorts\u0026rdquo; for more details.\nBefore we consider another insert sort, there is one other advantage to insertion sort that we need to consider. Because the algorithm is simple (like selection sort and bubble sort), it performs well on small arrays. More complex algorithms like heap sort, while providing much better worst-case performance for larger arrays, don\u0026rsquo;t tend to perform as well on small arrays. In many cases, the performance difference on small arrays isn\u0026rsquo;t enough to matter, as pretty much any algorithm will perform reasonably well on a small array. However, this performance difference can become significant if we need to sort many small arrays (in a later section, we will see an application in which this scenario occurs). Because insertion sort tends to out-perform both selection sort and bubble sort, it is usually the best choice when sorting small arrays.\n Another way to implement an insert sort is to use a balanced binary search tree, such as an AVL tree, to store the sorted part. In order to do this, we need to modify the definition of a binary search tree to allow multiple instances of the same key. In order to achieve stability, if we are inserting a key that is equal to a key already in the tree, we would treat the new key as being greater than the pre-existing key - i.e., we would recursively insert it into the right child. Once all the data items are inserted, we would then copy them back into the array in sorted order using an inorder traversal. We call this algorithm tree sort.\nThis algorithm doesn\u0026rsquo;t exactly match the above description of an insert sort, but it is not hard to see that it follows the same general principles. While the sorted portion is not a part of the array, but instead is a separate data structure, it does hold an initial part of the array in sorted order, and successive elements from the unsorted portion are inserted into it.\nBecause insertions into an AVL tree containing $k$ elements can be done in $O(\\lg k)$ time in the worst case, and because an inorder traversal can be done in $O(k)$ time, it follows that tree sort runs in $O(n \\lg n)$ time in the worst case, where $n$ is the number of elements in the array. However, because maintaining an AVL tree requires more overhead than maintaining a binary heap, heap sort tends to give better performance in practice. For this reason, tree sort is rarely used.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/bst/intro/",
	"title": "Introduction to Binary Search Trees",
	"tags": [],
	"description": "",
	"content": "Introduction to Binary Search Trees In this section and the next, we will present a binary search tree as a data structure that can be used to implement a dictionary whose key type can be ordered. This implementation will provide efficient lookups, insertions, and deletions in most cases; however, there will be cases in which the performance is bad. In a later section, we will show how to extend this good performance to all cases.\nA binary search tree is a binary tree containing key-value pairs whose keys can be ordered. Furthermore, the data items are arranged such that the key in each node is:\n greater than all the keys in its left child; and less than all the keys in its right child.  Note that this implies that all keys must be unique. For example, the following is a binary search tree storing integer keys (only the keys are shown):\nThe hierarchical nature of this structure allows us to do something like a binary search to find a key. Suppose, for example, that we are looking for 41 in the above tree. We first compare 41 with the key in the root. Because 41 \u0026lt; 54, we can safely ignore the right child, as all keys there must be greater than 54. We therefore compare 41 to the key in the root of the left child. Because 41 \u0026gt; 23, we look in the right child, and compare 41 to 35. Because 41 \u0026gt; 35, we look in the right child, where we find the key we are looking for.\nNote the similarity of the search described above to a binary search. It isn\u0026rsquo;t exactly the same, because there is no guarantee that the root is the middle element in the tree \u0026mdash; in fact, it could be the first or the last. In many applications, however, when we build a binary search tree as we will describe below, the root of the tree tends to be roughly the middle element. When this is the case, looking up a key is very efficient. Later, we will show how we can build and maintain a binary search tree so that this is always the case.\nIt isn\u0026rsquo;t hard to implement the search strategy outlined above using a loop. However, in order to reinforce the concept of recursion as a tree processing technique, let\u0026rsquo;s consider how we would implement the search using recursion. The algorithm breaks into four cases:\n The tree is empty. In this case, the element we are looking for is not present. The key we are looking for is at the root - we have found what we are looking for. The key we are looking for is less than the key at the root. We then need to look for the given key in the left child. Because this is a smaller instance of our original problem, we can solve it using a recursive call. The key we are looking for is greater than the key at the root. We then look in the right child using a recursive call.  Warning\nIt is important to handle the case of an empty tree first, as the other cases don\u0026rsquo;t make sense if the tree is empty. In fact, if we are using null to represent an empty binary search tree (as is fairly common), we will get a NullReferenceException if we try to access the key at the root.\n If we need to compare elements using a CompareTo method, it would be more efficient to structure the code so that this method is only called once; e.g.,\n If the tree is empty . . . . Otherwise:  Get the result of the comparison. If the result is 0 . . . . Otherwise, if the result is negative . . . . Otherwise . . . .    This method would need to take two parameters \u0026mdash; the key we are looking for and the tree we are looking in. This second parameter will actually be a reference to a node, which will either be the root of the tree or null if the tree is empty. Because this method requires a parameter that is not provided to the TryGetValue method, this method would be a private method that the TryGetValue method can call. This private method would then return the node containing the key, or null if this key was not found. The TryGetValue method can be implemented easily using this private method.\nWe also need to be able to implement the Add method. Let\u0026rsquo;s first consider how to do this assuming we are representing our binary search tree with immutable nodes. The first thing to observe is that because we can\u0026rsquo;t modify an immutable node, we will need to build a binary search tree containing the nodes in the current tree, plus a new node containing the new key and value. In order to accomplish this, we will describe a private recursive method that returns the result of adding a given key and value to a given binary search tree. The Add method will then need to call this private method and save the resulting tree.\nWe therefore want to design a private method that will take three parameters:\n a binary search tree (i.e., reference to a node); the key we want to add; and the value we want to add.  It will return the binary search tree that results from adding the given key and value to the given tree.\nThis method again has four cases:\n The tree is empty. In this case, we need to construct a node containing the given key and value and two empty children, and return this node as the resulting tree. The root of the tree contains a key equal to the given key. In this case, we can\u0026rsquo;t add the item - we need to throw an exception. The given key is less than the key at the root. We can then use a recursive call to add the given key and value to the left child. The tree returned by the recursive call needs to be the left child of the result to be returned by the method. We therefore construct a new node containing the data and right child from the given tree, but having the result of the recursive call as its left child. We return this new node. The given key is greater than the key at the root. We use a recursive call to add it to the right child, and construct a new node with the result of the recursive call as its right child. We return this new node.  Note that the above algorithm only adds the given data item when it reaches an empty tree. Not only is this the most straightforward way to add items, but it also tends to keep paths in the tree short, as each insertion is only lengthening one path. This page contains an application that will show the result of adding a key at a time to a binary search tree.\nWarning\nThe keys in this application are treated as strings; hence, you can use numbers if you want, but they will be compared as strings (e.g., \u0026ldquo;10\u0026rdquo; \u0026lt; \u0026ldquo;5\u0026rdquo; because \u0026lsquo;1\u0026rsquo; \u0026lt; \u0026lsquo;5\u0026rsquo;). For this reason, it is usually better to use either letters, words, or integers that all have the same number of digits.\n The above algorithm can be implemented in the same way if mutable binary tree nodes are used; however, we can improve its performance a bit by avoiding the construction of new nodes when recursive calls are made. Instead, we can change the child to refer to the tree returned. If we make this optimization, the tree we return will be the same one that we were given in the cases that make recursive calls. However, we still need to construct a new node in the case in which the tree is empty. For this reason, it is still necessary to return the resulting tree, and we need to make sure that the Add method always uses the returned tree.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/leftist-heaps/",
	"title": "Leftist Heaps",
	"tags": [],
	"description": "",
	"content": "Leftist Heaps One efficient way to complete the merge algorithm outlined in the previous section revolves around the concept of the null path length of a tree, which is defined to be $0$ for empty trees, or one more than the minimum of the null path lengths of the children for nonempty trees. Another way to understand this concept is that it gives the minimum number of steps needed to get from the root to an empty subtree. For an empty tree, there is no root, so we somewhat arbitrarily define the null path length to be $0$. For single-node trees or binary trees with at least one empty child, the null path length is $1$ because only one step is needed to reach an empty subtree.\nOne reason that the null path length is important is that it can be shown that any binary tree with $n$ nodes has a null path length that is no more than $\\lg(n + 1)$. Furthermore, recall that in the merging strategy outlined in the previous section, there is some flexibility in choosing which child of a node will be used in the recursive call. Because the strategy reaches a base case when one of the min-heaps is empty, the algorithm will terminate the most quickly if we do the recursive call on the child leading us more quickly to an empty subtree \u0026mdash; i.e., if we use the child with smaller null path length. Because this length is logarithmic in the number of nodes in the min-heap, this choice will quickly lead us to the base case and termination.\nA common way of implementing this idea is to use what is known as a leftist heap. A leftist heap is a binary tree that forms a heap such that for every node, the null path length of the right child is no more than the null path length of the left child. For such a structure, completing the merge algorithm is simple:\n For the recursive call, we merge the right child of s with b, where s and b are as defined in the previous section. When combining the root and left child of s with the result of the recursive call, we arrange the children so that the result is a leftist heap.  We can implement this idea by defining two classes, LeftistTree\u0026lt;T\u0026gt; and MinPriorityQueue\u0026lt;TPriority, TValue\u0026gt;. For the LeftistTree\u0026lt;T\u0026gt; class, we will only be concerned with the shape of the tree \u0026mdash; namely, that the null path length of the right child is never more than the null path length of the left child. We will adopt a strategy similar to what we did with AVL trees. Specifically a LeftistTree\u0026lt;T\u0026gt; will be immutable so that we can always be sure that it is shaped properly. It will then be a straightforward matter to implement a MinPriorityQueue\u0026lt;TPriority, TValue\u0026gt;, where TPriority is the type of the priorities, and TValue is the type of the values.\nThe implementation of LeftistTree\u0026lt;T\u0026gt; ends up being very similar to the implementation we described for AVL tree nodes, but without the rotations. We need three public properties using the default implementation with get accessors: the data (of type T) and the two children (of type LeftistTree\u0026lt;T\u0026gt;). We also need a private field to store the null path length (of type int). We can define a static method to obtain the null path length of a given LeftistTree\u0026lt;T\u0026gt;. This method is essentially the same as the Height method for an AVL tree, except that if the given tree is null, we return 0. A constructor takes as its parameters a data element of type T and two children of type LeftistTree\u0026lt;T\u0026gt;. It can initialize its data with the first parameter. To initialize its children, it first needs to determine their null path lengths using the static method above. It then assigns the two LeftistTree\u0026lt;T\u0026gt; parameters to its child fields so that the right child\u0026rsquo;s null path length is no more than the left child\u0026rsquo;s. Finally, it can initialize its own null path length by adding 1 to its right child\u0026rsquo;s null path length.\n Let\u0026rsquo;s now consider how we can implement MinPriorityQueue\u0026lt;TPriority, TValue\u0026gt;. The first thing we need to consider is the type, TPriority. This needs to be a type that can be ordered (usually it will be a numeric type like int). We can restrict TPriority to be a subtype of IComparable\u0026lt;TPriority\u0026gt; by using a where clause, as we did for dictionaries (see \u0026ldquo;Implementing a Dictionary with a Linked List\u0026quot;).\nWe then need a private field in which to store a leftist tree. We can store both the priority and the data element in a node if we use a LeftistTree\u0026lt;KeyValuePair\u0026lt;TPriority, TValue\u0026gt;\u0026gt;; thus, the keys are the priorities and the values are the data elements. We also need a public int property to get of the number of elements in the min-priority queue. This property can use the default implementation with get and private set accessors.\nIn order to implement public methods to add an element with a priority and to remove an element with minimum priority, we need the following method:\nprivate static LeftistTree\u0026lt;KeyValuePair\u0026lt;TPriority, TValue\u0026gt;\u0026gt; Merge(LeftistTree\u0026lt;KeyValuePair\u0026lt;TPriority, TValue\u0026gt;\u0026gt; h1, LeftistTree\u0026lt;KeyValuePair\u0026lt;TPriority, TValue\u0026gt;\u0026gt; h2) { . . . } This method consist of three cases. The first two cases occur when either of the parameters is null. In each such case, we return the other parameter. In the third case, when neither parameter is null, we first need to compare the priorities in the data stored in the root nodes of the parameters. A priority is stored in the Key property of the KeyValuePair, and we have constrained this type so that it has a CompareTo method that will compare one instance with another. Once we have determined which root has a smaller priority, we can construct and return a new LeftistTree\u0026lt;KeyValuePair\u0026lt;TPriority, TValue\u0026gt;\u0026gt; whose data is the data element with smaller priority, and whose children are the left child of this data element and the result of recursively merging the right child of this element with the parameter whose root has larger priority.\nThe remaining methods and properties of MinPriorityQueue\u0026lt;TPriority, TValue\u0026gt; are now fairly straightforward.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/tries/multiple-impl/",
	"title": "Multiple Implementations of Children",
	"tags": [],
	"description": "",
	"content": "Multiple Implementations of Children The trie implementation given in the previous section offers very efficient lookups - a word of length $m$ can be looked up in $O(m)$ time, no matter how many words are in the trie. However, it wastes a large amount of space. In a typical trie, a majority of the nodes will have no more than one child; however, each node contains a 26-element array to store its children. Furthermore, each of these arrays is automatically initialized so that all its elements are null. This initialization takes time. Hence, building a trie may be rather inefficient as well.\nWe can implement a trie more efficiently if we can customize the implementation of a node based on the number of children it has. Because most of the nodes in a trie can be expected to have either no children or only one child, we can define alternate implementations for these special cases:\n For a node with no children, there is no need to represent any children - we only need the bool indicating whether the trie rooted at this node contains the empty string. For a node with exactly one child, we maintain a single reference to that one child. If we do this, however, we won\u0026rsquo;t be able to infer the child\u0026rsquo;s label from where we store the child; hence, we also need to have a char giving the child\u0026rsquo;s label. We also need the bool indicating whether the trie rooted at this node contains the empty string.  For all other nodes, we can use an implementation similar to the one outlined in the previous section. We will still waste some space with the nodes having more than one child but fewer than 26; however, the amount of space wasted will now be much less. Furthermore, in each of these three implementations, we can quickly access the child with a given label (or determine that there is no such child).\nConceptually, this sounds great, but we run into some obstacles as soon as we try to implement this approach. Because we are implementing nodes in three different ways, we need to define three different classes. Each of these classes defines a different type. So how do we build a trie from three different types of nodes? In particular, how do we define the type of a child when that child may be any of three different types?\nThe answer is to use a C# construct called an interface. An interface facilitates abstraction - hiding lower-level details in order to focus on higher-level details. At a high level (i.e., ignoring the specific implementations), these three different classes appear to be the same: they are all used to implement tries of words made up of lower-case English letters. More specifically, we want to be able to add a string to any of these classes, as well as to determine whether they contain a given string. An interface allows us to define a type that has this functionality, and to define various sub-types that have different implementations, but still have this functionality.\nA simple example of an interface is IComparable\u0026lt;T\u0026gt;. Recall from the section, “Implementing a Dictionary with a Linked List”, that we can constrain the keys in a dictionary implementation to be of a type that can be ordered by using a where clause on the class statement, as follows:\npublic class Dictionary\u0026lt;TKey, TValue\u0026gt; where TKey : IComparable\u0026lt;TKey\u0026gt; The source code for the IComparable\u0026lt;T\u0026gt; interface has been posted by Microsoft®. The essential part of this definition is:\npublic interface IComparable\u0026lt;in T\u0026gt; { int CompareTo(T other); } (Don\u0026rsquo;t worry about the in keyword with the type parameter in the first line.) This definition defines the type IComparable\u0026lt;T\u0026gt; as having a method CompareTo that takes a parameter of the generic type T and returns an int. Note that there is no public or private access modifier on the method definition. This is because access modifiers are disallowed within interfaces \u0026mdash; all definitions are implicitly public. Note also that there is no actual definition of the CompareTo method, but only a header followed by a semicolon. Definitions of method bodies are also disallowed within interfaces \u0026mdash; an interface doesn\u0026rsquo;t define the behavior of a method, but only how it should be used (i.e., its parameter list and return type). For this reason, it is impossible to construct an instance of an interface directly. Instead, one or more sub-types of the interface must be defined, and these sub-types must provide definitions for the behavior of CompareTo. As a result, because the Dictionary\u0026lt;TKey, TValue\u0026gt; class restricts type TKey to be a sub-type of IComparable\u0026lt;T\u0026gt;, its can use the CompareTo method of any instance of type TKey.\nNow suppose that we want to define a class Fraction and use it as a key in our dictionary implementation. We would begin the class definition within Visual Studio® as follows:\nAt the end of the first line of the class definition, : IComparable\u0026lt;Fraction\u0026gt; indicates that the class being defined is a subtype of IComparable\u0026lt;Fraction\u0026gt;. In general, we can list one or more interface names after the colon, separating these names with commas. Each name that we list requires that all of the methods, properties, and indexers from that interface must be fully defined within this class. If we hover the mouse over the word, IComparable\u0026lt;Fraction\u0026gt;, a drop-down menu appears. By selecting \u0026ldquo;Implement interface\u0026rdquo; from this menu, all of the required members of the interface are provided for us:\nNote\nIn order to implement a method specified in an interface, we must define it as public.\n We now just need to replace the throw with the proper code for the CompareTo method and fill in any other class members that we need; for example:\nusing System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Ksu.Cis300.Fractions { /// \u0026lt;summary\u0026gt;  /// An immutable fraction whose instances can be ordered.  /// \u0026lt;/summary\u0026gt;  public class Fraction : IComparable\u0026lt;Fraction\u0026gt; { /// \u0026lt;summary\u0026gt;  /// Gets the numerator.  /// \u0026lt;/summary\u0026gt;  public int Numerator { get; } /// \u0026lt;summary\u0026gt;  /// Gets the denominator.  /// \u0026lt;/summary\u0026gt;  public int Denominator { get; } /// \u0026lt;summary\u0026gt;  /// Constructs a new fraction with the given numerator and denominator.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;numerator\u0026#34;\u0026gt;The numerator.\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;denominator\u0026#34;\u0026gt;The denominator.\u0026lt;/param\u0026gt;  public Fraction(int numerator, int denominator) { if (denominator \u0026lt;= 0) { throw new ArgumentException(); } Numerator = numerator; Denominator = denominator; } /// \u0026lt;summary\u0026gt;  /// Compares this fraction with the given fraction.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;other\u0026#34;\u0026gt;The fraction to compare to.\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;A negative value if this fraction is less  /// than other, 0 if they are equal, or a positive value if this  /// fraction is greater than other.\u0026lt;/returns\u0026gt;  public int CompareTo(Fraction other) { long prod1 = (long)Numerator * other.Denominator; long prod2 = (long)other.Numerator * Denominator; return prod1.CompareTo(prod2); } // Other class members  } }  Note\nThe CompareTo method above is not recursive. The CompareTo method that it calls is a member of the long structure, not the Fraction class.\n As we suggested above, interfaces can also include properties. For example, ICollection\u0026lt;T\u0026gt; is a generic interface implemented by both arrays and the class List\u0026lt;T\u0026gt;. This interface contains the following member (among others):\nint Count { get; } This member specifies that every subclass must contain a property called Count with a getter. At first, it would appear that an array does not have such a property, as we cannot write something like:\nint[] a = new int[10]; int k = a.Count; // This gives a syntax error.  In fact, an array does contain a Count property, but this property is available only when the array is treated as an ICollection\u0026lt;T\u0026gt; (or an IList\u0026lt;T\u0026gt;, which is an interface that is a subtype of ICollection\u0026lt;T\u0026gt;, and is also implemented by arrays). For example, we can write:\nint[] a = new int[10]; ICollection\u0026lt;int\u0026gt; col = a; int k = col.Count; or\nint[] a = new int[10]; int k = ((ICollection\u0026lt;int\u0026gt;)a).Count; This behavior occurs because an array explicitly implements the Count property. We can do this as follows:\npublic class ExplicitImplementationExample\u0026lt;T\u0026gt; : ICollection\u0026lt;T\u0026gt; { int ICollection\u0026lt;T\u0026gt;.Count { get { // Code to return the proper value  } } // Other class members } Thus, if we create an instance of ExplicitImplementationExample\u0026lt;T\u0026gt;, we cannot access its Count property unless we either store it in a variable of type ICollection\u0026lt;T\u0026gt; or cast it to this type. Note that whereas the public access modifier is required when implementing an interface member, neither the public nor the private access modifier is allowed when explicitly implementing an interface member.\nWe can also include indexers within interfaces. For example, the IList\u0026lt;T\u0026gt; interface is defined as follows:\npublic interface IList\u0026lt;T\u0026gt; : ICollection\u0026lt;T\u0026gt; { T this[int index] { get; set; } int IndexOf(T item); void Insert(int index, T item); void RemoveAt(int index); } The : ICollection\u0026lt;T\u0026gt; at the end of the first line specifies that IList\u0026lt;T\u0026gt; is a subtype of ICollection\u0026lt;T\u0026gt;; thus, the interface includes all members of ICollection\u0026lt;T\u0026gt;, plus the ones listed. The first member listed above specifies an indexer with a get accessor and a set accessor.\nNow that we have seen a little of what interfaces are all about, let\u0026rsquo;s see how we can use them to provide three different implementations of trie nodes. We first need to define an interface, which we will call ITrie, specifying the two public members of our previous implementation of a trie node. We do, however, need to make one change to the way the Add method is called. This change is needed because when we add a string to a trie, we may need to change the implementation of the root node. We can\u0026rsquo;t simply change the type of an object - instead, we\u0026rsquo;ll need to construct a new instance of the appropriate implementation. Hence, the Add method will need to return the root of the resulting trie. Because this node may have any of the three implementations, the return type of this method should be ITrie. The ITrie interface is therefore as follows:\n/// \u0026lt;summary\u0026gt; /// An interface for a trie. /// \u0026lt;/summary\u0026gt; public interface ITrie { /// \u0026lt;summary\u0026gt;  /// Determines whether this trie contains the given string.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;The string to look for.\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;Whether this trie contains s.\u0026lt;/returns\u0026gt;  bool Contains(string s); /// \u0026lt;summary\u0026gt;  /// Adds the given string to this trie.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;s\u0026#34;\u0026gt;The string to add.\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;The resulting trie.\u0026lt;/returns\u0026gt;  ITrie Add(string s); } We will then need to define three classes, each of which implements the above interface. We will use the following names for these classes:\n TrieWithNoChildren will be used for nodes with no children. TrieWithOneChild will be used for nodes with exactly one child. TrieWithManyChildren will be used for all other nodes; this will be the class described in the previous section with a few modifications.  These three classes will be similar because they each will implement the ITrie interface. This implies that they will each need a Contains method and an Add method as specified by the interface definition. However, the code for each of these methods will be different, as will other aspects of the implementations. For example, the TrieWithNoChildren and TrieWithOneChild classes need private fields as described at the beginning of this section, whereas the TrieWithManyChildren classes needs the same private fields as outlined in the previous section. In each case, whenever we need to refer to a trie, we will use the type ITrie.\nThe Add methods for both TrieWithNoChildren and TrieWithOneChild will need to be able to construct instances of TrieWithOneChild and TrieWithManyChildren, respectively, when they have no room for the string being added. The instances they will need to construct will need information regarding the strings already being stored, plus the string being added; hence, we will need to define constructors for both TrieWithOneChild and TrieWithManyChildren. Each of these constructors will need to take the string being added as one of its parameters. Because the instance being constructed also needs to retain all of the information stored in the implementation that calls it, additional parameters for each of these constructors will correspond to the private fields of the implementation that will need to call it.\nThus, the parameters for the TrieWithOneChild constructor will be a string to be stored (i.e., the one being added) and a bool indicating whether the empty string is also to be stored (i.e., because it was stored in the original TrieWithNoChildren). Furthermore, because the empty string can always be added to a TrieWithNoChildren without constructing a new node, this constructor should never be passed the empty string. The constructor can then operate as follows:\n If the given string is empty or begins with a character that is not a lower-case English letter, throw an exception. Initialize the bool field with the given bool. Initialize the char field with the first character of the given string. Initialize the ITrie field with the result of constructing a new TrieWithNoChildren and adding to it the substring of the given string following the first character.  The parameters for the TrieWithManyChildren constructor will need to be a string to be stored (i.e., the one being added), a bool indicating whether the empty string is to be stored, a char giving the label of a child, and an ITrie giving a child (these last three parameters will come from the original TrieWithOneChild). It can use the last three parameters to initialize its bool field and one of its children (computing the child\u0026rsquo;s index as in the previous section). It can then use its own Add method to add the given string, as there will always be room to add a string to this implementation; hence, it can ignore the value returned by the Add method. Furthermore, because the Add method does error checking on the given string, the only error checking this constructor needs to do is on the given char, to verify that it is a lower-case English letter.\nThe Contains method for TrieWithManyChildren can be exactly the same as for the implementation in the previous section. For the other two classes, the structure of the method is similar. Specifically, the empty string needs to be handled first and in exactly the same way, as the empty string is represented in the same way in all three implementations. Nonempty strings, however, are represented differently, and hence need to be handled differently. This is easy for the TrieWithNoChildren class, as this implementation can\u0026rsquo;t store a nonempty string; hence, its Contains method should simply return false when the given string is nonempty. For TrieWithOneChild, we need to check to see if the first character of the given string matches the child\u0026rsquo;s label. If so, we can recursively look for the remainder of the string in that child. Otherwise, we should simply return false, as this string is not in this trie.\nThe Add method for TrieWithManyChildren needs some modification from the description given in the previous section. First, the method must return the resulting trie, which will always be this, as this implementation never needs to be replaced by another to accommodate a new string. The only other change that needs to be made is where a new child is constructed - this new child should be a TrieWithNoChildren.\nThe Add method for TrieWithNoChildren will need to handle the empty string in the same way as the above Add method. However, this implementation cannot store a nonempty string. In this case, it will need to construct and return a new TrieWithOneChild containing the string to be added and the bool stored in this node.\nThe Add method for TrieWithOneChild will need three cases:\n The empty string: This case can be handled in the same way as for the other two classes. A nonempty string whose first character matches the child\u0026rsquo;s label: The remainder of the string can be added to the child using the child\u0026rsquo;s Add method. Because this method may return a different node, we need to replace the child with the value this method returns. We can then return this, as we didn\u0026rsquo;t need more room for the given string. A nonempty string whose first character does not match the child\u0026rsquo;s label. In this case, we need to return a new TrieWithManyChildren containing the given string and all of the information already being stored.  Code that uses such a trie will need to refer to it as an ITrie whenever possible. The only exception to this rule occurs when we are constructing a new trie, as we cannot construct an instance of an interface. Here, we want to construct the simplest implementation \u0026mdash; a TrieWithNoChildren. Otherwise, the only difference in usage as compared to the implementation of the previous section is that the Add method now returns the resulting trie, whose root may be a different object; hence, we will need to be sure to replace the current trie with whatever the Add method returns.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/rehashing/",
	"title": "Rehashing",
	"tags": [],
	"description": "",
	"content": "Rehashing In this section, we will show how to improve the performance of a hash table by adjusting the size of the array. In order to see how the array size impacts the performance, let\u0026rsquo;s suppose we are using an array with $m$ locations, and that we are storing $n$ keys in the hash table. In what follows, we will analyze the number of keys we will need to examine while searching for a particular key, k.\nIn the worst case, no matter how large the array is, it is possible that all of the keys map to the same array location, and therefore all end up in one long linked list. In such a case, we will need to examine all of the keys whenever we are looking for the last one in this list. However, the worst case is too pessimistic \u0026mdash; if the hash function is implemented properly, it is reasonable to expect that something approaching a uniform random distribution will occur. We will therefore consider the number of keys we would expect to examine, assuming a uniform random distribution of keys throughout the table.\nWe\u0026rsquo;ll first consider the case in which k is not in the hash table. In this case, we will need to examine all of the keys in the linked list at the array location where k belongs. Because each of the $n$ keys is equally likely to map to each of the $m$ array locations, we would expect, on average, $n / m$ keys to be mapped to the location where k belongs. Hence, in this case, we would expect to examine $n / m$ keys, on average.\nNow let\u0026rsquo;s consider the case in which k is in the hash table. In this case, we will examine the key k, plus all the keys that precede k in its linked list. The number of keys preceding k cannot be more than the total number of keys other than k in that linked list. Again, because each of the $n - 1$ keys other than k is equally likely to map to each of the $m$ array locations, we would expect, on average, $(n - 1) / m$ keys other than k to be in the same linked list as k. Thus, we can expect, on average, to examine no more than $1 + (n - 1) / m$ keys when looking for a key that is present.\nNotice that both of the values derived above decrease as m increases. Specifically, if $m \\geq n$, the expected number of examined keys on a failed lookup is no more than $1$, and the expected number of examined keys on a successful lookup is less than $2$. We can therefore expect to achieve very good performance if we keep the number of array locations at least as large as the number of keys.\nWe have already seen (e.g., in \u0026ldquo;Implementation of StringBuilders\u0026quot;) how we can keep an array large enough by doubling its size whenever we need to. However, a hash table presents two unique challenges for this technique. First, as we observed in the previous section, we are most likely to get good performance from a hash table if the number of array locations is a prime number. However, doubling a prime number will never give us a prime number. The other challenge is due to the fact that when we change the size of the array, we consequently change the hash function, as the hash function uses the array size. As a result, the keys will need to go to different array locations in the new array.\nIn order to tackle the first challenge, recall that we presented an algorithm for finding all prime numbers less than a given n in \u0026ldquo;Finding Prime Numbers\u0026quot;; however, this is a rather expensive way to find a prime number of an appropriate size. While there are more efficient algorithms, we really don\u0026rsquo;t need one. Suppose we start with an array size of $5$ (there may be applications using many small hash tables \u0026mdash; the .NET implementation starts with an array size of $3$). $5$ is larger than $2^2 = 4$. If we double this value $28$ times, we reach a value larger than $2^{30}$, which is larger than $1$ billion. More importantly, this value is large enough that we can\u0026rsquo;t double it again, as an array in C# must contain fewer than $2^{31}$ locations. Hence, we need no more than $29$ different array sizes. We can pre-compute these and hard-code them into our implementation; for example,\nprivate int[] _tableSizes = { 5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717, 51437, 102877, 205759, 411527, 823117, 1646237, 3292489, 6584983, 13169977, 26339969, 52679969, 105359939, 210719881, 421439783, 842879579, 1685759167 }; Each of the values in the above array is a prime number, and each one after the first is slightly more than twice its predecessor. In order to make use of these values, we need a private field to store the index at which the current table size is stored in this array. We also need to keep track of the number of keys currently stored. As this information is useful to the user, a public int Count property would be appropriate. It can use the default implementation with a get accessor and a private set accessor.\nOne important difference between the reason for rehashing and the reason for creating a larger array for an implementation of a StringBuilder, stack, or queue is that rehashing is done simply for performance reasons - there is always room to put a new key and value into a hash table unless we have run out of memory. For this reason, it makes sense to handle rehashing after we have added the new key and value. This results in one extra linked-list insertion (i.e., updating two references) each time we rehash, but it simplifies the coding somewhat. Because rehashing is rarely done, this overhead is minimal, and seems to be a reasonable price to pay for simpler code.\nOnce a new key and value have been added, we first need to update the Count. We then need to check to see whether this number exceeds the current array size. As we do this, we should also make sure that the array size we are using is not the last array size in _tableSizes, because if it is, we can\u0026rsquo;t rehash. If both of these conditions hold, we need to rehash.\nTo begin rehashing, we copy the reference to the table into a local variable and increment the field giving our current index into _tableSizes. We then construct for the table field a new array whose size is given by the value at the new current index into _tableSizes. Note that it is important that the local variable is used to refer to the old table, and that the field is used to refer to the new table, as the hash function uses the field to obtain the array size.\nWe then need to move all keys and values from the old table to the new one. As we do this, we will need to re-compute the hash function for each key, as the hash function has now changed. We therefore need two nested loops. The outer loop iterates through the locations in the old table, and the inner loop iterates as long as the linked list at the current table location is non-empty. On each iteration of the inner loop:\n Use a local variable to save a reference to the first cell in the linked list at the current table location. Remove this cell from this linked list. Using the hash function, compute the new array location of the key in this cell. Insert this cell into the beginning of the linked list at the new array location in the new table.  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/graphs/dijkstra/",
	"title": "Shortest Paths",
	"tags": [],
	"description": "",
	"content": "Shortest Paths In this section, we will consider a common graph problem \u0026mdash; that of finding a shortest path from a node u to a node v in a directed graph. We will assume that each edge contains as its data a nonnegative number. This number may represent a physical distance or some other cost, but for simplicity, we will refer to this value as the length of the edge. We can then define the length of a path to be the sum of the lengths of all the edges along that path. A shortest path from u to v is then a path from u to v with minimum length. Thus, for example, the shortest path from a to h in the graph below is a-c-g-f-h, and its length is 4.8 + 6.4 + 4.9 + 3.2 = 19.3.\nThe biggest challenge in finding an algorithm for this problem is that the number of paths in a graph can be huge, even for relatively small graphs. For example, a directed graph with 15 nodes might contain over 10 billion paths from a node u to a node v. Clearly, an algorithm that simply checks all paths would be impractical for solving a problem such as finding the shortest route between two given locations in North America. In what follows, we will present a much more efficient algorithm due to Edsger W. Dijkstra.\nFirst, it helps to realize that when we are looking for a shortest path from u to v, we are likely to find other shortest paths along the way. Specifically, if node w is on the shortest path from u to v, then taking that same path but stopping at w gives us a shortest path from u to w. Returning to the above example, the shortest path from a to h also gives us shortest paths from a to each of the nodes c, g, and f. For this reason, we will generalize the problem to that of finding the shortest paths from a given node u to each of the nodes in the graph. This problem is known as the single-source shortest paths problem. This problem is a bit easier to think about because we can use shortest path information that we have already computed to find additional shortest path information. Then once we have an algorithm for this problem, we can easily modify it so that as soon as it finds the shortest path to our actual goal node v, we terminate it.\nDijkstra\u0026rsquo;s algorithm progresses by finding a shortest path to one node at a time. Let S denote the set of nodes to which it has found a shortest path. Initially, S will contain only u, as the shortest path from u to u is the empty path. At each step, it finds a shortest path that begins at u and ends at a node outside of S. Let\u0026rsquo;s call the last node in this path x. Certainly, if this path to x is the shortest to any node outside of S, it is also the shortest to x. The algorithm therefore adds x to S, and continues to the next step.\nWhat makes Dijkstra\u0026rsquo;s algorithm efficient is the way in which it finds each of the paths described above. Recall that each edge has a nonnegative length. Hence, once a given path reaches some node outside of S, we cannot make the path any shorter by extending it further. We therefore only need to consider paths that remain in S until the last edge, which goes from a node in S to a node outside of S. We will refer to such edges as eligible. We are therefore looking for a shortest path whose last edge is eligible.\nSuppose (w, x) is an eligible edge; i.e., w is in S, but x is not. Because w is in S, we know the length of the shortest path to w. The length of a shortest path ending in (w, x) is simply the length of the shortest path to w, plus the length of (w, x).\nLet us therefore assign to each eligible edge (w, x) a priority equal to the length of the shortest path to w, plus the length of (w, x). A shortest path ending in an eligible edge therefore has a length equal to the minimum priority of any eligible edge. Furthermore, if the eligible edge with minimum priority is (w, x), then the shortest path to x is the shortest path to w, followed by (w, x).\nWe can efficiently find an eligible edge with minimum priority if we store all eligible edges in a MinPriorityQueue\u0026lt;TEdgeData, Edge\u0026lt;TNode, TEdgeData\u0026gt;\u0026gt;. Note however, that when we include x in S as a result of removing (w, x) from the queue, it will cause any other eligible edges leading to x to become ineligible, as x will no longer be outside of S. Because removing these edges from the min-priority queue is difficult, we will simply leave them in the queue, and discard them whenever they have minimum priority. This min-priority queue will therefore contain all eligible edges, plus some edges whose endpoints are both in S.\nWe also need a data structure to keep track of the shortest paths we have found. A convenient way to do this is, for each node to which we have found a shortest path, to keep track of this node\u0026rsquo;s predecessor on this path. This will allow us to retrieve a shortest path to a node v by starting at v and tracing the path backwards using the predecessor of each node until we reach u. A Dictionary\u0026lt;TNode, TNode\u0026gt; is an ideal choice for this data structure. The keys in the dictionary will be the nodes in S, and the value associated with a key will be that key\u0026rsquo;s predecessor on a shortest path. For node u, which is in S but has no predecessor on its shortest path, we can associate a value of u itself.\nThe algorithm begins by adding the key u with the value u to a new dictionary. Because all of the outgoing edges from u are now eligible, it then places each of these edges into the min-priority queue. Because u is the source node of each of these edges, and the shortest path from u to u has length 0, the priority of each of these edges will simply be its length.\nOnce the above initialization is done, the algorithm enters a loop that iterates as long as the min-priority queue is nonempty. An iteration begins by obtaining the minimum priority p from the min-priority queue, then removing an edge (w, x) with minimum priority. If x is a key in the dictionary, we can ignore this edge and go on to the next iteration. Otherwise, we add to the dictionary the key x with a value of w. Because we now have a shortest path to x, there may be more eligible edges that we need to add to the min-priority queue. These edges will be edges from x that lead to nodes that are not keys in the dictionary; however, because the min-priority queue can contain edges to nodes that are already keys, we can simply add all outgoing edges from x. Because the length of the shortest path to x is p, the priority of each of these outgoing edges is p plus the length of the outgoing edge.\nNote that an edge is added to the min-priority queue only when its source is added as a key to the dictionary. Because we can only add a key once, each edge is added to the min-priority queue at most once. Because each iteration removes an edge from the min-priority queue, the min-priority queue must eventually become empty, causing the loop to terminate. When the min-priority queue becomes empty, there can be no eligible edges; hence, when the loop terminates, the algorithm has found a shortest path to every reachable node.\nWe can now modify the above algorithm so that it finds a shortest path from u to a given node v. Each time we add a new key to the dictionary, we check to see if this key is v; if so, we return the dictionary immediately. We might also want to return this path\u0026rsquo;s length, which is the priority of the edge leading to v. In this case, we could return the dictionary as an out parameter. Doing this would allow us to return a special value (e.g., a negative number) if we get through the loop without adding v, as this would indicate that v is unreachable. This modified algorithm is therefore as follows:\n Construct a new dictionary and a new min-priority queue. Add to the dictionary the key u with value u. If u = v, return 0. For each outgoing edge (u, w) from u:  Add (u, w) to the min-priority queue with a priority of the length of this edge.   While the min-priority queue is nonempty:  Get the minimum priority p from the min-priority queue. Remove an edge (w, x) with minimum priority from the min-priority queue. If x is not a key in the dictionary:  Add to the dictionary the key x with a value of w. If x = v, return p. For each outgoing edge (x, y) from x:  Add (x, y) to the min-priority queue with priority p plus the length of (x, y).       Return a negative value.  The above algorithm computes all of the path information we need, but we still need to extract from the dictionary the shortest path from u to v. Because the value for each key is that key\u0026rsquo;s predecessor, we can walk backward through this path, starting with v. To get the path in the proper order, we can push the nodes onto a stack; then we can remove them in the proper order. Thus, we can extract the shortest path as follows:\n Construct a new stack. Set the current node to v. While the current node is not u:  Push the current node onto the stack. Set the current node to its value in the dictionary.   Process u. While the stack is not empty:  Pop the top node from the stack and process it.    "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilders/",
	"title": "StringBuilders",
	"tags": [],
	"description": "",
	"content": "StringBuilders In the previous section, we saw that building large strings from small pieces by concatenating them together is very inefficient. This inefficiency is due to the fact that strings are immutable. In order to overcome the inefficiency of concatenation, we need an alternative data structure that we can modify. The StringBuilder class fills this need.\nLike strings, StringBuilders implement sequences of characters, but the contents of StringBuilders can be changed. The StringBuilder class has six constructors. The simplest StringBuilder constructor takes no parameters and constructs an empty StringBuilder \u0026mdash; i.e., a StringBuilder containing no characters:\nStringBuilder sb = new StringBuilder(); We can then modify a StringBuilder in various ways. First, we may append a char to the end using its Append method. This method not only changes the contents of the StringBuilder, but it also returns a reference to it. Thus if we have char variables, a, b, and c, and a StringBuilder variable sb, we can write code such as:\nsb.Append(a).Append(b).Append(c); The first call to Append appends the contents of a to sb, and returns sb. Thus, the second call to Append also applies to sb - it appends the contents of b. Likewise, the third call appends the contents of c.\nBecause this method changes a StringBuilder, rather than constructing a new one, its implementation is very efficient - in most cases, only the appended character needs to be copied (see \u0026ldquo;Implementation of StringBuilders\u0026rdquo; for details). This class has other Append methods as well, including one that appends the contents of a given string. This method likewise only needs to copy the appended characters.\nLet us now return to the problem of converting all lower-case letters in a string to upper-case, converting all upper-case letters to lower-case, and leaving all other characters unchanged. We can use a StringBuilder as an intermediate data structure to do this much more efficiently than the code presented in the previous section:\nStringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; text.Length; i++) { char c = text[i]; if (Char.IsLower(c)) { sb.Append(Char.ToUpper(c)); } else if (Char.IsUpper(c)) { sb.Append(Char.ToLower(c)); } else { sb.Append(c); } } string result = sb.ToString(); On most iterations, the above loop only copies one character. In addition, the call to the StringBuilder\u0026rsquo;s ToString method copies each character in the result. If text is 100,000 characters long, this is a total of 200,000 character copies. Using the StringBuilder implementation described in the next section, there are some iterations that copy more than one character, but even if we account for this, it turns out that fewer than 400,000 characters are copied, as opposed to over five billion character copies when strings are used directly (see the previous section). The StringBuilder implementation in the .NET Framework performs even better. In either case, the above code runs in O(n) time, where n is the length of text; i.e., as n gets large, the running time is at worst proportional to n. Thus, its performance degrades much less rapidly than the O(n2) code that uses strings directly.\nA program that runs the above code and the code given in the previous section on user-provided text files can be obtained by creating a Git repository (see “Git Repositories”) using this URL. A noticeable performance difference can be seen on text files larger than 100K - for example, the full text of Lewis Carroll’s Through the Looking Glass.\nStringBuilders have some features in common with strings. For example, we access individual characters in a StringBuilder by indexing; i.e., if sb is a StringBuilder variable, then sb[0] accesses its first character, sb[1] accesses its second character, etc. The main difference here is that with a StringBuilder, we may use indexing to change characters; e.g., we may do the following, provided sb contains at least 3 characters:\nsb[2] = \u0026#39;x\u0026#39;; A StringBuilder also has a Length property, which gets the number of characters contained. However, we may also set this property to any nonnegative value, provided there is enough memory available to provide this length. For example, we may write:\nsb.Length = 10; If the new length is shorter than the old, characters are removed from the end of the StringBuilder. If the new length is longer that the old, chars containing the Unicode NULL value (0 in decimal) are appended.\nWarning\nThe Unicode NULL value is different from a null reference. Because char is a value type, a char cannot store a null reference.\n StringBuilders have many other methods to allow various kinds of manipulation - see the documentation for the StringBuilder class for details. There is also a StringBuilder constructor that takes a string as its only parameter and constructs a StringBuilder containing the contents of that string.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/strings/",
	"title": "strings and StringBuilders",
	"tags": [],
	"description": "",
	"content": "strings and StringBuilders C# and the .NET Framework provides two data structures for representing sequences of characters - strings and StringBuilders. Each of these data structures has its own advantages and disadvantages. In this chapter, we will examine how these two types are used and implemented. In the process, we will note the tradeoffs involved in using one or the other.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/dialogs/",
	"title": "Dialogs",
	"tags": [],
	"description": "",
	"content": "Dialogs Dialogs are windows displayed by a program for the purpose of exchanging specific information with the user. There are two kinds of dialogs:\n Modal dialogs block all other interaction with the program until the dialog is closed. Non-modal dialogs allow the user to interact with the program in other ways while the dialog is open.  We will examine three classes provided by the Microsoft® .NET Framework, each of which implements a modal dialog. The .NET Framework provides various other classes, such as FolderBrowserDialog, FontDialog, and ColorDialog, that also implement specific kinds of dialogs. We conclude by discussing how custom dialogs may be built using Visual Studio®.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/dialogs/message-boxes/",
	"title": "MessageBoxes",
	"tags": [],
	"description": "",
	"content": "Message Boxes The MessageBox class (found in the System.Windows.Forms namespace) provides a simple mechanism for displaying a message and obtaining one of a few simple responses from the user. The most common usage of a MessageBox is to call one of its various Show methods, each of which is static. The simplest Show method takes a string as its only parameter. The method then displays this string in a modal dialog containing an \u0026ldquo;OK\u0026rdquo; button. Thus, for example,\nMessageBox.Show(\u0026#34;Hello world!\u0026#34;); will display the following dialog:\nBecause the dialog is modal, it will block all other interaction with the program until the user closes it by clicking either the \u0026ldquo;OK\u0026rdquo; button or the \u0026ldquo;X\u0026rdquo; in the upper right. Furthermore, the Show method will not return until that time.\nOther Show methods allow greater customization of a MessageBox. For example, one Show method takes as an additional parameter a second string giving a caption for the MessageBox. Thus, the statement,\nMessageBox.Show(\u0026#34;Hello world!\u0026#34;, \u0026#34;Hello\u0026#34;); will display the following modal dialog:\nOther Show methods allow the buttons to be customized. For example, one Show method takes, as its third parameter, an element from the MessageBoxButtons enumeration. This enumeration contains the following values:\n MessageBoxButtons.AbortRetryIgnore: Buttons labeled \u0026ldquo;Abort\u0026rdquo;, \u0026ldquo;Retry\u0026rdquo;, and \u0026ldquo;Ignore\u0026rdquo; are shown. MessageBoxButtons.OK: A single button labeled \u0026ldquo;OK\u0026rdquo; is shown. MessageBoxButtons.OKCancel: Buttons labeled \u0026ldquo;OK\u0026rdquo; and \u0026ldquo;Cancel\u0026rdquo; are shown. MessageBoxButtons.RetryCancel: Buttons labeled \u0026ldquo;Retry\u0026rdquo; and \u0026ldquo;Cancel\u0026rdquo; are shown. MessageBoxButtons.YesNo: Buttons labeled \u0026ldquo;Yes\u0026rdquo; and \u0026ldquo;No\u0026rdquo; are shown. MessageBoxButtons.YesNoCancel: Buttons labeled \u0026ldquo;Yes\u0026rdquo;, \u0026ldquo;No\u0026rdquo;, and \u0026ldquo;Cancel\u0026rdquo; are shown.  The values above containing the word, \u0026ldquo;Cancel\u0026rdquo;, cause the \u0026ldquo;X\u0026rdquo; in the upper-right of the dialog to be enabled. Clicking this button in these cases is equivalent to clicking the \u0026ldquo;Cancel\u0026rdquo; button. The value, MessageBoxButtons.OK, also enables this \u0026ldquo;X\u0026rdquo; button, but in this case, clicking this button is equivalent to clicking the \u0026ldquo;OK\u0026rdquo; button. Using a Show without a MessageBoxButtons parameter also gives this behavior. For all other MessageBoxButtons values, this \u0026ldquo;X\u0026rdquo; button is disabled.\nIn order to provide appropriate functionality to each of the buttons, each Show method returns a value of type DialogResult. This type is another enumeration containing the following values to indicate which button the user clicked:\n DialogResult.Abort DialogResult.Cancel DialogResult.Ignore DialogResult.No DialogResult.None (this value won\u0026rsquo;t be returned by any of the Show methods) DialogResult.OK DialogResult.Retry DialogResult.Yes  Suppose, for example, that we are writing a document formatter or some other application in which the user builds a document. If the user attempts to exit the program when the document is unsaved, we would like to give an opportunity to save the document. We can accomplish this with the following code:\nDialogResult result = MessageBox.Show(\u0026#34;The file is not saved. Really quit?\u0026#34;, \u0026#34;Confirm Quit\u0026#34;, MessageBoxButtons.YesNo); if (result == DialogResult.Yes) { Application.Exit(); } The first statement displays the following dialog:\nAgain, because the dialog is modal, the Show method does not return until the user closes the dialog by clicking one of the two buttons (the \u0026ldquo;X\u0026rdquo; in the upper right is disabled). When the user does this, the dialog closes, and the Show method returns either DialogResult.Yes or DialogResult.No to indicate which button the user clicked. If the user clicked the \u0026ldquo;Yes\u0026rdquo; button, then the if-statement will cause the program to terminate. Otherwise, the program will continue with whatever code follows (probably nothing more, as the program will need to await further user action).\nWe can also decorate a MessageBox with an icon that indicates what type of message it is. This requires another Show method having a fourth parameter of type MessageBoxIcon. MessageBoxIcon is another enumeration. Some of its values are:\n MessageBoxIcon.Error:  MessageBoxIcon.Information:  MessageBoxIcon.None (no icon) MessageBoxIcon.Warning:   This enumeration contains a few other values as well, but they currently are simply duplicate values for the above icons or values that Microsoft recommends against using. To add a warning icon to the above example, we could replace the first statement with:\nDialogResult result = MessageBox.Show(\u0026#34;The file is not saved. Really quit?\u0026#34;, \u0026#34;Confirm Quit\u0026#34;, MessageBoxButtons.YesNo, MessageBoxIcon.Warning); This will display the following dialog:\nNotice that in the above example, the \u0026ldquo;Yes\u0026rdquo; button has the focus; i.e., pressing \u0026ldquo;Enter\u0026rdquo; has the same effect as clicking this button. It is usually desirable to have the safest response as the default - in this case, the \u0026ldquo;No\u0026rdquo; button. To achieve this, a Show method having a fifth parameter, of type MessageBoxDefaultButton, is required. MessageBoxDefaultButton is another enumeration having the following values to select an appropriate button to be the default:\n MessageBoxDefaultButton.Button1 MessageBoxDefaultButton.Button2 MessageBoxDefaultButton.Button3  Thus, the following statement:\nDialogResult result = MessageBox.Show(\u0026#34;The file is not saved. Really quit?\u0026#34;, \u0026#34;Confirm Quit\u0026#34;, MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button2); produces a dialog similar to the one above, but having the \u0026ldquo;No\u0026rdquo; button as its default.\nThere are other Show methods that allow additional fine-tuning; however, the ones described here cover most of the functionality. For details on other Show methods, see the documentation for the MessageBox class.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/simple-text-file/",
	"title": "Simple Text File I/O",
	"tags": [],
	"description": "",
	"content": "Simple Text File I/O Many of the I/O tools provided by the .NET Framework are found in the System.IO namespace. Note, however, that Visual Studio® does not automatically provide a using directive for this namespace; hence, if you want to avoid the need to add the prefix System.IO. to each type that you use from this namespace, you should add a using directive for it. One class that provides several general-purpose static methods related to file I/O is the File class. Two of the static methods provided by this class are:\n File.ReadAllText and File.WriteAllText  The File.ReadAllText method takes a string as its only parameter. This string should give the path to a text file. It will then attempt to read that entire file and return its contents as a string. For example, if fileName refers to a string containing the path to a text file, then\nstring contents = File.ReadAllText(fileName); will read that entire file and place its contents into the string to which contents refers. We can then process the string contents however we need to.\nThe File.WriteAllText method takes two parameters:\n a string giving the path to a file; and a string giving the text to be written.  It will then attempt to write the given text as the entire contents of the given file. Thus, if fileName refers to a string containing the path to a file and contents refers to some string, then\nFile.WriteAllText(fileName, contents); will write to that file the string to which contents refers.\nWarning\nWhen calling either of these methods, there are a number things that can go wrong. For example, the file might be accessed through a network, and access to the network might be lost before the method can complete. When such an issue prevents the successful completion of one of these methods, an exception is thrown. In the next section, we will discuss how to handle such exceptions.\n While these methods are quite easy to use, they are not always the best ways of doing text file I/O. One drawback is that files can be quite large - perhaps too large to fit in memory or within a single string. Even when it is possible to read the entire file into a single string, it may use enough memory that performance suffers. In the section, “Advanced Text File I/O”, we will present other techniques for reading and writing text files.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/avl/",
	"title": "AVL Trees",
	"tags": [],
	"description": "",
	"content": "AVL Trees Up to this point, we haven\u0026rsquo;t addressed the performance of binary search trees. In considering this performance, let\u0026rsquo;s assume that the time needed to compare two keys is bounded by some fixed constant. The main reason we do this is that this cost doesn\u0026rsquo;t depend on the number of keys in the tree; however, it may depend on the sizes of the keys, as, for example, if keys are strings. However, we will ignore this complication for the purpose of this discussion.\nEach of the methods we have described for finding a key, adding a key and a value, or removing a key and its associated value, follows a single path in the given tree. As a result, the time needed for each of these methods is at worst proportional to the height of the tree, where the height is defined to be the length of the longest path from the root to any node. (Thus, the height of a one-node tree is $0$, because no steps are needed to get from the root to the only node - the root itself \u0026mdash; and the height of a two-node tree is always $1$.) In other words, we say that the worst-case running time of each of these methods is in $O(h)$, where $h$ is the height of the tree.\nDepending on the shape of the tree, $O(h)$ running time might be very good. For example, it is possible to show that if keys are randomly taken from a uniform distribution and successively added to an initially empty binary search tree, the expected height is in $O(\\log n)$, where $n$ is the number of nodes. In this case, we would expect logarithmic performance for lookups, insertions, and deletions. In fact, there are many applications in which the height of a binary search tree remains fairly small in comparison to the number of nodes.\nOn the other hand, such a shape is by no means guaranteed. For example, suppose a binary search tree were built by adding the int keys 1 through $n$ in increasing order. Then 1 would go at the root, and 2 would be its right child. Each successive key would then be larger than any key currently in the tree, and hence would be added as the right child of the last node on the path going to the right. As a result, the tree would have the following shape:\nThe height of this tree is $n - 1$; consequently, lookups will take time linear in $n$, the number of elements, in the worst case. This performance is comparable with that of a linked list. In order to guaranteed good performance, we need a way to ensure that the height of a binary search tree does not grow too quickly.\nOne way to accomplish this is to require that each node always has children that differ in height by at most $1$. In order for this restriction to make sense, we need to extend the definition of the height of a tree to apply to an empty tree. Because the height of a one-node tree is $0$, we will define the height of an empty tree to be $-1$. We call this restricted form of a binary search tree an AVL tree (\u0026ldquo;AVL\u0026rdquo; stands for the names of the inventors, Adelson-Velskii and Landis).\nThis page contains a Java applet/application that displays an AVL tree of a given height using as few nodes as possible. For example, the following screen capture shows an AVL tree of height $7$ having a minimum number of nodes:\nAs the above picture illustrates, a minimum of $54$ nodes are required for an AVL tree to reach a height of $7$. In general, it can be shown that the height of an AVL tree is at worst proportional to $\\log n$, where $n$ is the number of nodes in the tree. Thus, if we can maintain the shape of an AVL tree efficiently, we should have efficient lookups and updates.\nRegarding the AVL tree shown above, notice that the tree is not as well-balanced as it could be. For example, $0$ is at depth $7$, whereas $52$, which also has two empty children, is only at depth $4$. Furthermore, it is possible to arrange $54$ nodes into a binary tree with height as small as $5$. However, maintaining a more-balanced structure would likely require more work, and as a result, the overall performance might not be as good. As we will show in what follows, the balance criterion for an AVL tree can be maintained without a great deal of overhead.\nThe first thing we should consider is how we can efficiently determine the height of a binary tree. We don\u0026rsquo;t want to have to explore the entire tree to find the longest path from the root \u0026mdash; this would be way too expensive. Instead, we store the height of a tree as a private field in its root. If our nodes are mutable, we would also need to provide a public property to give read/write access to this field. However, such a setup places the burden of maintaining the heights on the user of the binary tree node class. Using immutable nodes allows a much cleaner (albeit slightly less efficient) solution. In what follows, we will show how to modify the definition of an immutable binary tree node so that whenever a binary tree is created from such nodes, the resulting tree is guaranteed to satisfy the AVL tree balance criterion. As a result, user code will be able to form AVL trees as if they were ordinary binary search trees.\nIn order to allow convenient and efficient access to the height, even for empty trees, we can provide a static method to take a binary tree node as its only parameter and return its height. Making this method static will allow us to handle empty (i.e., null) trees. If the tree is empty, this method will return $-1$; otherwise, it will return the height stored in the tree. This method can be public.\nWe then can modify the constructor so that it initializes the height field. Using the above method, it can find the heights of each child, and add $1$ to the maximum of these values. This is the height of the node being constructed. It can initialize the height field to this value, and because the nodes are immutable, this field will store the correct height from that point on.\nNow that we have a way to find the height of a tree efficiently, we can focus on how we maintain the balance property. Whenever an insertion or deletion would cause the balance property to be violated for a particular node, we perform a rotation at that node. Suppose, for example, that we have inserted an element into a node\u0026rsquo;s left child, and that this operation causes the height of the new left child to be two greater than the height of the right child (note that this same scenario could have occurred if we had removed an element from the right child). We can then rotate the tree using a single rotate right:\nThe tree on the left above represents the tree whose left child has a height $2$ greater than its right child. The root and the lines to its children are drawn using dashes to indicate that the root node has not yet been constructed \u0026mdash; we have at this point simply built a new left child, and the tree on the left shows the tree that would be formed if we were building an ordinary binary search tree. The circles in the picture indicate individual nodes, and the triangles indicate arbitrary trees (which may be empty). Note that the because the left child has a height $2$ greater than the right child, we know that the left child cannot be empty; hence, we can safely depict it as a node with two children. The labels are chosen to indicate the order of the elements \u0026mdash; e.g., as \u0026ldquo;a\u0026rdquo; $\\lt$ \u0026ldquo;b\u0026rdquo;, every key in tree a is less than the key in node b. The tree on the right shows that tree that would be built by performing this rotation. Note that the rotation preserves the order of the keys.\nSuppose the name of our class implementing a binary tree node is BinaryTreeNode\u0026lt;T\u0026gt;, and suppose it has the following properties:\n Data: gets the data stored in the node. LeftChild: gets the left child of the node. RightChild: gets the right child of the node.  Then the following code can be used to perform a single rotate right:\n/// \u0026lt;summary\u0026gt; /// Builds the result of performing a single rotate right on the binary tree /// described by the given root, left child, and right child. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;root\u0026#34;\u0026gt;The data stored in the root of the original tree.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;left\u0026#34;\u0026gt;The left child of the root of the original tree.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;right\u0026#34;\u0026gt;The right child of the root of the original tree.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The result of performing a single rotate right on the tree described /// by the parameters.\u0026lt;/returns\u0026gt; private static BinaryTreeNode\u0026lt;T\u0026gt; SingleRotateRight(T root, BinaryTreeNode\u0026lt;T\u0026gt; left, BinaryTreeNode\u0026lt;T\u0026gt; right) { BinaryTreeNode\u0026lt;T\u0026gt; newRight = new BinaryTreeNode\u0026lt;T\u0026gt;(root, left.RightChild, right); return new BinaryTreeNode\u0026lt;T\u0026gt;(left.Data, left.LeftChild, newRight); } Relating this code to the tree on the left in the picture above, the parameter root refers to d, the parameter left refers to the tree rooted at b, and the parameter right refers to the tree e. The code first constructs the right child of the tree on the right and places it in the variable newRight. It then constructs the entire tree on the right and returns it.\nWarning\nDon\u0026rsquo;t try to write the code for doing rotations without looking at pictures of the rotations.\n Now that we have seen what a single rotate right does and how to code it, we need to consider whether it fixes the problem. Recall that we were assuming that the given left child (i.e., the tree rooted at b in the tree on the left above) has a height $2$ greater than the given right child (i.e., the tree e in the tree on the left above). Let\u0026rsquo;s suppose the tree e has height $h$. Then the tree rooted at b has height $h + 2$. By the definition of the height of a tree, either a or c (or both) must have height $h + 1$. Assuming that every tree we\u0026rsquo;ve built so far is an AVL tree, the children of b must differ in height by at most $2$; hence, a and c must both have a height of at least $h$ and at most $h + 1$.\nGiven these heights, let\u0026rsquo;s examine the tree on the right. We have assumed that every tree we\u0026rsquo;ve built up to this point is an AVL tree, so we don\u0026rsquo;t need to worry about any balances within a, c, or e. Because c has either height $h$ or height $h + 1$ and e has height $h$, the tree rooted at d satisfies the balance criterion. However, if c has height $h + 1$ and a has height $h$, then the tree rooted at d has height $h + 2$, and the balance criterion is not satisfied. On the other hand, if a has height $h + 1$, the tree rooted at d will have a height of either $h + 1$ or $h + 2$, depending on the height of c. In these cases, the balance criterion is satisfied.\nWe therefore conclude that a single rotate right will restore the balance if:\n The height of the original left child (i.e., the tree rooted at b in the above figure) is $2$ greater than the height of the original right child (tree e in the above figure); and The height of the left child of the original left child (tree a in the above figure) is greater than the height of the original right child (tree e).  For the case in which the height of the left child of the original left child (tree a) is not greater than the height of the original right child (tree e), we will need to use a different kind of rotation.\nBefore we consider the other kind of rotation, we can observe that if an insertion or deletion leaves the right child with a height $2$ greater than the left child and the right child of the right child with a height greater than the left child, the mirror image of a single rotate right will restore the balance. This rotation is called a single rotate left:\nReturning to the case in which the left child has a height $2$ greater than the right child, but the left child of the left child has a height no greater than the right child, we can in this case do a double rotate right:\nNote that we have drawn the trees a bit differently by showing more detail. Let\u0026rsquo;s now show that this rotation restores the balance in this case. Suppose that in the tree on the left, g has height $h$. Then the tree rooted at b has height $h + 2$. Because the height of a is no greater than the height of g, assuming all trees we have built so far are AVL trees, a must have height $h$, and the tree rooted at d must have height $h + 1$ (thus, it makes sense to draw it as having a root node). This means that c and e both must have heights of either $h$ or $h - 1$. It is now not hard to verify that the balance criterion is satisfied at b, f, and d in the tree on the right.\nThe only remaining case is the mirror image of the above \u0026mdash; i.e., that the right child has height $2$ greater than the left child, but the height of the right child of the right child is no greater than the height of the left child. In this case, a double rotate left can be applied:\nWe have shown how to restore the balance whenever the balance criterion is violated. Now we just need to put it all together in a public static method that will replace the constructor as far as user code is concerned. In order to prevent the user from calling the constructor directly, we also need to make the constructor private. We want this static method to take the same parameters as the constructor:\n The data item that can be stored at the root, provided no rotation is required. The tree that can be used as the left child if no rotation is required. The tree that can be used as the right child if no rotation is required.  The purpose of this method is to build a tree including all the given nodes, with the given data item following all nodes in the left child and preceding all nodes in the right child, but satisfying the AVL tree balance criterion. Because this method will be the only way for user code to build a tree, we can assume that both of the given trees satisfy the AVL balance criterion. Suppose that the name of the static method to get the height of a tree is Height, and that the names of the methods to do the remaining rotations are SingleRotateLeft, DoubleRotateRight, and DoubleRotateLeft, respectively. Further suppose that the parameter lists for each of these last three methods are the same as for SingleRotateRight above. The following method can then be used to build AVL trees:\n/// \u0026lt;summary\u0026gt; /// Constructs an AVL Tree from the given data element and trees. The heights of /// the trees must differ by at most two. The tree built will have the same /// inorder traversal order as if the data were at the root, left were the left /// child, and right were the right child. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;A data item to be stored in the tree.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;left\u0026#34;\u0026gt;An AVL Tree containing elements less than data.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;right\u0026#34;\u0026gt;An AVL Tree containing elements greater than data. /// \u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The AVL Tree constructed.\u0026lt;/returns\u0026gt; public static BinaryTreeNode\u0026lt;T\u0026gt; GetAvlTree(T data, BinaryTreeNode\u0026lt;T\u0026gt; left, BinaryTreeNode\u0026lt;T\u0026gt; right) { int diff = Height(left) - Height(right); if (Math.Abs(diff) \u0026gt; 2) { throw new ArgumentException(); } else if (diff == 2) { if (Height(left.LeftChild) \u0026gt; Height(right)) { return SingleRotateRight(data, left, right); } else { return DoubleRotateRight(data, left, right); } } else if (diff == -2) { if (Height(right.RightChild) \u0026gt; Height(left)) { return SingleRotateLeft(data, left, right); } else { return DoubleRotateLeft(data, left, right); } } else { return new BinaryTreeNode\u0026lt;T\u0026gt;(data, left, right); } } In order to build and maintain an AVL tree, user code simply needs to call the above wherever it would have invoked the BinaryTreeNode\u0026lt;T\u0026gt; constructor in building and maintaining an ordinary binary search tree. The extra overhead is fairly minimal \u0026mdash; each time a new node is constructed, we need to check a few heights (which are stored in fields), and if a rotation is needed, construct one or two extra nodes. As a result, because the height of an AVL tree is guaranteed to be logarithmic in the number of nodes, the worst-case running times of both lookups and updates are in $O(\\log n)$, where $n$ is the number of nodes in the tree.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/exceptions/",
	"title": "Exception Handling",
	"tags": [],
	"description": "",
	"content": "Exception Handling As was mentioned in the previous section, various problems can occur when doing file I/O. Some of these problems include:\n Trying to write to a read-only file. Trying to access a file that is locked by another process. Accessing an external drive that becomes disconnected.  Note that some of these issues are beyond the programmer\u0026rsquo;s control, while others may be tedious for the programmer to check. When one of these problems prevents an I/O operation from completing successfully, an exception is thrown. This section discusses how to handle such exceptions gracefully, without terminating the program.\nTip\nFile dialogs can be quite helpful in avoiding some of these exceptions, as they can reject improper selections by the user.\n The mechanism used to handle exceptions is the try-catch construct. In its simplest form, it looks like:\ntry { // Block of code that might throw an exception  } catch { // Code to handle the exception  } If we are concerned about exceptions thrown while doing I/O, we would include the I/O and anything dependent on it within the try-block. If at any point within this block an exception is thrown, control immediately jumps to the catch-block. Here, we would place code to handle the exception - for example, displaying a message to the user.\nSuppose, for example, that we want to count the number of upper-case letters in a file whose name is in the string referenced by fileName. We could use the following code:\ntry { string contents = File.ReadAllText(fileName); int count = 0; foreach (char c in contents) { if (Char.IsUpper(c)) { count++; } } MessageBox.Show(\u0026#34;The file contains \u0026#34; + count + \u0026#34; upper-case letters.\u0026#34;); } catch { MessageBox.Show(\u0026#34;An exception occurred.\u0026#34;); }  Note\nSee the section, \u0026ldquo;The foreach Statement\u0026rdquo; for an explanation of foreach loops. The Char.IsUpper method returns a bool indicating whether the given char is an upper-case letter in some alphabet.\n We should always include within the try-block all of the code that depends on what we want to read. Consider what would happen, for example, if we tried to move the statement,\nMessageBox.Show(\u0026#34;The file contains \u0026#34; + count + \u0026#34; upper-case letters.\u0026#34;); outside the try-catch. First, we would have a syntax error because the variable count is declared with the try-block, and hence cannot be used outside of it. We could fix this error by declaring and initializing count prior to the try statement. The resulting code would compile and run, but consider what happens if an exception is thrown during the reading of the file. Control immediately jumps to the catch-block, where the message, \u0026ldquo;An exception occurred.\u0026rdquo;, is displayed. After that, assuming we have made these changes to the above code, control continues on past the catch-block to the code to display the results. Because the file was not successfully read, it really doesn\u0026rsquo;t make any sense to do this. The code given above, however, displays a result only if the result is successfully computed; otherwise, the exception message is displayed.\nIn the above example, the message, \u0026ldquo;An exception occurred.\u0026rdquo;, isn\u0026rsquo;t very helpful to the user. It gives no indication of what the problem is. In order to be able to provide more information to the user, we need more information regarding the nature of the exception. The way we do this is to use some additional code on the catch statement:\ncatch (Exception ex) The word Exception above is a type. Every exception in C# is a subtype of the Exception class. In this form of the catch statement, we can include any subtype of Exception, including Exception itself, as the first word within the parentheses. The second word is a new variable name. One effect of this parenthesized part is to declare this variable to be of the given type; i.e., ex is of type Exception, and may be used within the catch block.\nThis form of the catch statement will catch any exception that can be treated as the given type. If we use the type, Exception, as above, the catch-block will still catch any exception. In addition, the variable defined within the parentheses will refer to that exception. Thus, the parenthesized part of this statement behaves much like a parameter list, giving us access to the exception that was thrown. Having the exception available to examine, we can now give more meaningful feedback to the user. One rather crude way of doing this is to use the exception\u0026rsquo;s ToString method to convert it to a string representation, which can then be displayed to the user; for example,\ncatch (Exception ex) { MessageBox.Show(ex.ToString()); } Replacing the catch-block in the earler example with this catch-block might result in the following message:\nWhile this message is not something we would want to show to an end user, it does provide helpful debugging information, such as the exception thrown and the line that threw the exception.\nTip\nEvery object in C# has a ToString method. Hence, we can convert an instance of any type to string by using its ToString method. This method will always return a string, but depending on the original type, this string may or may not be useful. For example, because there is no particularly meaningful way to convert a Form to a string, its ToString method is not especially useful.\n A single try-block can have more than one catch-block. In such a case, whenever an exception occurs within the try-block, control is transferred to the first catch-block that can catch that particular exception. For example, we can set up the following construct:\ntry { // Code that may throw an exception  } catch (DirectoryNotFoundException ex) { // Code to handle a DirectoryNotFoundException  } catch (FileNotFoundException ex) { // Code to handle a FileNotFoundException  } catch (Exception ex) { // Code to handle any other exception  } If we don\u0026rsquo;t need access to the exception itself in order to handle it, but only need to know what kind of exception it is, we can leave off the variable name in the catch statement. For example, if we are trying to read from a file whose name is referenced by the string fileName, we might handle a FileNotFoundException as follows:\ncatch (FileNotFoundException) { MessageBox.Show(\u0026#34;Could not find the file \u0026#34; + fileName); }  Warning\nDon\u0026rsquo;t use exception handling (i.e., try-catch) to handle cases that are expected to occur under normal conditions. In such cases, use an if-statement instead. Not only is this better style, but it is also more efficient.\n "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/dialogs/file-dialogs/",
	"title": "File Dialogs",
	"tags": [],
	"description": "",
	"content": "File Dialogs The System.Windows.Forms namespace contains two other classes that implement modal dialogs for obtaining file names from the user. These classes are OpenFileDialog, which is designed to obtain the name of a file to read, and SaveFileDialog, which is designed to obtain the name of a file to write. Because we often need to obtain the name of a file prior to doing file I/O, it is appropriate to consider these classes now.\nAlthough these dialogs are visually separate from the window from which they are opened, it is possible (and usually desirable) to add instances of these classes to a form from the Design window. Both can be found in the \u0026ldquo;Dialogs\u0026rdquo; section of the Toolbox. They can be added to the form simply by double-clicking on their names. They will not appear on the form itself, but in a separate area of the Design window. Their properties can then be modified in the same way as any other control. We will discuss some of these properties a bit later in what follows.\nEach of these classes has a method called ShowDialog that takes no parameters. For example, if we call the ShowDialog method of an OpenFileDialog, a dialog resembling the following will be opened:\nSimilarly, calling the ShowDialog method of a SaveFileDialog opens a dialog resembling the following:\nBecause these dialogs are modal, the method call will not return until the user closes the dialog. It will then return a DialogResult indicating how the user closed the form - either DialogResult.OK or DialogResult.Cancel (see the previous section for more information on the DialogResult type). Therefore, if uxFileDialog is a variable referring to a file dialog, we typically use the following code template to display it:\nif (uxFileDialog.ShowDialog() == DialogResult.OK) { // Process the file } Thus, if the user selects a file, we process it; otherwise, we do nothing. In some cases, we might include an else containing code that needs to be executed if the user closes the dialog without selecting a file.\nProcessing a file will be discussed in the three sections that follow. However, one thing we will certainly want to do prior to processing the file is to obtain the file name that the user selected (after all, this is the reason we display a file dialog). We can obtain this file name via the dialog\u0026rsquo;s FileName property; for example,\nstring fileName = uxFileDialog.FileName; Note that this and other properties are accessible for initialization purposes through a file dialog\u0026rsquo;s Properties window in the Designer. This is useful for an OpenFileDialog\u0026rsquo;s FileName property, as the default supplied by Visual Studio® is rather odd. Other properties that we might want to initialize here (in addition to (Name), the name of the variable referring to the dialog) include:\n  Title, the title of the dialog (by default, \u0026ldquo;Open\u0026rdquo; for an OpenFileDialog or \u0026ldquo;Save As\u0026rdquo; for a SaveFileDialog).\n  Filter, a filter string, which controls what file types will be displayed. An example of a filter string is: C# files|*.cs|All files|*.*. A filter string consists of an even number of components separated by vertical bars (\u0026quot;|\u0026quot;). Thus, the above filter string consists of four components. These components are grouped into pairs. The first component of each pair gives the string that will be displayed in the dialog to describe what files are displayed. The second component of each pair describes a pattern of file names to be displayed when the first component of that pair is shown. Use an asterisk (\u0026quot;*\u0026quot;) in a pattern to denote any sequence of characters. The \u0026ldquo;.\u0026rdquo; in a pattern ending in \u0026ldquo;.*\u0026rdquo; does not need to be matched - a file without an extension will be listed if it matches the pattern to the left of the \u0026ldquo;.\u0026rdquo;. Multiple patterns, separated by semicolons (\u0026quot;;\u0026quot;), may be listed in one component. Thus, the above filter string describes two filters that the user may choose from. The first filter is labeled, \u0026ldquo;C# files\u0026rdquo;, and lists all files ending in \u0026ldquo;.cs\u0026rdquo;. The second filter is labeled \u0026ldquo;All files\u0026rdquo;, and lists all files.\n  FilterIndex indicates which pair in the filter string is currently being used. Note that the first pair has an index of 1, not 0.\n  AddExtension and DefaultExt control the dialog\u0026rsquo;s behavior when the user types in a file name without an extension. When this happens, if a filter with a unique extension is chosen, that extension will be appended, regardless of the values of these two properties. Otherwise, if AddExtension is True, the value of DefaultExt will be appended, following a \u0026ldquo;.\u0026rdquo;.\n  Other properties allow further customization of file dialogs. For more details, see the OpenFileDialog and SaveFileDialog documentation.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/linked-lists/sieve-eratosthenes/",
	"title": "Finding Prime Numbers",
	"tags": [],
	"description": "",
	"content": "Finding Prime Numbers An integer greater than $1$ is said to be prime if it is not divisible by any positive integers other than itself and $1$. Thus, $2$, $3$, and $5$ are prime, but not $1$ (it is not greater than $1$) or $4$ (it is divisible by $2$). Because every integer is divisible by itself and $1$, we will call any other positive factors nontrivial factors; thus, a prime number is an integer greater than $1$ that has no nontrivial factors. The study of prime numbers dates back to at least the third century BC. One of the earliest known algorithms finds all prime numbers less than a given integer $n$. This algorithm is known as the Sieve of Eratosthenes, and is attributed to the Greek mathematician Eratosthenes of Cyrene (c. 276 BC - c. 194 BC).\nThe most basic version of this algorithm operates as follows:\n Place all integers greater than $1$ and less than $n$ in order in a list. For each element $k$ in the list, remove all subsequent elements that are divisible by $k$. The remaining values are the prime numbers less than $n$.  For example, suppose $n = 20$. We then place the integers from $2$ to $19$ in a list: $$ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 9\\ 10\\ 11\\ 12\\ 13\\ 14\\ 15\\ 16\\ 17\\ 18\\ 19 $$ We then remove all numbers following $2$ that are divisible by $2$: $$ \\require{cancel} 2\\ 3\\ \\cancel{4}\\ 5\\ \\cancel{6}\\ 7\\ \\cancel{8}\\ 9\\ \\cancel{10}\\ 11\n\\cancel{12}\\ 13\\ \\cancel{14}\\ 15\\ \\cancel{16}\\ 17\\ \\cancel{18}\\ 19 $$ We then remove all numbers following $3$ that are divisible by $3$: $$ 2\\ 3\\ \\cancel{4}\\ 5\\ \\cancel{6}\\ 7\\ \\cancel{8}\\ \\cancel{9}\\ \\cancel{10}\\ 11\n\\cancel{12}\\ 13\\ \\cancel{14}\\ \\cancel{15}\\ \\cancel{16}\\ 17\\ \\cancel{18}\\ 19 $$ The algorithm continues, but none of the succeeding iterations finds any values to remove. Therefore, $2, 3, 5, 7, 11, 13, 17$, and $19$ are the prime numbers less than $20$.\nTo see why this algorithm gives us exactly the prime numbers less than $n$, first note that because we only remove a number when we find a nontrivial factor, we only remove non-primes from the list. What may be a little less obvious is that we remove all non-primes from the list. To see this, suppose $m$ is a non-prime less than $n$, and let $a$ be its smallest nontrivial factor. Then $a$ must be prime because any nontrivial factor of $a$ would be less than $a$ and would also divide $m$. $a$ therefore will not be removed from the list. When $k = a$ in Step 2, $m$ will be removed.\nThere is actually a good reason why the first two iterations in the above example removed all of the non-primes \u0026mdash; once the algorithm reaches a divisor $k$ such that $k^2 \\geq n$ (in this example, $5^2 = 25 \\geq 20$), all of the non-primes will have been removed. To see why this is true, let $m$ and $a$ be as above. We can then write $$ m = ab $$ where $a \\leq b$, and $m$ is removed from the list when $k = a$. We can then multiply both sides of the above equation by $a/b$, yielding: $$ \\frac{am}{b} = a^2. $$ Finally, because $a \\leq b$, $a/b \\leq 1$. Therefore, $$ m \\geq a^2. $$ We conclude that if $m$ is a non-prime greater than $1$, it is removed when the algorithm reaches some value $k$ with $k^2 \u0026lt; n$. We can therefore optimize the algorithm by stopping when $k^2 \\geq n$.\nWe can implement this algorithm using a linked list. A linked list is an appropriate data structure for this algorithm because once the list is built, all of the processing involves iterating through it from beginning to end \u0026mdash; the same direction the links go.\nTo implement Step 1, it is easier to build the list from back to front, as we don\u0026rsquo;t need to maintain a separate reference to the end of the list. This step then consists of a loop that iterates from $n - 1$ down to $2$, with each iteration adding to the front of the list a cell containing the loop index.\nIn order to be able to implement Step 2, we will need to know how to remove a cell from a linked list. Suppose, for example, that we want to remove the cell referring to \u0026ldquo;the\u0026rdquo; from the following linked list:\nTo remove it, we need the cell that precedes it to be followed by the cell that follows it:\nIn order to change that reference, we need a reference to the cell that precedes the cell we want to remove:\nWe can then remove the cell following the cell referenced by q as follows:\nq.Next = q.Next.Next; Now that we know how to remove a cell from a linked list, let\u0026rsquo;s consider Step 2 of the algorithm. For one value of $k$, we need to remove all subsequent values that are divisible by $k$. In terms of the linked list, we need to start this process with the cell containing $k$. For example, consider the second iteration from the example above \u0026mdash; i.e., when $k = 3$:\nWe need to iterate p through the linked list, checking the next cell on each iteration to see whether its contents are divisible by $k$. We can check for divisibility by $k$ using the remainder operator \u0026mdash; i.e., $k$ divides $m$ if $m \\mathbin{\\texttt{%}} k$ is 0. Thus, the first iteration would see if $3$ divides $5$. It doesn\u0026rsquo;t, so we advance p to the next cell (containing $5$). We then see if $3$ divides $7$. Again it doesn\u0026rsquo;t, so we advance p to the next cell (containing $7$). At this point, $3$ divides $9$, so we remove the cell containing $9$ as shown above. This gives us the following linked list:\nNote that we have not yet advanced p, and indeed we don\u0026rsquo;t want to, as $11$ is the next value we want to check. Thus, on each iteration, if $k$ divides the value in the cell following p, we remove that cell; otherwise, we advance p to that cell. We iterate this loop as long as there is a cell following p.\nThe loop described above represents a single iteration of the loop described for Step 2. Thus, for Step 2, we need to iterate a variable through the list, performing the above on each iteration. We stop when we either have run off the end of the list or have reached a value of $k$ such that $k^2 \\geq n$. Note that at the end of each iteration, we want to advance to the next cell.\nWarning\nMake sure when iterating through a linked list that you keep a reference to the beginning of the list. Otherwise, you will lose all of your list.\n "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/strings/stringbuilder-impl/",
	"title": "Implementation of StringBuilders",
	"tags": [],
	"description": "",
	"content": "Implementation of StringBuilders In this section, we will examine some of the implementation details of the StringBuilder class. There are several reasons for doing this. First, by examining these details, we can begin to understand why a StringBuilder is so much more efficient than a string when it comes to building long strings a character at a time. Second, by studying implementations of data structures, we can learn techniques that might be useful to us if we need to build our own data structures. Finally, a computing professional who better understands the underlying software will be better equipped to use that software effectively.\nIn what follows, we will develop an implementation of a simplified StringBuilder class. Specifically, we will only implement enough to support the program that flips the case of all characters in a string (see the previous section). Most other features of a StringBuilder have a rather straightforward implementation once the basics are done (we will show how to implement an indexer in a later section).\nNote\nThe implementation described here is much simpler than the actual implementation in the .NET Framework. Their implementation achieves even better performance.\n In order to illustrate more clearly the techniques used to implement a StringBuilder, we will present an implementation that uses only those types provided by the C# core language, rather than those found in a library such as the .NET Framework. One of the more useful data structures that the C# core language provides for building more advanced data structures is the array. We can represent the characters in a StringBuilder using a char[ ]. One difficulty in using an array, however, is that we don\u0026rsquo;t know how many characters our StringBuilder might need. We will return to this issue shortly, but for now, let\u0026rsquo;s just arbitrarily pick a size for our array, and define:\n/// \u0026lt;summary\u0026gt; /// The characters in this StringBuilder. /// \u0026lt;/summary\u0026gt; private char[] _characters = new char[100]; An array with 100 elements will give us room enough to store up to 100 characters. In fact, initializing the array in this way actually gives us 100 characters, as each array element is initialized to a Unicode NULL character (a char with a decimal value of 0). Because char is a value type, each array element is going to store a char - it\u0026rsquo;s just a question of which char it is going to store. Therefore, if we want to be able to represent a sequence of fewer than 100 characters, we need an additional field to keep track of how many characters of the array actually represent characters in the StringBuilder. We therefore define:\n/// \u0026lt;summary\u0026gt; /// The number of characters in this StringBuilder. /// \u0026lt;/summary\u0026gt; private int _length = 0; Thus, for example, if _length is 25, the first 25 characters in _characters will be the characters in the StringBuilder.\nBecause both fields have initializers, the default constructor will initialize them both; hence, we don\u0026rsquo;t need to write a constructor. Let\u0026rsquo;s focus instead on the Append method. This method needs to take a char as its only parameter and return a StringBuilder (itself). Its effect needs to be to add the given char to the end of the sequence of characters in the StringBuilder.\nIn order to see how this can be done, consider how our fields together represent the sequence of characters:\nWithin the array referred to by _characters, the first _length locations (i.e., locations 0 through _length - 1) store the characters in the StringBuilder. This means that _characters[_length] is the next available location, provided this is a valid array location. In this case, we can simply place the char to be appended in _characters[_length], increment _length (because the number of characters in the StringBuilder has increased by 1), and return the StringBuilder.\nHowever, what if we are already using all of the array locations for characters in the StringBuilder? In this case, _length is the length of the array, and therefore is not a valid array location. In order to handle this case, we need to make more room. The only way to do this to construct a new, larger array, and copy all of the characters into it. We will then make _characters refer to the new array. (The .NET Framework actually provides a method to do all this, but in order to show the details of what is happening, we will not use it.) Now that there is enough room, we can append the new character as above. The code is as follows:\n/// \u0026lt;summary\u0026gt; /// Appends the given character to the end of this StringBuilder. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;c\u0026#34;\u0026gt;The character to append.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;This StringBuilder.\u0026lt;/returns\u0026gt; public StringBuilder Append(char c) { if (_length == _characters.Length) { char[] chars = new char[2 * _length]; _characters.CopyTo(chars, 0); _characters = chars; } _characters[_length] = c; _length++; return this; } A few comments on the above code are in order. First, when we need a new array, we allocate one of twice the size as the original array. We do this for a couple of reasons. First, notice that copying every character from one array to another is expensive if there are a lot of characters. For this reason, we don\u0026rsquo;t want to do it very often. By doubling the size of the array every time we run out of room, we increase the size by enough that it will be a while before we need to do it again. On the other hand, doubling the array doesn\u0026rsquo;t waste too much space if we don\u0026rsquo;t need to fill it entirely.\nThe CopyTo method used above copies all of the elements in the array to which this method belongs (in this case, _characters) to the array given by the first parameter (chars in this case), placing them beginning at the location given by the second parameter (0 in this case). Thus, we are copying all the elements of _characters to chars, placing them beginning at location 0.\nThe last statement within the if block assigns the reference stored in chars to _characters; i.e., it makes _characters refer to the same array as does chars. The last statement in the method returns the StringBuilder whose Append method was called.\n To complete this simple implementation, we need to provide a ToString method. This method is already defined for every object; hence, StringBuilder inherits this definition by default. However, the ToString method defined for objects doesn\u0026rsquo;t give us the string we want. Fortunately, though, this method is a virtual method, meaning that we can re-define by overriding it. We do this by using the keyword, override, in its definition. Visual Studio®'s auto-complete feature is helpful here, as when we type the word override, it presents us with a list of the methods that can be overridden. Selecting ToString from this list will fill in a template for the method with a correct parameter list and return type.\nWe want this method to return the string formed from the first _length characters in _characters. We can form such a string using one of the string constructors. This constructor takes three parameters:\n a char[ ] containing the characters to form the string; an int giving the index in this array of the first character to use; and an int giving the number of characters to use.  We can therefore define the ToString method as follows:\n/// \u0026lt;summary\u0026gt; /// Converts this StringBuilder to a string. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;The string equivalent of this StringBuilder.\u0026lt;/returns\u0026gt; public override string ToString() { return new string(_characters, 0, _length); } You can obtain a program containing the complete class definition by creating a Git repository (see “Git Repositories”) using this URL. This program is a modification of the program used in the previous section to compare the performance differences between using strings or StringBuilders when building strings a character at a time. Its only modification is to use this StringBuilder class, defined within a class library, instead of the class defined in the .NET Framework. By running the program on long strings, you can verify that the performance of this StringBuilder class is comparable to that of the StringBuilder in the .NET Framework.\nNow that we have the details of a StringBuilder implementation, we can begin to see why it is so much more efficient to build a string a character at a time using a StringBuilder, as opposed to using a string. As we have noted, allocating a new array and copying all characters to it is expensive; however, we have tried to reduce the number of times this is done. To see how this is accomplished, suppose we are building a string of 100,000 characters. The first time we need a larger array, we will copy 100 characters to a 200-element array. The next time, we will copy 200 characters to a 400-element array. This will continue until we copy 51,200 characters to a 102,400-element array, which is large enough to hold all of the characters. If we add up all of the character copies we have done when allocating new arrays, we find that there are a total of 102,300 copies. In addition, each time we call Append, we copy the char parameter to the array. This is another 100,000 copies. Finally, the ToString method must copy all of the characters to the string it is constructing. This is another 100,000 character copies, for a total of 302,300 copies. In general, the number of character copies will always be less than 4n, where n is the length of the string being built.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/dictionaries/binary-search/",
	"title": "Implementing a Dictionary with an Array-Like Structure",
	"tags": [],
	"description": "",
	"content": "Implementing a Dictionary with an Array-Like Structure In the previous section, we discussed how linked lists could be used to implement a dictionary. An alternative to a linked list would be an array. A couple of other alternatives are the non-generic System.Collections.ArrayList or the generic System.Collections.Generic.List\u0026lt;T\u0026gt;. These classes are similar to singly-dimensioned arrays, but they can grow as needed. In this respect, they are like a StringBuilder, but instead of storing chars, an ArrayList stores objects and a List\u0026lt;T\u0026gt; stores instances of the type parameter T. Elements can be retrieved from instances of these classes using indexing, just like retrieving an element from an array.\nAssuming we restrict the keys to be sub-types of IComparable\u0026lt;TKey\u0026gt;, where TKey is the key type, we can store the keys in order in any of these data structures. We can then search for a key in the same way as we described for a linked list. However, such a search can be expensive - to search for a key that is larger than any key in the dictionary, we need to examine all of the keys. We say that the performance of this sequential search is in $O(n)$, where $n$ is the number of keys in the dictionary. This means that as $n$ grows, the time required for the search is at worst proportional to $n$.\nWe can improve this performance dramatically for an arrays or array-like structure such as an ArrayList or a List\u0026lt;T\u0026gt; using a technique called binary search (there isn\u0026rsquo;t much we can do to improve the performance of searching a linked list, as its structure restricts us to traversing it sequentially). The idea is similar to what humans do when looking for something in an ordered list such as a dictionary or an index of a book. Rather than looking sequentially through the sequence, we first look in the middle and narrow our search space depending on how what we are looking for compares with what we are looking at. For example, if we are looking for \u0026ldquo;Les Miserables\u0026rdquo;, we first look in the middle of the sequence, where we might see \u0026ldquo;Othello\u0026rdquo;. Because \u0026ldquo;Les Miserables\u0026rdquo; is alphabetically less than \u0026ldquo;Othello\u0026rdquo;, we can narrow the search space to those titles less than \u0026ldquo;Othello\u0026rdquo;. In the middle of this search space, we might find the title, \u0026ldquo;Great Expectations\u0026rdquo;. Because \u0026ldquo;Les Miserables\u0026rdquo; is alphabetically greater than \u0026ldquo;Great Expectations\u0026rdquo;, we narrow the search space to those titles greater than \u0026ldquo;Great Expectations\u0026rdquo; and less than \u0026ldquo;Othello\u0026rdquo;. We continue narrowing in this way until either we find \u0026ldquo;Les Miserables\u0026rdquo; or the search space becomes empty, implying that the data set does not contain this title.\nIn a binary search, each lookup is as nearly as possible in the center of the search space. This means that each time we look at an entry, we either find what we are looking for, or we decrease the size of the search space to at most half its previous size. For large data sets the search space therefore shrinks rapidly. For example, if we start with 1,000,000 elements and repeatedly reduce the search space to at most half its previous size, after 20 such reductions, we are left with nothing. Likewise, if we start with 1,000,000,000 elements, 30 such reductions in size lead to an empty search space.\nTo implement this algorithm, we need to keep track of the search space. We will use two int variables, start and end. start will keep track of the first index in the search space, while end will keep track of the first index past the search space, as follows:\nThe way we have defined end may seem unnatural at first, but because it simplifies various calculations, it is a common way of describing a search space. For example, the number of elements in such a search space is simply the difference between end and start, and to describe an entire array, we can initialize start to 0 and end to the array\u0026rsquo;s length.\nWe then need a loop to iterate as long as this search space is nonempty (we can return from inside this loop if we find what we are looking for). On each iteration, we need to find the midpoint of the search space. This midpoint is simply the average of start and end - i.e., their sum divided by 2. We need to be a bit careful here because we are doing integer division, which may involve truncation. As a result, we may not get exactly the average. In any case, we need to ensure that the index we compute is within the search space - otherwise, we may not reduce the search space, and an infinite loop will result. Because the search space is nonempty, start \u0026lt; end; hence, the true average is strictly between start and end. If this average is not an integer, the result will be rounded down to the next smaller integer. Because start is an integer, this result will be no less than start, but less than end; hence it will be in the search space.\nOnce we have computed this midpoint, we need to compare the key of the element at that location with the key we are looking for. Recall that we use the CompareTo method to do this comparison. Note that for large key types, the CompareTo method can be expensive. For this reason, it is best to call the CompareTo method only once for a given pair of keys, and if necessary, save the result it returns in order to make more than one comparison between this result and 0.\nThus, once we have obtained the result of the CompareTo method, we need to determine which of the three cases we have. If the keys are equal, we should be able to return. If the key we are looking for is less than the key at the midpoint, we need to adjust end. Otherwise, we need to adjust start. We are then ready for the next iteration of the loop.\nIf the loop finishes without returning, then the search space is empty; hence, the key we are looking for is not in the data set. However, start will end up at the point at which this key could be inserted; hence, the binary search can be used for both lookups and insertions.\nBinary search is a very efficient way to search an ordered array-like structure. In particular, it always makes no more than $O(\\log n)$ comparisons, where $n$ is the number of elements in the data set. The $\\log$ function grows very slowly - much more slowly than $n$.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/undo/",
	"title": "Implementing Undo and Redo for a TextBox",
	"tags": [],
	"description": "",
	"content": "Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations. This section outlines various ways of implementing such a feature.\nWe first observe that when we perform an Undo, we want to undo the most recent edit that has not been undone; i.e., we need LIFO access to the edits. Likewise, when we perform a Redo, we want to redo the most recent Undo that has not been redone. Again, we need LIFO access to the Undo operations. We will therefore use two stacks, one to keep the edit history, and one to keep the Undo history (i.e., the history of Undo operations that can be redone).\nBefore we can define these stacks, we need to determine what we will be storing in them; i.e., we need to determine how we will represent an edit. We will consider several ways of doing this, but the simplest way is to store the entire contents of the TextBox after each edit. Proceeding in this way, we really aren\u0026rsquo;t representing edits at all, but we certainly would have the information we need to undo the edits. Likewise, the Undo history would store the entire contents of the TextBox prior to each Undo. Because the contents of the TextBox form a string, we need two private fields, each referring to a stack of strings:\n/// \u0026lt;summary\u0026gt; /// The history of the contents of the TextBox. /// \u0026lt;/summary\u0026gt; private Stack\u0026lt;string\u0026gt; _editingHistory = new Stack\u0026lt;string\u0026gt;(); /// \u0026lt;summary\u0026gt; /// The history of TextBox contents that have been undone and can be redone. /// \u0026lt;/summary\u0026gt; private Stack\u0026lt;string\u0026gt; _undoHistory = new Stack\u0026lt;string\u0026gt;(); Before we can proceed to implementing the Undo and Redo operations, we need to do a bit more initialization. Note that by the way we have defined _editingHistory, this stack needs to contain the initial contents of the TextBox. Therefore, assuming the TextBox field is named uxDisplay, we need to add the following line to the end of the constructor of our user interface:\n_editingHistory.Push(uxDisplay.Text); In order to support Undo and Redo, we need to be able to record the content of uxDisplay each time it is modified. We can do this via an event handler for the TextChanged event on the TextBox. Because this event is the default event for a TextBox, we can add such an event handler by double-clicking on the TextBox within the Visual Studio® Design window. This event handler will then be called every time the contents of the TextBox are changed.\nWe need to deal with one important issue before we can write the code for this event handler. Whenever we perform an Undo or Redo operation, we will change the contents of the TextBox. This will cause the TextChanged event handler to be called. However, we don\u0026rsquo;t want to treat an Undo or a Redo in the same way as an edit by the user. For example, if the user does an Undo, we don\u0026rsquo;t want that Undo to be considered an edit, or a subsequent Undo would just undo the Undo; i.e., it would perform a Redo rather than an Undo.\nFortunately, there is an easy way to distinguish between an edit made by the user and a change made by the program code. A TextBox has a Modified property, which is set to true when the user modifies the TextBox contents, and is set to false when the program modifies the contents. Thus, we only want to record the TextBox contents when this property is true. Assuming the TextBox is named uxDisplay, we can then set up the event handler as follows:\n/// \u0026lt;summary\u0026gt; /// Handles a TextChanged event on the TextBox. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void uxDisplay_TextChanged(object sender, EventArgs e) { if (uxDisplay.Modified) { RecordEdit(); } } Now let\u0026rsquo;s consider how to write the RecordEdit method. Suppose there are two GUI controls (e.g., menu items or buttons) called uxUndo and uxRedo, which invoke the Undo and Redo operations, respectively. These controls should be enabled only when there are operations to undo or redo. Thus, initially these controls will be disabled. Whenever the user modifies the contents of the TextBox, we need to do the following:\n Push the resulting text onto _editingHistory. Enable uxUndo, as there is now an edit that can be undone. Clear the contents of _undoHistory, as the last change to the TextBox contents was not an Undo. (A Stack\u0026lt;T\u0026gt; has a Clear method for this purpose.) Disable uxRedo.  We therefore have the following method:\n/// \u0026lt;summary\u0026gt; /// Records an edit made by the user. /// \u0026lt;/summary\u0026gt; private void RecordEdit() { _editingHistory.Push(uxDisplay.Text); uxUndo.Enabled = true; _undoHistory.Clear(); uxRedo.Enabled = false; } Now that we have a mechanism for recording the user\u0026rsquo;s edits, we can implement the Undo operation. The contents of the TextBox following the last edit (i.e, the current contents of the TextBox) should always be at the top of _editingHistory. An Undo should change the current contents to the previous contents - i.e., to the next string on _editingHistory. However, we don\u0026rsquo;t want to lose the top string, as this is the string that would need to be restored by a subsequent Redo. Instead, we need to push this string onto _undoHistory. We then need to enable uxRedo. In order to determine whether uxUndo should be enabled, we need to know how many elements remain in _editingHistory. We know there is at least one string on this stack - the string that we placed in the TextBox. There is an edit to undo if there is at least one more element on this stack - i.e., if its Count is greater than 1. We therefore have the following event handler for a Click event on uxUndo:\n/// \u0026lt;summary\u0026gt; /// Handles a Click event on Undo. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void uxUndo_Click(object sender, EventArgs e) { _undoHistory.Push(_editingHistory.Pop()); uxRedo.Enabled = true; uxDisplay.Text = _editingHistory.Peek(); uxUndo.Enabled = _editingHistory.Count \u0026gt; 1; } The implementation of Redo is similar, but now we need to transfer a string between the stacks in the opposite direction - we move the top string from _undoHistory to _editingHistory. Then uxRedo should be enabled if any more strings remain in _undoHistory. The string we removed from _undoHistory should be placed in the TextBox. Finally, uxUndo should be enabled. We therefore have the following event handler for a Click event on uxRedo:\n/// \u0026lt;summary\u0026gt; /// Handles a Click event on Redo. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void uxRedo_Click(object sender, EventArgs e) { _editingHistory.Push(_undoHistory.Pop()); uxRedo.Enabled = _undoHistory.Count \u0026gt; 0; uxDisplay.Text = _editingHistory.Peek(); uxUndo.Enabled = true; } This solution will work, except that an Undo or Redo always brings the text caret to the beginning of the TextBox contents. Furthermore, if the TextBox contains a long string, each edit causes a long string to be placed onto _editingHistory. This can quickly eat up a lot of memory, and may eventually fill up all available storage. In what follows, we will outline two better approaches.\nThe idea for both of these approaches is that instead of recording the entire contents of the TextBox for each edit, we only record a description of each edit. A single edit will either be an insertion or a deletion of some text. The number of characters inserted/deleted may vary, as the edit may be a cut or a paste (if we select a block of text and do a paste, the TextChanged event handler is actually called twice - once for the deletion of the selected text, and once for the insertion of the pasted text). We can therefore describe the edit with the following three values:\n A bool indicating whether the edit was an insertion or a deletion. An int giving the index of the beginning of the edit. The string inserted or deleted.  We can maintain this information in stacks in one of two ways. One way is to use non-generic stacks and to push three items onto a stack for each edit. If we do this, we need to realize that when we pop elements from the stack, they will come out in reverse order from the way they were pushed onto it. Alternatively, we can define a class or a structure to represent an edit using the three values above as private fields. We can then use generic stacks storing instances of this type.\nWhichever way we choose to represent the edits, we need to be able to compute each of the three pieces of information describing the edit. In order to compute this information, we need to compare the current contents of the TextBox with its prior contents in order to see how it changed. This means that, in addition to the two private fields we defined for the stacks, we will also need a private field to store the last string we saw in the TextBox. Rather than initializing _editingHistory within the constructor, we should now initialize this string in its place (because there will have been no edits initially, both stacks should initially be empty). If we keep this string field up to date, we will always have a \u0026ldquo;before\u0026rdquo; picture (the contents of this field) and an \u0026ldquo;after\u0026rdquo; picture (the current contents of the TextBox) for the edit we need to record.\nTo determine whether the edit was an insertion or a deletion, we can compare the lengths of the current TextBox contents and its previous contents. If the current content is longer, then the edit was an insertion; otherwise, the edit was a deletion. We therefore have the following method for this purpose:\n/// \u0026lt;summary\u0026gt; /// Returns whether text was deleted from the given string in order to /// obtain the contents of the given TextBox. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;editor\u0026#34;\u0026gt;The TextBox containing the result of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lastContent\u0026#34;\u0026gt;The string representing the text prior /// to the edit.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;Whether the edit was a deletion.\u0026lt;/returns\u0026gt; private bool IsDeletion(TextBox editor, string lastContent) { return editor.TextLength \u0026lt; lastContent.Length; } Note that the above code uses the TextBox\u0026rsquo;s TextLength property. This is more efficient than finding the length of its Text property because evaluating the Text property requires all the characters to be copied to a new string.\nBefore getting either the location of the edit or the edit string itself, it is useful to compute the length of the edit string. This length is simply the absolute value of the difference in the lengths of the string currently in the TextBox and the last string we saw there. The Math class (in the System namespace) contains a static method Abs, which computes the absolute value of an int. We therefore have the following method:\n/// \u0026lt;summary\u0026gt; /// Gets the length of the text inserted or deleted. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;editor\u0026#34;\u0026gt;The TextBox containing the result of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lastContent\u0026#34;\u0026gt;The string representing the text prior /// to the edit.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The length of the edit.\u0026lt;/returns\u0026gt; private int GetEditLength(TextBox editor, string lastContent) { return Math.Abs(editor.TextLength - lastContent.Length); } Now that we can determine whether an edit is a deletion or an insertion, and we can find the length of the edit string, it isn\u0026rsquo;t hard to find the beginning of the edit. First, suppose the edit is a deletion. The point at which the deletion occurred is the point at which the text caret now resides. We can find this point using the TextBox\u0026rsquo;s SelectionStart property. When there is no current selection - and there never will be immediately following an edit - this property gives the location of the text caret in the TextBox. Now consider the case in which the edit was an insertion. When text is inserted into a TextBox, the text caret ends up at the end of the inserted text. We need to find its beginning. We can do this by subtracting the length of the edit string from the text caret position. We therefore have the following method:\n/// \u0026lt;summary\u0026gt; /// Gets the location of the beginning of the edit. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;editor\u0026#34;\u0026gt;The TextBox containing the result of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;isDeletion\u0026#34;\u0026gt;Indicates whether the edit was a deletion.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;len\u0026#34;\u0026gt;The length of the edit string.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The location of the beginning of the edit.\u0026lt;/returns\u0026gt; private int GetEditLocation(TextBox editor, bool isDeletion, int len) { if (isDeletion) { return editor.SelectionStart; } else { return editor.SelectionStart - len; } } The last piece of information we need is the string that was deleted or inserted. If the edit was a deletion, this string can be found in the previous TextBox contents. Its beginning is the point at which the edit occurred. We can therefore extract the deleted string from the previous contents using its Substring method. We pass this method the beginning index of the substring and its length, and it returns the substring, which is the deleted string. On the other hand, if the edit was an insertion, we can find the inserted string in the current TextBox contents by using its Substring in a similar way. We therefore have the following method:\n/// \u0026lt;summary\u0026gt; /// Gets the edit string. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;content\u0026#34;\u0026gt;The current content of the TextBox.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;lastContent\u0026#34;\u0026gt;The string representing the text prior /// to the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;isDeletion\u0026#34;\u0026gt;Indicates whether the edit was a deletion.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;editLocation\u0026#34;\u0026gt;The location of the beginning of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;len\u0026#34;\u0026gt;The length of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The edit string.\u0026lt;/returns\u0026gt; private string GetEditString(string content, string lastContent, bool isDeletion, int editLocation, int len) { if (isDeletion) { return lastContent.Substring(editLocation, len); } else { return content.Substring(editLocation, len); } } Using the methods above, we can modify the RecordEdit method to obtain the three values listed above to describe an edit. Once we have placed these three values onto the stack of editing history, we also need to update the string giving the previous TextBox contents. This should now be the current TextBox contents. We can then finish the method as shown above.\nIn order to implement Undo and Redo, we need to be able to insert and delete text in the TextBox. A string has two methods we can use to accomplish this:\n The Remove method takes as its parameters the beginning index and length of the portion to remove, and returns the result. The Insert method takes as its parameters the index at which the string should be inserted, and the string to insert. It returns the result.  Given the location of the edit along with the edit string itself, we can easily provide the parameters to the appropriate method above. Furthermore, it is not hard to set the location of the text caret using the TextBox\u0026rsquo;s SelectionStart property - we just need to be sure to add the length of the edit string if we are inserting text. The following method therefore performs a given edit, updating the string containing the last contents of the TextBox as well (we assume this string is called _lastText):\n/// \u0026lt;summary\u0026gt; /// Performs the given edit on the contents of the given TextBox. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;editor\u0026#34;\u0026gt;The TextBox to edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;isDeletion\u0026#34;\u0026gt;Indicates whether the edit is a deletion.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;loc\u0026#34;\u0026gt;The location of the beginning of the edit.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;text\u0026#34;\u0026gt;The text to insert or delete.\u0026lt;/param\u0026gt; private void DoEdit(TextBox editor, bool isDeletion, int loc, string text) { if (isDeletion) { _lastText = editor.Text.Remove(loc, text.Length); editor.Text = _lastText; editor.SelectionStart = loc; } else { _lastText = editor.Text.Insert(loc, text); editor.Text = _lastText; editor.SelectionStart = loc + text.Length; } } We can now implement event handlers for Undo and Redo. We can obtain the description of the edit from the stack of editing history for an Undo, or from the stack of undo history for a Redo. This description gives us the type of edit (i.e., either insertion or deletion), the beginning position of the edit, and the inserted or deleted string. To implement a Redo, we simply do this edit, but to implement an Undo, we must do the opposite.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/memoization/",
	"title": "Memoization",
	"tags": [],
	"description": "",
	"content": "Memoization We we will now present an example of a common technique involving dictionaries. Consider the following variation of the 2-player game, Nim. The board consists of a number of stones arranged into several piles. Associated with each nonempty pile is a limit, which is a positive integer no greater than the number of stones on that pile (the limit for an empty pile is always 0). Players alternate taking stones according to the following rules:\n On each turn, the player must take some number of stones from a single pile. The number of stones taken must be at least 1, but no more than the current limit for that pile. Taking n stones from a pile changes the limit for that pile to 2n. (If this limit is more than the number of stones remaining on that pile, the new limit is the number of stones remaining.)  The player taking the last stone wins. Note that by the rules of the game, there will always be a winner \u0026mdash; a draw is impossible.\nFor example, suppose we start a game with three piles, each containing 10 stones with a limit of 9. We will denote this board position as (10/9; 10/9; 10/9). If Player 1 removes two stones from Pile 1, the resulting position is (8/4; 10/9; 10/9). Note that because 2 stones were removed from Pile 1, its new limit is 2 x 2 = 4. If Player 2 now removes 4 stones from Pile 2, the resulting position is (8/4; 6/6; 10/9). Note that because 4 stones were removed, the new limit for Pile 2 would become 2 x 4 = 8; however, because only 6 stones remain, the new limit is 6. Play then continues until a player wins by taking all remaining stones.\nLet us define a winning play as any play giving a position from which there is no winning play. Thus, if we make a winning play, there are two possible cases. In the first case, there are no winning plays from the resulting position because there are no legal plays. This means we just took the last stone and won the game. In the other case, there are legal plays, but none is a winning play. Our opponent must make one of these plays. Because it isn\u0026rsquo;t a winning play, there must be a winning play from the resulting position. Therefore, an optimal strategy is to make a winning play whenever one exists. Because of the way a winning play is defined, if a winning play exists, following this strategy will enable us to continue to make winning plays until we eventually win the game. If no winning play exists, we just have to make some play and hope that our opponent blunders by making a play that is not a winning play. If that happens, a winning play will be available, and our strategy leads us to a win.\nConsider the following examples:\n Example 1: (1/1; 0/0). Taking one stone from Pile 1 is a winning play because there is no legal play from the resulting position; hence, there can be no winning play from it. Example 2: (1/1; 1/1). There is no winning play from this position because both legal plays give essentially the position from Example 1, from which there is a winning play. Example 3: (2/2; 1/1). Taking one stone from Pile 1 is a winning play because it leads to (1/1; 1/1), from which there is no winning play, as shown in Example 2.  Given enough stones and piles, finding a winning play or determining that there is none is challenging. In order to develop a search algorithm somewhat similar to the one described in “Tries in Word Games”, we can define the following tree:\n The root is the current board position. The children of a node are all the positions that can be reached by making legal plays.  Thus, the tree defined by (2/2; 2/2) is as follows:\nThe winning plays have been marked with a \u0026lsquo;W\u0026rsquo; in the above tree. As in “Tries in Word Games”, this tree is not a data structure, but simply a mental guide to building a search algorithm. Specifically, we can find a winning play (or determine whether there is none) by traversing the tree in the following way:\n For each legal play p from the given position:  Form the board position that results from making this play (this position is a child). Recursively find a winning play from this new position. If there was no winning play returned (i.e., it was null), return p, as it\u0026rsquo;s a winning play.   If we get to this point we\u0026rsquo;ve examined all the plays, and none of them is winning; hence we return null.  Note that the above algorithm may not examine all the nodes in the tree because once it finds a winning play, it returns it immediately without needing to examine any more children. For example, when processing the children of the node (1/1; 2/2), it finds that from its second child, (1/1; 1/1), there is no winning play; hence, it immediately returns the play that removes one stone from Pile 2 without even looking at the third child, (1/1; 0/0). Even so, because the size of the tree grows exponentially as the number of stones increases, once the number of stones reaches about 25, the time needed for the algorithm becomes unacceptable.\nNotice that several of the nodes in the tree occur multiple times. For example, (1/1; 1/1) occurs twice and (1/1; 0/0) occurs five times. For a large tree, the number of duplicate nodes in the tree increases dramatically. The only thing that determines the presence of a winning move is the board position; hence, once we have a winning move (or know that none exists) for a given position, it will be the same wherever this position may occur in the tree. We can therefore save a great deal of time by saving the winning move for any position we examine. Then whenever we need to examine a position, we first check to see if we\u0026rsquo;ve already processed it \u0026mdash; if so, we just use the result we obtained earlier rather than processing it again. Because processing it again may involve searching a large tree, the savings in time might be huge.\nThe technique outlined in the above paragraph is known as memoization (not to be confused with memorization) \u0026mdash; we make a memo of the results we compute so that we can look them up again later if we need them. A dictionary whose keys are board positions and whose values are plays is an ideal data structure for augmenting the above search with memoization. As the first step, before we look at any plays from the given board position, we look up the position in the dictionary. If we find it, we immediately return the play associated with it. Otherwise, we continue the algorithm as before, but prior to returning a play (even if it is null), we save that play in the dictionary with the given board position as its key. This memoization will allow us to analyze board positions containing many more stones.\nTo implement the above strategy, we need to define two types - one to represent a board position and one to represent a play. The type representing a play needs to be a class so that we can use null to indicate that there is no winning play. The type representing a board position can be either a class or a structure. Because the dictionary needs to be able to compare instances of this type for equality in order be able to find keys, its definition will need to re-define the equality comparisons. Consequently, we need to redefine the hash code computation to be consistent with the equality comparison. The next two sections will examine these topics.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/merge/",
	"title": "Merge Sorts",
	"tags": [],
	"description": "",
	"content": "Merge Sorts A merge sort works by merging together two sorted parts of an array. Thus, we should focus our attention on an array that is partitioned into two sorted parts, as shown in the following figure.\nThe different ways of implementing a merge sort depend both on how the above arrangement is achieved, and also on how the two parts are merged together. The simplest implementation is an algorithm simply called merge sort.\nMerge sort uses recursion to arrange the array into two sorted parts. In order to use recursion, we need to express our algorithm, not in terms of sorting an array, but instead in terms of sorting a part of an array. If the part we are sorting has more than one element, then we can split it into two smaller parts of roughly equal size (if it doesn\u0026rsquo;t have more than one element, it is already sorted). Because both parts are smaller, we can recursively sort them to achieve the arrangement shown above.\nThe more complicated step in merge sort is merging the two sorted parts into one. While it is possible to do this without using another array (or other data structure), doing so is quite complicated. Merge sort takes a much simpler approach that uses a temporary array whose size is the sum of the sizes of the two sorted parts combined. It first accumulates the data items into the new array in sorted order, then copies them back into the original array.\nIn order to understand how the merging works, let\u0026rsquo;s consider a snapshot of an arbitrary step of the algorithm. If we\u0026rsquo;ve accumulated an initial portion of the result, these elements will be the smallest ones. Because both of the parts we are merging are sorted, these smallest elements must come from initial portions of these two parts, as shown below.\nInitially, the three shaded areas above are all empty. In order to proceed, we need local variables to keep track of the first index in each of the three unshaded areas. We then iterate as long as both of the unshaded areas are nonempty. On each iteration, we want to place the next element into the temporary array. This element needs to be the smallest of the unmerged elements. Because both parts of the given array are sorted, the smallest unmerged element will be the first element from one of the two unshaded parts of this array \u0026mdash; whichever one is smaller (for stability, we use the first if they are equal). We copy that element to the beginning of the unshaded portion of the temporary array, then update the local variables to reflect that we have another merged item.\nThe above loop will terminate as soon as we have merged all the data items from one of the two sorted parts; however, the other sorted part will still contain unmerged items. To finish merging to the temporary array, we just need to copy the remaining items to the temporary array. We can do this by first copying all remaining items from the first sorted part, then copying all remaining items from the second sorted part (one of these two copies will copy nothing because there will be no remaining items in one of the two sorted parts). Once all items have been merged into the temporary array, we copy all items back to the original array to complete the merge.\nWe won\u0026rsquo;t do a running time analysis here, but merge sort runs in $O(n \\lg n)$ time in the worst case. Furthermore, unlike heap sort, it is stable. Because it tends to perform better in practice than tree sort, it is a better choice when we need a stable sorting algorithm. In fact, it is the basis (along with insertion sort) of a stable hybrid sorting algorithm that performs very well in practice. This algorithm, called Tim sort, is rather complicated; hence, we won\u0026rsquo;t describe it here. If we don\u0026rsquo;t need a stable sorting algorithm, though, there are other alternatives, as we shall see in the next two sections.\n Another scenario in which a merge sort is appropriate occurs when we have a huge data set that will not fit into an array. In order to sort such a data set, we need to keep most of the data in files while keeping a relatively small amount within internal data structures at any given time. Because merging processes data items sequentially, it works well with files. There are several variations on how we might do this, but the basic algorithm is called external merge sort.\nExternal merge sort uses four temporary files in addition to an input file and an output file. Each of these files will alternate between being used for input and being used for output. Furthermore, at any given time, one of the two files being used for input will be designated as the first input file, and the other will designated as the second input file. Similarly, at any given time, one of the two files being used for output will be designated as the current output file, and the other will be designated as the alternate output file.\nThe algorithm begins with an initialization step that uses the given unsorted data file as its input, and two of the temporary files as its output. We will need two variables storing references to the current output file and the alternate output file, respectively. At this point we begin a loop that iterates until we reach the end of the input. Each iteration of this loop does the following:\n Fill a large array with data items from the input (if there aren\u0026rsquo;t enough items to fill this array, we just use part of it). Sort this array using whatever sorting algorithm is appropriate. Write each element of the sorted array to the current output file. Write a special end marker to the output file. Swap the contents of the variables referring to the current output file and the alternate output file.  After the above loop terminates, the two output files are closed. Thus, the initialization writes several sorted sequences, each terminated by end markers, to the two output files. Furthermore, either the two output files will contain the same number of sorted sequences or the one that was written to first will contain one more sorted sequence than the other. The following figure illustrates these two files.\nThe algorithm then enters the main loop. Initially the output file first written in the initialization is designated as the first input file, and the other file written in the initialization is designated as the second input file. The other two temporary files are arbitrarily designated as the current output file and the alternate output file. The loop then iterates as long as the second input file is nonempty. Each iteration does the following:\n While there is data remaining in the second input file: Merge the next sorted sequence in the first input file with the next sorted sequence in the second input file, writing the result to the current output file (see below for details). Write an end marker to the current output file. Swap the current output file and the alternate output file.  If there is data remaining in the first input file:Copy the remaining data from the first input file to the current output file Write an end marker to the current output file. Swap the current output file and the alternate output file.  Close all four temporary files. Swap the first input file with the alternate output file. Swap the second input file with the current output file.  Each iteration therefore combines pairs of sorted sequences from the two input files, thus reducing the number of sorted sequences by about half. Because it alternates between the two output files, as was done in the initialization, either the two output files will end up with the same number of sequences, or the last one written (which will be the alternate output file following step 2) will have one more than the other. The last two steps therefore ensure that to begin the next iteration, if the the number of sequences in the two input files is different, the first input file has the extra sequence.\nThe loop described above finishes when the second input file is empty. Because the first input file will have no more than one more sorted sequence than the second input file, at the conclusion of the loop, it will contain a single sorted sequence followed by an end marker. The algorithm therefore concludes by copying the data from this file, minus the end marker, to the output file.\nLet\u0026rsquo;s now consider more carefully the merge done in step 1a above. This merge is done in essentially the same way that the merge is done in the original merge sort; however, we don\u0026rsquo;t need to read in the entire sorted sequences to do it. Instead, all we need is the next item from each sequence. At each step, we write the smaller of the two, then read the next item from the appropriate input file. Because we only need these two data items at any time, this merge can handle arbitrarily long sequences.\nFor an external sorting algorithm, the most important measure of performance is the number of file I/O operations it requires, as these operations are often much more expensive than any other (depending, of course, on the storage medium). Suppose the initial input file has $n$ data items, and suppose the array we use in the initialization step can hold $m$ data items. Then the number of sorted sequences written by the initialization is $n/m$, with any fractional part rounded up. Each iteration of the main loop then reduces the number of sorted sequences by half, with any fractional part again rounded up. The total number of iterations of the main loop is therefore $\\lg (n/m)$, rounding upward again. Each iteration of this loop makes one pass through the entire data set. In addition, the initialization makes one pass, and the final copying makes one pass. The total number of passes through the data is therefore $\\lg (n/m) + 2$. For example, if we are sorting $10$ billion data items using an array of size $1$ million, we need $\\lg 10,000 + 2$ passes, rounded up; i.e., we need $16$ passes through the data.\nVarious improvements can be made to reduce the number of passes through the data. For example, we can avoid the final file copy if we use another mechanism for denoting the end of a sorted sequence. One alternative is to keep track of the length of each sequence in each file in a List\u0026lt;long\u0026gt;. If the temporary files are within the same directory as the output file, we can finish the sort by simply renaming the first input file, rather than copying it.\nA more substantial improvement involves using more temporary files. $k$-way external merge sort uses $k$ input and $k$ output files. Each merge then merges $k$ sorted sequences into $1$. This reduces the number of iterations of the main loop to $\\log_k (n/m)$. Using the fact that $\\log_{k^2} n = (\\log_k n)/2$, we can conclude that squaring $k$ will reduce the number of passes through the data by about half. Thus, $4$-way external merge sort will make about half as many passes through the data as $2$-way external merge sort. The gain diminishes quickly after that, however, as we must increase $k$ to $16$ to cut the number of passes in half again.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/naming/",
	"title": "Naming Conventions",
	"tags": [],
	"description": "",
	"content": "Naming Conventions The naming conventions described below use the following terminology:\n Pascal case: Multiple words are joined without spaces, using capital letters at the beginning of each word. If acronyms of 3 or more letters are included, only the first letter of the acronym is capitalized. For example, AverageAge, ContextBoundObject, RgbCode. Camel case: The same as pascal case, except the first letter is not capitalized. For example, averageAge, contextBoundObject, rgbCode.  Namespaces Use the form Ksu.Cis300.ProgramName, where each of the 3 components is in pascal case. For the program name, use a name that tells what the program does, not something like Homework1. For example:\nnamespace Ksu.Cis300.Spreadsheet { } Classes, Structures, and Enumerations Use pascal case. If the name begins with \u0026ldquo;I\u0026rdquo;, the following letter must not be capitalized, as this would look like an interface - see below. For an exception class, append the word \u0026ldquo;Exception\u0026rdquo;. Make your names descriptive nouns or noun phrases without abbreviations. For example:\npublic class AccountManager { } Interfaces Use the above conventions with a capital \u0026ldquo;I\u0026rdquo; preceding the first letter (which must also be capitalized). For example:\npublic interface IPriorityQueue { } Methods Use pascal case. Make your names descriptive without abbreviations. For example:\nprivate void InitializeComponent() { }  Note\nAutomatically-generated event handlers don\u0026rsquo;t follow this convention - this is an allowable exception to the rule. If you need to write your own event handlers, follow the style of the automatically generated ones.\n Properties Use pascal case. Make your names descriptive without abbreviations. For example:\npublic int Count { get; private set; } Controls on Forms Use camel case, and begin names with \u0026ldquo;ux\u0026rdquo; followed by a capital letter (this \u0026ldquo;ux\u0026rdquo; stands for \u0026ldquo;user experience\u0026rdquo;). Make your names descriptive of the functionality, not the type of control. For example, uxAccept, uxCustomerName.\nNote\nYou will not typically declare these names in code, but will enter them in the Visual Studio® design window.\n public Constants Use pascal case. Make your names descriptive. For example:\npublic const double GravitationalAcceleration = 9.80665; private Fields Use camel case with an underscore character preceding the first letter. For example:\nprivate double _weight; Parameters and Local Variables Within Methods Use camel case. For example, inString and outString in the following code:\npublic string ToMixedCase(string inString) { string outString; // code here  return outString; } "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/paren/",
	"title": "Parenthesis Matching",
	"tags": [],
	"description": "",
	"content": "Parenthesis Matching The problem of finding matching parentheses must be solved in many computing applications. For example, consider a C# compiler. Matching parentheses (( and )), brackets ([ and ]), and braces ({ and }) delimit various parts of the source code. In order for these parts to be interpreted correctly, the compiler must be able to determine how these different kinds of parentheses match up with each other. Another example is processing structured data stored in XML format. Different parts of such a data set are delimited by nested begin tags like \u0026lt;summary\u0026gt; and end tags like \u0026lt;/summary\u0026gt; (documentation comments in C# code are in XML format). These tags are essentially different kinds of parentheses that need to be matched.\nWe will restrict our attention to parentheses, brackets, and braces. We will call all six of these characters \u0026ldquo;parentheses\u0026rdquo;, but will divide them into three types. Each type then has an opening parenthesis and a closing parenthesis. We will define a string restricted to these six characters to be matched (or balanced) if we can repeatedly remove an opening parenthesis and a closing parenthesis of the same type to its immediate right until there are no more parentheses.\nFor example, suppose we have the string, \u0026ldquo;([]{()[]})[{}]\u0026rdquo;. We can apply the matching-pair removal process described above as follows (blank space is inserted to make it easier to see which parentheses are removed):\n ([]{()[]})[{}] ( {()[]})[{}] ( { []})[{}] ( { })[{}] ( )[{}] [{}] [ ]  Hence, this string is matched. On the other hand, consider the string, \u0026ldquo;([]{()[])}[{}]\u0026rdquo;. When we apply the above process to this string, we obtain:\n ([]{()[])}[{}] ( {()[])}[{}] ( { [])}[{}] ( { )}[{}] ( { )}[ ] ( { )}  and we can go no further. Hence, this string is not matched.\nWe can extend the definition of a matched string to include other characters if we first remove all other characters before we begin the matching-pair removal process. In what follows, we will focus on the problem of determining whether a given string is matched.\nThe matching-pair removal process shown above gives us an algorithm for determining whether a string is matched. However, if implemented directly, it isn\u0026rsquo;t very efficient. Changes to a string are inefficient because the entire string must be reconstructed. We could use a StringBuilder, but even then, removing characters is inefficient, as all characters to the right of the removed character must be moved to take its place. Even if we simply change parentheses to blanks, as we did in the above example, searching for matching pairs is still rather expensive.\nWhat we would like to do instead is to find a way to apply the matching-pair removal process while scanning the string once. As we are scanning the string, we don\u0026rsquo;t want to spend time searching for a matching pair. We can do this if, while scanning the string, we keep all unmatched opening parentheses in a stack. Then the parenthesis at the top of the stack will always be the rightmost unmatched opening parenthesis. Thus, starting with an empty stack, we do the following for each character in the string:\n If the character is a opening parenthesis, push it onto the stack. If the character is a closing parenthesis:  If the stack is nonempty, and the current character matches the character on top of the stack, remove the character from the top of the stack. Otherwise, the string is not matched.   Ignore all other characters.  If the stack is empty when the entire string has been processed, then the string is matched; otherwise, it is not.\nFor example, consider the string, \u0026ldquo;{a[b]([c]){de}}f[(g)]\u0026rdquo;. In what follows, we will simulate the above algorithm, showing the result of processing each character on a separate line. The portion of the line with an orange background will be the stack contents, with the top element shown at the right. We will insert blank space in the orange area for clarity, but the stack will only contain opening parentheses. The first character with a black background is the character currently being processed.\n {a[b]([c]){de}}f[(g)] --- an opening parenthesis - push it onto the stack {a[b]([c]){de}}f[(g)] --- ignore { [b]([c]){de}}f[(g)] --- push onto stack { [b]([c]){de}}f[(g)] --- ignore { [ ]([c]){de}}f[(g)] --- closing parenthesis that matches the top - remove top { ([c]){de}}f[(g)] --- push onto stack { ([c]){de}}f[(g)] --- push onto stack { ([c]){de}}f[(g)] --- ignore { ([ ]){de}}f[(g)] --- a match - remove top { ( ){de}}f[(g)] --- a match - remove top { {de}}f[(g)] --- push onto stack { {de}}f[(g)] --- ignore { { e}}f[(g)] --- ignore { { }}f[(g)] --- a match - remove top { }f[(g)] --- a match - remove top f[(g)] --- ignore [(g)] --- push onto stack [(g)] --- push onto stack [(g)] --- ignore [( )] --- a match - remove top [ ] --- a match - remove top  --- end of string and stack empty - matched string  If at any time during the above process we had encountered a closing parenthesis while the stack was empty, this would have indicated that this closing parenthesis has no matching opening parenthesis. In this case, we would have stopped immediately, determining that the string is not matched. Likewise, if we had encountered a closing parenthesis that did not match the parentheis at the top of the stack, this would have indicated a mismatched pair. Again, we would have stopped immediately. Finally, if we had reached the end of the string with a nonempty stack, this would have indicated that we had at least one opening parenthesis that was never matched. We would have again determined that the string is not matched.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/bst/remove/",
	"title": "Removing from a Binary Search Tree",
	"tags": [],
	"description": "",
	"content": "Removing from a Binary Search Tree Before we can discuss how to remove an element from a binary search tree, we must first define exactly how we want the method to behave. Consider first the case in which the tree is built from immutable nodes. We are given a key and a binary search tree, and we want to return the result of removing the element having the given key. However, we need to decide what we will do if there is no element having the given key. This does not seem to be exceptional behavior, as we may have no way of knowing in advance whether the key is in the tree (unless we waste time looking for it). Still, we might want to know whether the key was found. We therefore need two pieces of information from this method - the resulting tree and a bool indicating whether the key was found. In order to accommodate this second piece of information, we make the bool an out parameter.\nWe can again break the problem into cases and use recursion, as we did for adding an element. However, removing an element is complicated by the fact that its node might have two nonempty children. For example, suppose we want to remove the element whose key is 54 in the following binary search tree:\nIn order to preserve the correct ordering of the keys, we should replace 54 with either the next-smaller key (i.e., 41) or the next-larger key (i.e., 64). By convention, we will replace it with the next-larger key, which is the smallest key in its right child. We therefore have a sub-problem to solve - removing the element with the smallest key from a nonempty binary search tree. We will tackle this problem first.\nBecause we will not need to remove the smallest key from an empty tree, we don\u0026rsquo;t need to worry about whether the removal was successful - a nonempty binary search tree always has a smallest key. However, we still need two pieces of information from this method:\n the element removed (so that we can use it to replace the element to be removed in the original problem); and the resulting tree (so that we can use it as the new right child in solving the original problem).  We will therefore use an out parameter for the element removed, and return the resulting tree.\nBecause we don\u0026rsquo;t need to worry about empty trees, and because the smallest key in a binary search tree is never larger than the key at the root, we only have two cases:\n The left child is empty. In this case, there are no keys smaller than the key at the root; i.e., the key at the root is the smallest. We therefore assign the data at the root to the out parameter, and return the right child, which is the result of removing the root. The left child is nonempty. In this case, there is a key smaller than the key at the root; furthermore, it must be in the left child. We therefore use a recursive call on the left child to obtain the result of removing element with the smallest key from that child. We can pass as the out parameter to this recursive call the out parameter that we were given - the recursive call will assign to it the element removed. We then need to construct a new node whose data and right child are the same as in the given tree, but whose left child is the tree returned by the recursive call. We return this node.  Having this sub-problem solved, we can now return to the original problem. We again have four cases, but one of these cases breaks into three sub-cases:\n The tree is empty. In this case the key we are looking for is not present, so we set the out parameter to false and return an empty tree. The key we are looking for is at the root. In this case, we can set the out parameter to true but in order to remove the element, we have three sub-cases:  The left child is empty. We can then return the right child (the result of removing the root). The right child is empty. We can then return the left child. Both children are nonempty. We must then obtain the result of removing the smallest key from the right child. We then construct a new node whose data is the element removed from the right child, the left child is the left child of the given tree, and the right child is the result of removing the smallest key from that child. We return this node.   The key we are looking for is less than the key at the root. We then obtain the result of removing this key from the left child using a recursive call. We can pass as the out parameter to this recursive call the out parameter we were given and let the recursive call set its value. We then construct a new node whose data and right child are the same as in the given tree, but whose left child is the tree returned by the recursive call. We return this node. The key we are looking for is greater than the key at the root. This case is symmetric to the above case.  As we did with adding elements, we can optimize the methods described above for mutable nodes by modifying the contents of a node rather than constructing new nodes.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/",
	"title": "Stacks and Queues",
	"tags": [],
	"description": "",
	"content": "Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an \u0026ldquo;Undo\u0026rdquo; operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations. However, we don\u0026rsquo;t want to undo just any operation in this sequence - we need to undo the most recent one that hasn\u0026rsquo;t yet been undone. We therefore need to access the operations in last-in-first-out, or LIFO, order. Other applications might need to access data items in first-in-first-out, or FIFO, order. In this chapter, we will examine data structures that support these kinds of access.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/structs/",
	"title": "Structures",
	"tags": [],
	"description": "",
	"content": "Structures A structure is similar to a class, except that it is a value type, whereas a class is a reference type. A structure definition looks a lot like a class definition; for example, the following defines a structure for storing information associated with a name:\n/// \u0026lt;summary\u0026gt; /// A structure containing a name, frequency, and rank. /// \u0026lt;/summary\u0026gt; public struct NameInformation { /// \u0026lt;summary\u0026gt;  /// The name.  /// \u0026lt;/summary\u0026gt;  private string _name; /// \u0026lt;summary\u0026gt;  /// The frequency.  /// \u0026lt;/summary\u0026gt;  private float _frequency; /// \u0026lt;summary\u0026gt;  /// The rank.  /// \u0026lt;/summary\u0026gt;  private int _rank; /// \u0026lt;summary\u0026gt;  /// Gets the name.  /// \u0026lt;/summary\u0026gt;  public string Name { get { return _name; } } /// \u0026lt;summary\u0026gt;  /// Gets the frequency.  /// \u0026lt;/summary\u0026gt;  public float Frequency { get { return _frequency; } } /// \u0026lt;summary\u0026gt;  /// Gets the rank.  /// \u0026lt;/summary\u0026gt;  public int Rank { get { return _rank; } } /// \u0026lt;summary\u0026gt;  /// Constructs a new NameInformation containing the given name,  /// frequency, and rank.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;name\u0026#34;\u0026gt;The name.\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;frequency\u0026#34;\u0026gt;The frequency.\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;rank\u0026#34;\u0026gt;The rank.\u0026lt;/param\u0026gt;  public NameInformation(string name, float frequency, int rank) { _name = name; _frequency = frequency; _rank = rank; } } Note that the above definition looks just like a class definition, except that the keyword struct is used instead of the keyword class. A structure can be defined anywhere a class can be defined. However, there are several restrictions on what a structure definition may contain. Some of the more important restrictions include:\n  A field may not be initialized in the statement that defines it unless it is declared to be const or static. For example, while the following would be allowed in a class definition, it is not allowed in a structure definition:\nprivate int _rank = -1; These fields are instead automatically initialized to the default values for their types. If you want to initialize a field to another value, you will need to use a constructor (but see the next restriction).\n  All constructors must contain at least one parameter. There will always be a default constructor containing no parameters. It will initialize all non-static, non-const fields to the default values for their types.\n  A field may not be defined to have same type as the structure containing it. For example, the following is not allowed:\npublic struct S { private S _nextS; }   For more information on structures, see the section, “Classes and Structs” in the C# Programming Guide.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/tries/traversing/",
	"title": "Traversing a Trie",
	"tags": [],
	"description": "",
	"content": "Traversing a Trie As with other kinds of trees, there are occasions where we need to process all the elements stored in a trie in order. Here, the elements are strings, which are not stored explicitly in the trie, but implicitly based on the labels of various nodes. Thus, an individual node does not contain a string; however, if its bool has a value of true, then the path to that node describes a string stored in the trie. We can therefore associate this string with this node. Note that this string is a prefix of any string associated with any node in any of this node\u0026rsquo;s children; hence, it is alphabetically less than any string found in any of the children. Thus, in order to process each of the strings in alphabetic order, we need to do a preorder traversal, which processes the root before recursively processing the children.\nIn order to process the string associated with a node, we need to be able to retrieve this string. Because we will have followed the path describing this string in order to get to the node associated with it, we can build this string on the way to the node and pass it as a parameter to the preorder traversal of the trie rooted at this node. Because we will be building this string a character at a time, to do this efficiently we should use a StringBuilder instead of a string. Thus, the preorder traversal method for a trie will take a StringBuilder parameter describing the path to that trie, in addition to any other parameters needed to process the strings associated with its nodes.\nBefore we present the algorithm itself, we need to address one more important issue. We want the StringBuilder parameter to describe the path to the node we are currently working on. Because we will need to do a recursive call on each child, we will need to modify the StringBuilder to reflect the path to that child. In order to be able to do this, we will need to ensure that the recursive calls don\u0026rsquo;t change the contents of the StringBuilder (or more precisely, that they undo any changes that they make).\nBecause we are implementing a preorder traversal, the first thing we will need to do is to process the root. This involves determining whether the root is associated with a string contained in the trie, and if so, processing that string. Determining whether the root is associated with a contained string is done by checking the bool at the root. If it is true, we can convert the StringBuilder parameter to a string and process it by doing whatever processing needs to be done for each string in our specific application.\nOnce we have processed the root, we need to recursively process each of the children in alphabetic order of their labels. How we accomplish this depends on how we are implementing the trie - we will assume the implementation of the previous section. Because this implementation uses three different classes depending on how many children a node has, we will need to write three different versions of the preorder traversal, one for each class:\n For a TrieWithNoChildren, there is nothing to do (after processing the root). Because a TrieWithOneChild has exactly one child, we need a single recursive call on this child. Before we make this call, we will need to append the child\u0026rsquo;s label to the StringBuilder. Following the recursive call, we will need to remove the character that we added by reducing its Length property by 1. We handle a TrieWithManyChildren in a similar way as a TrieWithOneChild , only we will need to iterate through the array of children and process each non-null child with a recursive call. Note that for each of these children, its label will need to be appended to the StringBuilder prior to the recursive call and removed immediately after. We can obtain the label of a child by adding \u0026lsquo;a\u0026rsquo; to its array index and casting the result to a char.  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/graphs/breadth-first/",
	"title": "Unweighted Shortest Paths",
	"tags": [],
	"description": "",
	"content": "Unweighted Shortest Paths In some shortest path problems, all edges have the same length. For example, we may be trying to find the shortest path out of a maze. Each cell in the maze is a node, and an edge connects two nodes if we can move between them in a single step. In this problem, we simply want to minimize the number of edges in a path to an exit. We therefore say that the edges are unweighted \u0026mdash; they contain no explicit length information, and the length of each edge is considered to be $1$.\nWe could of course apply Dijkstra’s algorithm to this problem, using $1$ as the length of each edge. However, if analyze what this algorithm does in this case, we find that we can optimize it to achieve significantly better performance.\nThe optimization revolves around the use of the min-priority queue. Note that Dijkstra\u0026rsquo;s algorithm first adds all outgoing edges from the start node u to the min-priority queue, using their lengths as their priorities. For unweighted edges, each of these priorities will be $1$. As the algorithm progresses it retrieves the minimum priority and removes an edge having this priority. If it adds any new edges before removing the next edge, they will all have a priority $1$ greater than the priority of the edge just removed.\nWe claim that this behavior causes the priorities in the min-priority queue to differ by no more than $1$. To see this, we will show that we can never reach a point where we change the maximum difference in priorities from no more than $1$ to more than $1$. First observe that when the outgoing edges from u are added, the priorities all differ by $0 \\leq 1$. Removing an edge can\u0026rsquo;t increase the difference in the priorities stored. Suppose the edge we remove has priority $p$. Assuming we have not yet achieved a priority difference greater than $1$, any priorities remaining in the min-priority queue must be either $p$ or $p + 1$. Any edges we add before removing the next edge have priority $p + 1$. Hence, the priority difference remains no more than $1$. Because we have covered all changes to the priority queue, we can never cause the priority difference to exceed $1$.\nBased on the above claim, we can now claim that whenever an edge is added, its priority is the largest of any in the min-priority queue. This is certainly true when we add the outgoing edges from u, as all these edges have the same priority. Furthermore, whenever we remove an edge with priority $p$, any edges we subsequently add have priority $p + 1$, which must be the maximum priority in the min-priority queue.\nAs a result of this behavior, we can replace the min-priority queue with an ordinary FIFO queue, and for unweighted edges, the behavior of the algorithm will be the same. Because accessing a FIFO queue is more efficient than accessing a min-priority queue, the resulting algorithm, known as breadth-first search, is also more efficient.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/solutions/",
	"title": "Visual Studio Solutions",
	"tags": [],
	"description": "",
	"content": "Visual Studio Solutions All code developed within Visual Studio 2019 must belong to one or more solutions. When you are using Visual Studio to develop a program, you will be working with a single solution. A solution will contain one or more projects. Each of these projects may belong to more than one solution. Each project typically contains several files, including source code files. Each file will typically belong to only one project. The following figure illustrates some of the possible relationships between solutions, projects, and files.\nNote that in the above figure, Project4 is contained in both Solution2 and Solution3. In this section, we will focus on solutions that contain exactly one project, which in turn belongs to no other solutions (e.g., Solution1 in the above figure).\nWhenever you open a solution in Studio 2019, the Solution Explorer (which you can always find on the \u0026ldquo;View\u0026rdquo; menu) will give you a view of the structure of your solution; for example, opening the solution in the repository given in the previous section should result in the following being shown in the Solution Explorer:\nYou will normally want to see the Solution view, which you can get by double clicking the line that ends in \u0026ldquo;.sln\u0026rdquo;. This will give you the following view:\nWarning\nYou ordinarily will not want to use Folder view, as this will cause files to be edited without any syntax or consistency checking. As a result, you can end up with a solution that is unusable. If your Solution Explorer ever looks like this:\n(note the indication \u0026ldquo;Folder View\u0026rdquo; at the top and the absence of any boldface line), then it is in Folder view. To return to Solution view, click the icon indicated by the arrow in the above figure. This will return the Solution Explorer to its initial view, where you can double-click the solution to select Solution view.\n If you click on the small triangle to the left of \u0026ldquo;Ksu.Cis300.HelloWorld\u0026rdquo;, you will get a more-detailed view:\nNear the top, just under the search box, is the name of the solution with an indication of how many projects it contains. Listed under the name of the solution is each project, together with the various components of the project. One of the projects is always shown in bold face. The bold face indicates that this project is the startup project; i.e., it is the project that the debugger will attempt to execute whenever it is invoked (for more details, see the section, “The Debugger”).\nThe project components having a suffix of \u0026ldquo;.cs\u0026rdquo; are C# source code files. When a Windows Forms Application is created, its project will contain the following three source code files:\n  Form1.cs: This file contains code that you will write in order to implement the main GUI for the application. It will be discussed in more detail in “The Code Window”.\n  Form1.Designer.cs: You will need to click the triangle to the left of \u0026ldquo;Form1.cs\u0026rdquo; in the Solution Explorer in order to reveal this file name. This contains automatically-generated code that completes the definition of the main GUI. You will build this code indirectly by laying out the graphical components of the GUI in the design window (see the section, “The Design Window” for more details). Ordinarily, you will not need to look at the contents of this file.\n  Program.cs: This file will contain something like the following:\nusing System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using System.Windows.Forms; namespace Ksu.Cis300.HelloWorld { static class Program { /// \u0026lt;summary\u0026gt;  /// The main entry point for the application.  /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } } } The Main method is where the application code begins. The last line of this method constructs a new instance of the class that implements the GUI. The call to Application.Run displays the GUI and starts a loop that processes events such as mouse clicks and keystrokes. Ordinarily, there is no need to look at this code.\n  One of the first things you will need to do when starting a new Windows Forms Application is to change the name of Form1.cs, as this name (without the \u0026ldquo;.cs\u0026rdquo; suffix) is also the name of the class implementing the GUI. Therefore, it will need to be changed in order to conform to the naming convention for classes. To do this, right-click on its name in the Solution Explorer, and select \u0026ldquo;Rename\u0026rdquo; from the resulting popup menu. You will then be able to edit the name in the Solution Explorer. When you have entered the new name, the following window will be displayed:\nYou should click the \u0026ldquo;Yes\u0026rdquo; button in order to make the renaming consistent - particularly to rename the class as well.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/solutions/",
	"title": "Visual Studio Solutions",
	"tags": [],
	"description": "",
	"content": "Visual Studio Solutions All code developed within Visual Studio 2022 must belong to one or more solutions. When you are using Visual Studio to develop a program, you will be working with a single solution. A solution will contain one or more projects. Each of these projects may belong to more than one solution. Each project typically contains several files, including source code files. Each file will typically belong to only one project. The following figure illustrates some of the possible relationships between solutions, projects, and files.\nNote that in the above figure, Project4 is contained in both Solution2 and Solution3. In this section, we will focus on solutions that contain exactly one project, which in turn belongs to no other solutions (e.g., Solution1 in the above figure).\nWhenever you open a solution in Studio 2022, the Solution Explorer (which you can always find on the \u0026ldquo;View\u0026rdquo; menu) will give you a view of the structure of your solution; for example, opening the solution in the repository given in the previous section should result in the following being shown in the Solution Explorer:\nYou will normally want to see the Solution view, which you can get by double clicking the line that ends in \u0026ldquo;.sln\u0026rdquo;. This will give you the following view:\nWarning\nYou ordinarily will not want to use Folder view, as this will cause files to be edited without any syntax or consistency checking. As a result, you can end up with a solution that is unusable. If your Solution Explorer ever looks like this:\n(note the indication \u0026ldquo;Folder View\u0026rdquo; at the top and the absence of any boldface line), then it is in Folder view. To return to Solution view, click the icon indicated by the arrow in the above figure. This will return the Solution Explorer to its initial view, where you can double-click the solution to select Solution view.\n If you click on the small triangle to the left of \u0026ldquo;Ksu.Cis300.HelloWorld\u0026rdquo;, you will get a more-detailed view:\nNear the top, just under the search box, is the name of the solution with an indication of how many projects it contains. Listed under the name of the solution is each project, together with the various components of the project. One of the projects is always shown in bold face. The bold face indicates that this project is the startup project; i.e., it is the project that the debugger will attempt to execute whenever it is invoked (for more details, see the section, “The Debugger”).\nThe project components having a suffix of \u0026ldquo;.cs\u0026rdquo; are C# source code files. When a Windows Forms App is created, its project will contain the following three source code files:\n  Form1.cs: This file contains code that you will write in order to implement the main GUI for the application. It will be discussed in more detail in “The Code Window”.\n  Form1.Designer.cs: You will need to click the triangle to the left of \u0026ldquo;Form1.cs\u0026rdquo; in the Solution Explorer in order to reveal this file name. This contains automatically-generated code that completes the definition of the main GUI. You will build this code indirectly by laying out the graphical components of the GUI in the design window (see the section, “The Design Window” for more details). Ordinarily, you will not need to look at the contents of this file.\n  Program.cs: This file will contain something like the following:\nusing System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using System.Windows.Forms; namespace Ksu.Cis300.HelloWorld { static class Program { /// \u0026lt;summary\u0026gt;  /// The main entry point for the application.  /// \u0026lt;/summary\u0026gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(new Form1()); } } } The Main method is where the application code begins. The last line of this method constructs a new instance of the class that implements the GUI. The call to Application.Run displays the GUI and starts a loop that processes events such as mouse clicks and keystrokes. Ordinarily, there is no need to look at this code.\n  One of the first things you will need to do when starting a new Windows Forms App is to change the name of Form1.cs, as this name (without the \u0026ldquo;.cs\u0026rdquo; suffix) is also the name of the class implementing the GUI. Therefore, it will need to be changed in order to conform to the naming convention for classes. To do this, right-click on its name in the Solution Explorer, and select \u0026ldquo;Rename\u0026rdquo; from the resulting popup menu. You will then be able to edit the name in the Solution Explorer. When you have entered the new name, the following window will be displayed:\nYou should click the \u0026ldquo;Yes\u0026rdquo; button in order to make the renaming consistent - particularly to rename the class as well.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/linked-lists/",
	"title": "Linked Lists",
	"tags": [],
	"description": "",
	"content": "Linked Lists Using arrays to implement data structures has performance advantages in some cases, but this technique has its limitations. With this chapter, we begin a study of data structures that use reference types in a powerful way. Rather than forming sequences by placing data items in adjacent cells of an array, we instead use references to chain data elements together in a sequence. For some applications, this ends up being more efficient than using an array. As we will see in a later chapter, this chaining technique can be further exploited to link data items in a hierarchical way, providing even more flexible and efficient access.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/advanced-text-file/",
	"title": "Advanced Text File I/O",
	"tags": [],
	"description": "",
	"content": "Advanced Text File I/O Though the File.ReadAllText and File.WriteAllText methods provide simple mechanisms for reading and writing text files, they are not always the best choices. For one reason, files can be very large \u0026mdash; too large to fit into memory, or possibly even larger than the maximum length of a string in C# (2,147,483,647 characters). Even when it is possible to store the entire contents of a file as a string, it may not be desirable, as the high memory usage may degrade the overall performance of the system.\nFor the purpose of handling a sequence of input or output data in more flexible ways, the .NET Framework provides streams. These streams are classes that provide uniform access to a wide variety of sequences of input or output data, such as files, network connections, other processes, or even blocks of memory. The StreamReader and StreamWriter classes (in the System.IO namespace) provide read and write, respectively, access to text streams, including text files.\nSome of the more useful public members of the StreamReader class are:\n A constructor that takes a string giving a file name as its only parameter and constructs a StreamReader to read from that file. A Read method that takes no parameters. It reads the next character from the stream and returns it as an int. If it cannot read a character because it is already at the end of the stream, it returns -1 (it returns an int because -1 is outside the range of char values). A ReadLine method that takes no parameters. It reads the next line from the stream and returns it as a string. If it cannot read a line because it is already at the end of the stream, it returns null. An EndOfStream property that gets a bool indicating whether the end of the stream has been reached.  With these members, we can read a text file either a character at a time or a line at a time until we reach the end of the file. The StreamWriter class has similar public members:\n A constructor that takes a string giving a file name as its only parameter and constructs a StreamWriter to write to this file. If the file already exists, it is replaced by what is written by the StreamWriter; otherwise, a new file is created. A Write method that takes a char as its only parameter. It writes this char to the end of the stream. Another Write method that takes a string as its only parameter. It writes this string to the end of the stream. A WriteLine method that takes no parameters. It writes a line terminator to the end of the stream (i.e., it ends the current line of text). Another WriteLine method that takes a char as its only parameter. It writes this char to the end of the stream, then terminates the current line of text. Yet another WriteLine method that takes a string as its only parameter. It writes this string to the end of the stream, then terminates the current line of text.  Thus, with a StreamWriter, we can build a text file a character at a time, a line at a time, or an arbitrary string at a time. In fact, a number of other Write and WriteLine methods exist, providing the ability to write various other types, such as int or double. In each case, the given value is first converted to a string, then written to the stream.\nStreams are different from other classes, such as strings or arrays, in that they are unmanaged resources. When a managed resource, such as a string or an array, is no longer being used by the program, the garbage collector will reclaim the space that it occupies so that it can be allocated to new objects that may need to be constructed. However, after a stream is constructed, it remains under the control of the program until the program explicitly releases it. This has several practical ramifications. For example, the underlying file remains locked, restricting how other programs may use it. In fact, if an output stream is not properly closed by the program, some of the data written to it may not actually reach the underlying file. This is because output streams are typically buffered for efficiency \u0026mdash; when bytes are written to the stream, they are first accumulated in an internal array, then written as a single block when the array is full. When the program is finished writing, it needs to make sure that this array is flushed to the underlying file.\nBoth the StreamReader and StreamWriter classes have Dispose methods to release them properly; however, because I/O typically requires exception handling, it can be tricky to ensure that this method is always called when the I/O is finished. Specifically, the try-catch may be located in a method that does not have access to the stream. In such a case, the catch-block cannot call the stream\u0026rsquo;s Dispose method.\n To handle this difficulty, C# provides a using statement. A using statement is different from a using directive, such as\nusing System.IO; A using statement occurs within a method definition, not at the top of a code file. Its recommended form is as follows:\nusing ( /* declaration and initialization of disposable variable(s) */ ) { /* Code that uses the disposable variables(s) */ } Thus, if we want to read and process a text file whose name is given by the string variable fileName, we could use the following code structure:\nusing (StreamReader input = new StreamReader(fileName)) { /* Code that reads and process the file accessed by the * StreamReader input */ } This declares the variable input to be of type StreamReader and initializes it to a new StreamReader to read the given file. This variable is only visible with the braces; furthermore, it is read-only \u0026mdash; its value cannot be changed to refer to a different StreamReader. The using statement then ensures that whenever control exits the code within the braces, input\u0026rsquo;s Dispose method is called.\nMore than one variable of the same type may be declared and initialized within the parentheses of a using statement; for example:\nusing (StreamReader input1 = new StreamReader(fileName1), input2 = new StreamReader(fileName2)) { /* Code that reads from input1 and input2 */ } The type of variable(s) declared must be a subtype of IDisposable. This ensures that the variables each have a Dispose method.\nAs a complete example of the use of a StreamReader and a StreamWriter, together with a using statement for each, suppose we want to write a method that takes as its parameters two strings giving the name of an input file and the name of an output file. The method is to reproduce the input file as the output file, but with each line prefixed by a line number and a tab. We will start numbering lines with 1. The following method accomplishes this:\n/// \u0026lt;summary\u0026gt; /// Copies the file at inFileName to outFileName with each line /// prefixed by its line number followed by a tab. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;inFileName\u0026#34;\u0026gt;The path name of the input file.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;outFileName\u0026#34;\u0026gt;The path name of the output file.\u0026lt;/param\u0026gt; private void AddLineNumbers(string inFileName, string outFileName) { using (StreamReader input = new StreamReader(inFileName)) { using (StreamWriter output = new StreamWriter(outFileName)) { int count = 0; while (!input.EndOfStream) { string line = input.ReadLine(); count++; output.Write(count); output.Write(\u0026#39;\\t\u0026#39;); // The tab character  output.WriteLine(line); } } } } We can call the above method within a try-block to handle any exceptions that may be thrown during the I/O. The catch-block will not have access to either input or output, but it doesn\u0026rsquo;t need it. If an exception is thrown during the I/O, the two using statements will ensure that the Dispose methods of both the StreamReader and the StreamWriter are called.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/comments/",
	"title": "Comments",
	"tags": [],
	"description": "",
	"content": "Comments Within each source code file that you edit, you will need to provide certain comments as documentation. Visual Studio® automatically generates some source code files that you will not need to modify \u0026mdash; you don\u0026rsquo;t need to add comments to those files.\nAt the top of each file in which you provide code, add a comment of the following form:\n/* filename.cs * Author: Name */ where filename.cs is the name of the file, and Name is the name of the primary author. The primary author will either be you or, for files provided for you, the name of the original author of that file. Whenever you use someone else\u0026rsquo;s code, it is important that you give them credit for it. (To fail to do this is plagiarism.) Thus, if one of your source files was originally written by Rod Howell, leave his name as the author. If you have modified a file originally written by someone else, below the Author line, insert a line of the following form:\n/* * Modified by: Your Name */ Prior to each class, structure, enumeration, field, property, and method, place a comment documenting its use. This comment should be delimited by /// on each line. When you type /// immediately above a class, structure, enumeration, field, property, or method, the IDE will automatically insert additional text to form a comment stub such as:\n/// \u0026lt;summary\u0026gt; /// /// \u0026lt;/summary\u0026gt; \u0026lt;summary\u0026gt; and \u0026lt;/summary\u0026gt; are XML tags, which are understood by the IDE. Between these tags, you should insert a summary of the program component you are documenting, including any requirements that must be satisfied by the calling code in order for the method to work properly. For example:\n/// \u0026lt;summary\u0026gt; /// Indicates whether this structure is empty. /// \u0026lt;/summary\u0026gt; private bool _isEmpty; If the program component being documented is a method with at least one parameter and/or a non-void return type, additional XML tags will be generated by the IDE. For each parameter, \u0026lt;param\u0026gt; and \u0026lt;/param\u0026gt; tags will be generated. You should insert a description of the use of that parameter between these tags. If the method has a non-void return type, \u0026lt;returns\u0026gt; and \u0026lt;/returns\u0026gt; tags are generated. You should insert an explanation of the value being returned between these tags. For example:\n/// \u0026lt;summary\u0026gt; /// Computes the number of times a given string x /// occurs within a given string y. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;x\u0026#34;\u0026gt;The string being searched for.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;y\u0026#34;\u0026gt;The string being searched.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The number of occurrences of x in y.\u0026lt;/returns\u0026gt; private int Occurrences(string x, string y) { }  Note\nYou do not need to fill in descriptions of the parameters for event handlers unless you use these parameters.\n Comments should also be used within methods to explain anything that is not obvious from the code itself.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/dialogs/custom/",
	"title": "Custom Dialogs",
	"tags": [],
	"description": "",
	"content": "Custom Dialogs While the dialogs provided by the .NET Framework are useful in a variety of applications, there are times when we need to be able to design our own special-purpose dialog to obtain specific information from the user. This section outlines how Visual Studio® can be used to build such a dialog.\nLet\u0026rsquo;s begin by considering a simple example. Suppose we are building an application that needs a dialog to obtain from the user the following pieces of information:\n a name; a phone number; and a number of siblings.  In order to keep the example simple, the program will simply display this information in its main window. Thus, the main window looks like this:\nClicking the \u0026ldquo;Get New Information\u0026rdquo; button will open our custom dialog, which will look like this:\nAfter the user enters the information, clicking \u0026ldquo;OK\u0026rdquo; will cause the information entered to be displayed in the main window. If the user clicks \u0026ldquo;Cancel\u0026rdquo;, the main window will be unchanged.\nAfter building the main form in Visual Studio\u0026rsquo;s Design Window, we can build the dialog by creating another form. To do this, in the Solution Explorer, right-click on the project name and select \u0026ldquo;Add-\u0026gt;Windows Form\u0026hellip;\u0026rdquo;. This will open a dialog for adding a new item, where the type of item is pre-selected to be a Windows Form. You will need to supply a name for the form. This name will serve as both a file name for a source file and the name of a class defined within this file. For example, we could choose the name, \u0026ldquo;InformationDialog.cs\u0026rdquo;, and the class will be named InformationDialog. Clicking the \u0026ldquo;Add\u0026rdquo; button will then open a new Design Window containing a form.\nWe can then use the Design Window to build this form as we would build any other form. In addition, the Button class has a DialogResult property that governs certain behavior when buttons are used within a dialog. This property is of type DialogResult. Setting it to a value other than None will cause the button to do the following when clicked, provided the form is displayed as a modal dialog:\n Close the form. Return the value of the DialogResult property.  Thus, we should set the \u0026ldquo;OK\u0026rdquo; button\u0026rsquo;s DialogResult property to OK and the \u0026ldquo;Cancel\u0026rdquo; button\u0026rsquo;s DialogResult property to Cancel. Once we have done this, there is no need to define any event handlers for these buttons.\nFurthermore, the Form itself has two properties that can be set to provide shortcuts for these buttons. The AcceptButton property, of type IButtonControl (a super-type of Button), can be used to cause the \u0026ldquo;Enter\u0026rdquo; key to activate a button on the form, as if that button had been clicked. Thus, we could set this property to the \u0026ldquo;OK\u0026rdquo; button. Similarly, the CancelButton property (also of type IButtonControl) can be used to cause the \u0026ldquo;Esc\u0026rdquo; key to activate a button on the form. We could therefore set this property to the \u0026ldquo;Cancel\u0026rdquo; button.\nWhile we don\u0026rsquo;t need any event handlers for this dialog, we still need to provide code to allow the class for the main window to access the values provided by the user. This can be accomplished with three public properties, one for each of the three pieces of information the user can provide:\n/// \u0026lt;summary\u0026gt; /// Gets the name. (There is already a Name property inherited from /// the Form class, so we will use FullName.) /// \u0026lt;/summary\u0026gt; public string FullName =\u0026gt; uxName.Text; /// \u0026lt;summary\u0026gt; /// Gets the phone number. /// \u0026lt;/summary\u0026gt; public string PhoneNumber =\u0026gt; uxPhoneNumber.Text; /// \u0026lt;summary\u0026gt; /// Gets the number of siblings. /// \u0026lt;/summary\u0026gt; public int Siblings =\u0026gt; (int)uxSiblings.Value; In order for the main window to be able to display this dialog, it needs to construct an instance of it. We can add to its class definition a private field initialized to such an instance:\n/// \u0026lt;summary\u0026gt; /// The dialog for obtaining information from the user. /// \u0026lt;/summary\u0026gt; private InformationDialog uxInformation = new InformationDialog(); Finally, we need an event handler for the \u0026ldquo;Get New Information\u0026rdquo; button. This event handler needs to display the InformationDialog as a modal dialog, and if the user closes it with the \u0026ldquo;OK\u0026rdquo; button, to copy the information provided by the user to the main window. A Form provides two methods for displaying it as a dialog:\n Show displays the Form as a non-modal dialog. It takes no parameters and returns nothing. ShowDialog displays the Form as a modal dialog. It takes no parameters and returns a DialogResult indicating how the user closed the dialog.  Thus, the event handler can display the dialog and retrieve its information much like it would do with a file dialog:\n/// \u0026lt;summary\u0026gt; /// Handles a Get New Information event. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void uxNew_Click(object sender, EventArgs e) { if (uxInformation.ShowDialog() == DialogResult.OK) { uxName.Text = uxInformation.FullName; uxPhoneNumber.Text = uxInformation.PhoneNumber; uxSiblings.Text = uxInformation.Siblings.ToString(); } } This git repository contains the complete program described above.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/dictionaries/",
	"title": "Dictionaries",
	"tags": [],
	"description": "",
	"content": "Dictionaries A common problem in computing is that of keyed storage and retrieval. Specifically, we have a number of data items, each having a unique key. This key may be any type, and is used to find the associated data item; i.e., given a key we need to find the data item associated with that key. A data structure that provides this kind of access is called a dictionary. In this chapter, we will examine a dictionary class provided by the .NET Framework. We will then consider two ways of implementing dictionaries. Later chapters will examine improvements over these implementations.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/equality/",
	"title": "Equality in C#",
	"tags": [],
	"description": "",
	"content": "Equality in C# Continuing our discussion from the previous section, we want to define a type that represents a Nim board. Furthermore, we need to be able to compare instances of this type for equality. Before we can address how this can be done, we first need to take a careful look at how C# handles equality. In what follows, we will discuss how C# handles the == operator, the non-static Equals method, and two static methods for determining equality. We will then show how the comparison can be defined so that all of these mechanisms behave in a consistent way.\nWe first consider the == operator. The behavior of this operator is determined by the compile-time types of its operands. This is determined by the declared types of variables, the declared return types of methods or properties, and the rules for evaluating expressions. Thus, for example, if we have a statement\nobject x = \u0026#34;abc\u0026#34;; the compile-time type of x is object, even though it actually refers to a string.\nFor pre-defined value types, == evaluates to true if its operands contain the same values. Because enumerations are represented as numeric types such as int or byte, this rule applies to them as well. For user-defined structures, == is undefined unless the structure definition explicitly defines the == and != operators. We will show how this can be done below.\nBy default, when == is applied to reference types, it evaluates to true when the two operands refer to the same object (i.e., they refer to the same memory location). A class may override this behavior by explicitly defining the == and != operators. For example, the string class defines the == operator to evaluate to true if the given strings are the same length and contain the same sequence of characters.\nLet\u0026rsquo;s consider an example that illustrates the rules for reference types:\nstring a = \u0026#34;abc\u0026#34;; string b = \u0026#34;0abc\u0026#34;.Substring(1); object x = a; object y = b; bool comp1 = a == b; bool comp2 = x == y; The first two lines assign to a and b the same sequence of characters; however, because the strings are computed differently, they are different objects. The next two lines copy the reference in a to x and the reference in b to y. Thus, at this point, all four variables refer to a string \u0026ldquo;abc\u0026rdquo;; however, a and x refer to a different object than do b and y. The fifth line compares a and b for equality using ==. The compile-time types of a and b are both string; hence, these variables are compared using the rules for comparing strings. Because they refer to strings of the same length and containing the same sequence of characters, comp1 is assigned true. The behavior of the last line is determined by the compile-time types of x and y. These types are both object, which defines the default behavior of this operator for reference types. Thus, the comparison determines whether the two variables refer to the same object. Because they do not, comp2 is assigned false.\nNow let\u0026rsquo;s consider the non-static Equals method. The biggest difference between this method and the == operator is that the behavior of x.Equals(y) is determined by the run-time type of x. This is determined by the actual type of the object, independent of how any variables or return types are declared.\nBy default, if x is a value type and y can be treated as having the same type, then x.Equals(y) returns true if x and y have the same value (if y can\u0026rsquo;t be treated as having the same type as x, then this method returns false). Thus, for pre-defined value types, the behavior is the same as for == once the types are determined (provided the types are consistent). However, the Equals method is always defined, whereas the == operator may not be. Furthermore, structures may override this method to change this behavior \u0026mdash; we will show how to do this below.\nBy default, if x is a reference type, x.Equals(y) returns true if x and y refer to the same object. Hence, this behavior is the same as for == once the types are determined (except that if x is null, x.Equals(y) will throw a NullReferenceException, whereas x == y will not). However, classes may override this method to change this behavior. For example, the string class overrides this method to return true if y is a string of the same length and contains the same sequence of characters as x.\nLet\u0026rsquo;s now continue the above example by adding the following lines:\nbool comp3 = a.Equals(b); bool comp4 = a.Equals(x); bool comp5 = x.Equals(a); bool comp6 = x.Equals(y); These all evaluate to true for one simple reason \u0026mdash; the behavior is determined by the run-time type of a in the case of the first two lines, or of x in the case of the last two lines. Because these types are both string, the objects are compared as strings.\nNote\nIt\u0026rsquo;s actually a bit more complicated in the case of comp3, but we\u0026rsquo;ll explain this later.\n The object class defines, in addition to the Equals method described above, two public static methods, which are in turn inherited by every type in C#:\n bool Equals(object x, object y): The main purpose of this method is to avoid the NullReferenceException that is thrown by x.Equals(y) when x is null. If neither x nor y is null, this method simply returns the value of x.Equals(y). Otherwise, it will return true if both x and y are null, or false if only one is null. User-defined types cannot override this method, but because it calls the non-static Equals method, which they can override, they can affect its behavior indirectly. bool ReferenceEquals(object x, object y): This method returns true if x and y refer to the same object or are both null. If either x or y is a value type, it will return false. User-defined types cannot override this method.  Finally, there is nothing to prevent user-defined types from including their own Equals methods with different parameter lists. In fact, the string class includes definitions of the following public methods:\n bool Equals(string s): This method actually does the same thing as the non-static Equals method defined in the object class, but is slightly more efficient because less run-time type checking needs to be done. This is the method that is called in the computation of comp3 in the above example. static bool Equals(string x, string y): This method does the same thing as the static Equals method defined in the object class, but again is slightly more efficient because less run-time type checking needs to be done.  All of this can be rather daunting at first. Fortunately, in most cases these comparisons end up working the way we expect them to. The main thing we want to focus on here is how to define equality properly in a user-defined type.\n Let\u0026rsquo;s start with the == operator. This is one of several operators that may be defined within class and structure definitions. If we are defining a class or structure called SomeType, we can include a definition of the == operator as follows:\npublic static bool operator ==(SomeType x, SomeType y) { // Definition of the behavior of == } Note the resemblance to the definition of a static method. Even though we define it using the syntax for a method definition, we still use it as we typically use the == operator; e.g.,\nif (a == b) { . . . } If a and b are both of type SomeType, the above definition will be called using a as the parameter x and b as the parameter y.\nWithin the operator definition, if it is within a class definition, the first thing we need to do is to handle the cases in which one or both parameters are null. We don\u0026rsquo;t need to do this for a structure definition because value types can\u0026rsquo;t be null, but if we omit this part for a reference type, comparing a variable or expression of this type to null will most likely result in a NullReferenceException. We need to be a bit careful here, because if we use == to compare one of the parameters to null it will be a recursive call \u0026mdash; infinite recursion, in fact. Furthermore, using x.Equals(null) is always a bad idea, as if x does, in fact, equal null, this will throw a NullReferenceException. We therefore need to use one of the static methods, Equals or ReferenceEquals:\npublic static bool operator ==(SomeType x, SomeType y) { if (Equals(x, null)) { return (Equals(y, null)); } else if (Equals(y, null)) { return false; } else { // Code to determine if x == y  } } Note that because all three calls to Equals have null as a parameter, these calls won\u0026rsquo;t result in calling the Equals method that we will override below.\nWhenever we define the == operator, C# requires that we also define the != operator. In virtually all cases, what we want this operator to do is to return the negation of what the == operator does:\npublic static bool operator !=(SomeType x, SomeType y) { return !(x == y); } We now turn to the (non-static) Equals method. This is defined in the object class to be a virtual method, meaning that sub-types are allowed to override its behavior. Because every type in C# is a subtype of object, this method is present in every type, and it can be overridden by any class or structure.\nWe override this method as follows:\npublic override bool Equals(object obj) { // Definition of the behavior of Equals } For the body of the method, we first need to take care of the fact that the parameter is of type object; hence, it may not even have the same type as what we want to compare it to. If this is the case, we can immediately return false. Otherwise, in order to ensure consistency between this method and the == operator, we can do the actual comparison using the == operator:\npublic override bool Equals(object obj) { if (obj is SomeType) { return this == (SomeType)obj; } else { return false; } } The above definitions give a template for defining the == and != operators and the non-static Equals method for most classes that we would want to compare for equality. For structures, we can remove the code that handles null parameters from the == definition. In either case, all we then need to do to complete the definitions is to replace the name SomeType, wherever it occurs, with the name of the type we are defining, and to fill in the hole left in the definition of the == operator. It is here where we actually define how the comparison is to be made.\nSuppose, for example, that we want to define a class to represent a Nim board position (see the previous section). This class will need to have two private fields: an int[ ] storing the number of stones on each pile and an int[ ] storing the limit for each pile. These two arrays should be non-null and have the same length, but this should be enforced by the constructor. By default, two instances of a class are considered to be equal (by either the == operator or the non-static Equals method) if they are the same object. This is too strong for our purposes; instead, two instances x and y of the board position class should be considered equal if\n Their arrays giving the number of stones on each pile have the same length; and For each indexi into the arrays giving the number of stones on each pile, the elements at location i of these arrays have the same value, and the elements at location i of the arrays giving the limit for each pile have the same value.  Code to make this determination and return the result can be inserted into the above template defining of the == operator, and the other two templates can be customized to refer to this type.\nAny class that redefines equality should also redefine the hash code computation to be consistent with the equality definition. We will show how to do this in the next section.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/graphs/impl/",
	"title": "Implementing a Graph",
	"tags": [],
	"description": "",
	"content": "Implementing a Graph Traditionally, there are two main techniques for implementing a graph. Each of these techniques has advantages and disadvantages, depending on the characteristics of the graph. In this section, we describe the implementation of the DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; class from Ksu.Cis300.Graphs.dll. This implementation borrows from both traditional techniques to obtain an implementation that provides good performance for any graph. In what follows, we will first describe the two traditional techniques and discuss the strengths and weaknesses of each. We will then outline the implementation of DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt;.\nThe first traditional technique is to use what we call an adjacency matrix. This matrix is an $n \\times n$ boolean array, where $n$ is the number of nodes in the graph. In this implementation, each node is represented by an int value $i$, where $0 \\leq i \\lt n$. The value at row $i$ and column $j$ will be true if there is an edge from node $i$ to node $j$.\nThe main advantage to this technique is that we can very quickly determine whether an edge exists \u0026mdash; we only need to look up one element in an array. There are several disadvantages, however. First, we are forced to use a specific range of int values as the nodes. If we wish to have a generic node type, we need an additional data structure (such as a Dictionary\u0026lt;TNode, int\u0026gt;) to map each node to its int representation. It also fails to provide a way to associate a value with an edge; hence, we would need an additional data structure (such as a TEdgeData[int, int]) to store this information.\nPerhaps the most serious shortcoming for the adjacency matrix, however, is that if the graph contains a large number of nodes, but relatively few edges, it wastes a huge amount of space. Suppose, for example, that we have a graph representing street information, and suppose there are about one million nodes in this graph. We might expect the graph to contain around three million edges. However, an adjacency matrix would require one trillion entries, almost all of which will be false. Similarly, finding the edges from a given node would require examining an entire row of a million elements to find the three or four outgoing edges from that node.\nThe other traditional technique involves using what we call adjacency lists. An adjacency list is simply a linked list containing descriptions of the outgoing edges from a single node. These lists are traditionally grouped together in an array of size $n$, where $n$ is again the number of nodes in the graph. As with the adjacency matrix technique, the nodes must be nonnegative ints less than $n$. The linked list at location $i$ of the array then contains the descriptions of the outgoing edges from node $i$.\nOne advantage to this technique is that the amount of space it uses is proportional to the size of the graph (i.e., the number of nodes plus the number of edges). Furthermore, obtaining the outgoing edges from a given node simply requires traversing the linked list containing the descriptions of these edges. Note also that we can store the data associated with an edge within the linked list cell describing that edge. However, this technique still requires some modification if we wish to use a generic node type. A more serious weakness, though, is that in order to determine if a given edge exists, we must search through potentially all of the outgoing edges from a given node. If the number of edges is large in comparison to the number of nodes, this search can be expensive.\nAs we mentioned above, our implementation of DirectedGraph\u0026lt;TNode, TEdgeData\u0026gt; borrows from both of these traditional techniques. We start by modifying the adjacency lists technique to use a Dictionary\u0026lt;TNode, LinkedListCell\u0026lt;TNode\u0026gt;\u0026gt; instead of an array of linked lists. Thus, we can accommodate a generic node type while maintaining efficient access to the adjacency lists. While a dictionary lookup is not quite as efficient as an array lookup, a dictionary would provide the most efficient way of mapping nodes of a generic type to int array indices. Using a dictionary instead of an array eliminates the need to do a subsequent array lookup. The linked list associated with a given node in this dictionary will then contain the destination node of each outgoing edge from the given node.\nIn addition to this dictionary, we use a Dictionary\u0026lt;(TNode, TNode), TEdgeData\u0026gt; to facilitate efficient edge lookups. The notation (T1, T2) defines a tuple, which is an ordered pair of elements, the first of type T1, and the second of type T2. Elements of this type are described with similar notation, (x, y), where x is of type T1 and y is of type T2. These elements can be accessed using the public properties Item1 and Item2. In general, longer tuples can be defined similarly.\nThis second dictionary essentially fills the role of an adjacency matrix, while accommodating a generic node type and using space more efficiently. Specifically, a tuple whose Item1 is u and whose Item2 is v will be a key in this dictionary if there is an edge from node u to node v. The value associated with this key will be the data associated with this edge. Thus, looking up an edge consists of a single dictionary lookup.\nThe two dictionaries described above are the only private fields our implementation needs. We will refer to them as _adjacencyLists and _edges, respectively. Because we can initialize both fields to new dictionaries, there is no need to define a constructor. Furthermore, given these two dictionaries, most of the public methods and properties (see “Introduction to Graphs”) can be implemented using a single call to one of the members of one of these dictionaries:\n void AddNode(TNode node): We can implement this method using the Add method of _adjacencyLists. We associate an empty linked list with this node. void AddEdge(TNode source, TNode dest, TEdgeData value): See below. bool TryGetEdge(TNode source, TNode dest, out TEdgeData value): We can implement this method using the TryGetValue method of _edges. int NodeCount: Because _adjacencyLists contains all of the nodes as keys, we can implement this property using this dictionary\u0026rsquo;s Count property. int EdgeCount: We can implement this property using the Count property of _edges. bool ContainsNode(TNode node): We can implement this method using the ContainsKey method of _adjacencyLists. bool ContainsEdge(TNode source, TNode dest): We can implement this method using the ContainsKey method of _edges. IEnumerable\u0026lt;TNode\u0026gt; Nodes: We can implement this property using the Keys property of _adjacencyLists. IEnumerable\u0026lt;Edge\u0026lt;TNode, TEdgeData\u0026gt;\u0026gt; OutgoingEdges(TNode source): See below.  Let\u0026rsquo;s now consider the implementation of the AddEdge method. Recall from “Introduction to Graphs” that this method adds an edge from source to dest with data item value. If either source or dest is not already in the graph, it will be added. If either source or dest is null, it will throw an ArgumentNullException. If source and dest are the same, or if the edge already exists in the graph, it will throw an ArgumentException.\nIn order to avoid changing the graph if the parameters are bad, we should do the error checking first. However, there is no need to check whether the edge already exists, provided we update _edges using its Add method, and that we do this before making any other changes to the graph. Because a dictionary\u0026rsquo;s Add method will throw an ArgumentException if the given key is already in the dictionary, it takes care of this error checking for us. The key that we need to add will be a (TNode, TNode) containing the two nodes, and the value will be the value.\nAfter we have updated _edges, we need to update _adjacencyLists. To do this, we first need to obtain the linked list associated with the key source in _adjacencyLists; however, because source may not exist as a key in this dictionary, we should use the TryGetValue method to do this lookup (note that if source is not a key in this dictionary, the out parameter will be set to null, which we can interpret as an empty list). We then construct a new linked list cell, in which we place dest. We then insert this cell at the beginning of the linked list we retrieved, and set this linked list as the new value associated with source in _adjacencyLists. Finally, if _adjacencyLists doesn\u0026rsquo;t already contain dest as a key, we need to add it with null as its associated value.\nFinally, we need to implement the OutgoingEdges method. Because this method returns an IEnumerable\u0026lt;Edge\u0026lt;TNode, TEdgeData\u0026gt;\u0026gt;, it needs to iterate through the cells of the linked list associated with the given node in _adjacencyLists. For each of these cells, it will need to yield return (see \u0026ldquo;Enumerators\u0026quot;) an Edge\u0026lt;TNode, TEdgeData\u0026gt; describing the edge represented by that cell. The source node for this edge will be the node given to this method. The destination node will be the node stored in the cell. The edge data can be obtained from the dictionary _edges.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl/",
	"title": "Implementing a Stack",
	"tags": [],
	"description": "",
	"content": "Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack\u0026lt;T\u0026gt; use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of objects and generic stacks. We will focus on implementing a generic stack in this section, as it is easy to modify such an implementation to be non-generic.\n We first need to consider how to define a generic class. In the simplest case, we simply add a type parameter to the class statement, as follows:\npublic class Stack\u0026lt;T\u0026gt; { . . . } Within this class definition, T is treated like any other type, except that the compiler knows nothing about it. We can declare fields, parameters, and local variables to be of type T. Even though the compiler knows nothing about T, it will still do type checking - you cannot assign an expression of any other type to a variable of type T, and you can only assign an expression of type T to variables of either type T or type object (because any type is a subtype of object). In general, we can define generic data types with any number of type parameters if more that one generic type is needed by the data structure. To do this, we would list the type parameters, separated by commas, between the \u0026lt; and \u0026gt; symbols of the generic class definition. Each of the type parameters is then treated as a type within the class definition. We will show how the types passed as type parameters can be restricted in a later section.\nFor the class Stack\u0026lt;T\u0026gt;, only one type parameter is needed. The type parameter T denotes the type of the values that are stored in the stack. Therefore, the array in which we will store the elements will be of type T[ ]. As in the StringBuilder implementation, we will need a private field for this array. This field can be initialized in a manner similar to the StringBuilder implementation; hence, we don\u0026rsquo;t need to write a constructor.\nA stack has a public read-only property, Count, which gets the number of elements in the stack (as an int). We can define this property to use the default implementation with a private set accessor, as outlined in the section, \u0026ldquo;Properties\u0026rdquo;.\nBefore we can delve any further into the implementation, we need to decide how we are going to arrange the elements in the array. Because all of our accesses will be to the top of the stack, it makes sense to keep the bottom element of the stack at location 0, and as we go up the stack, keep each successive element in the next location:\nThis arrangement makes sense because unless all of the array locations are being used, there is room to push a new element on top of the stack without having to move any pre-existing elements out of its way.\nNote the similarity of this arrangement to the implementation of a StringBuilder. Given this similarity, we can implement the Push method in a similar way to how we implemented the Append method for a StringBuilder. Instead of taking a char parameter, the Push method takes a T parameter, but this is the type that we can store in the array. The biggest difference in these two methods is that while Append returns a StringBuilder, Push returns nothing.\nWe now need to implement the public methods that retrieve elements from the stack. We will start with the Peek method, which takes no parameters and returns a T. This method needs to begin with some error checking: if there are no elements in the stack, it needs to throw an InvalidOperationException. We can do this by constructing such an exception and throwing it with the throw keyword:\nthrow new InvalidOperationException(); If there are elements in the stack, we need to return the one at the top. Note from the figure above that the top element is at the location preceding the location indexed by Count.\nThe other public method to retrieve an element is the Pop method. This method also takes no parameters and returns a T. Part of what it does we have already implemented in the Peek method. In order to avoid duplicating code, we can retrieve the top element using the Peek method, and save it in a local variable so that we can return it when we are finished with this method (avoiding code duplication improves maintainability, as there are fewer places that might need to be modified later). Note that by using the Peek method, we are taking advantage of the fact that it checks whether the stack is empty; hence, there is no need to do that here. Before we can return the value we retrieved, we need to update Count to reflect the fact that we are removing one element.\nWhile what we have described in the preceding paragraph is sufficient for correct functioning, there is one issue we need to address. Note that we have done nothing to the array location that stored the value we popped - it still stores that value. This fact does not impact correctness, however, because after we update the number of elements, we are no longer considering that location to be storing a stack element - its contents are irrelevant. However, there is a performance issue here. If T is a reference type, then the reference stored in this location may refer to a large data structure that is no longer needed by the program. However, because this array still stores a reference to it, the garbage collector cannot tell that it is no longer in use, and consequently, it cannot reclaim the storage.\n\nIt therefore makes sense to remove what is stored in this array location. However, we run into a difficulty when we try to do this. We can\u0026rsquo;t simply assign null to this location because T might be a value type; hence, the compiler will not allow such an assignment. In order to address this problem, C# has the keyword, default, which can be used to get the default value for a given type. Thus, if T is a reference type, default(T) will give us null, but if T is a value type, it will give us the value whose binary representation is all 0s. In order to free up any memory we might no longer need, it therefore makes sense to assign default(T) to an array location after we are no longer using it.\nTip\nOften the parameter to default (including the parentheses) can be omitted because the compiler can detect what type is needed. This is the case in the current context. If using default without the parameter gives a syntax error, supply the parameter.\n Finally, we can implement a public Clear method. This method takes no parameters and returns nothing. One way to implement it would be to pop all of the elements, one by one, from the stack. However, this could be very inefficient if the stack contains a lot of elements. A better way is simply to change Count to 0; however, this way prevents the garbage collector from reclaiming storage we no longer need. In order to allow this storage to be reclaimed, we should also replace our array with a new array of the size we used when we initialized this field (note that this is more efficient than replacing every element with the default element of the appropriate type). Because we are no longer using the old array, the garbage collector can reclaim it, along with any otherwise unused data it might refer to.\nDue to the similarities between this implementation and the StringBuilder implementation, the two data structures have similar performance characteristics. In fact, it is possible to show that any sequence of n operations on an initially empty Stack\u0026lt;T\u0026gt; is done in O(n) time - i.e., in time proportional to n.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/bst/inorder/",
	"title": "Inorder Traversal",
	"tags": [],
	"description": "",
	"content": "Inorder Traversal When we store keys and values in an ordered dictionary, we typically want to be able to process the keys in increasing order. The \u0026ldquo;processing\u0026rdquo; that we do may be any of a number of things - for example, writing the keys and values to a file or adding them to the end of a list. Whatever processing we want to do, we want to do it increasing order of keys.\nIf we are implementing the dictionary using a binary search tree, this may at first seem to be a rather daunting task. Consider traversing the keys in the following binary search tree in increasing order:\nProcessing these keys in order involves frequent jumps in the tree, such as from 17 to 23 and from 41 to 54. It may not be immediately obvious how to proceed. However, if we just think about it with the purpose of writing a recursive method, it actually becomes rather straightforward.\nAs with most tree-processing algorithms, if the given tree is nonempty, we start at the root (if it is empty, there are no nodes to process). However, the root isn\u0026rsquo;t necessarily the first node that we want to process, as there may be keys that are smaller than the one at the root. These key are all in the left child. We therefore want to process first all the nodes in the left child, in increasing order of their keys. This is a smaller instance of our original problem - a recursive call on the left child solves it. At this point all of the keys less than the one at the root have been processed. We therefore process the root next (whatever the \u0026ldquo;processing\u0026rdquo; might be). This just leaves the nodes in the right child, which we want to process in increasing order of their keys. Again, a recursive call takes care of this, and we are finished.\nThe entire algorithm is therefore as follows:\n If the given tree is nonempty:  Do a recursive call on the left child to process all the nodes in it. Process the root. Do a recursive call on the right child to process all the nodes in it.    This algorithm is known as an inorder traversal because it processes the root between the processing of the two children. Unlike preorder traversal, this algorithm only makes sense for binary trees, as there must be exactly two children in order for \u0026ldquo;between\u0026rdquo; to make sense.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/split/",
	"title": "Split Sorts",
	"tags": [],
	"description": "",
	"content": "Split Sorts A split sort operates by splitting the array into three parts:\n An unsorted part containing elements less than or equal to some pivot element p. A nonempty part containing elements equal to p. An unsorted part containing elements greater than or equal to p.  This arrangement is illustrated in the following figure.\nTo complete the sort, it then sorts the two unsorted parts. Note that because the second part is nonempty, each of the two unsorted parts is smaller than the original data set; hence, the algorithm will always make progress.\nThe various implementations of a split sort are collectively known as quick sort. They differ in how many elements are placed in the middle part (only one element or all elements equal to the pivot), how the pivot is chosen, how the elements are partitioned into three parts, and how the two sub-problems are sorted. We will examine only two variations, which differ in how the pivot element is chosen.\nLet\u0026rsquo;s start with how we do the partitioning. Let p denote the pivot element. Because most of the split sort implementations use recursion to complete the sort, we\u0026rsquo;ll assume that we are sorting a portion of an array. At each stage of the partitioning, the array portion we are sorting will be arranged into the following four segments:\n Segment L: Elements less than p. Segment U: Elements we haven\u0026rsquo;t yet examined (i.e., unknown elements). Segment E: Elements equal to p. Segment G: Elements greater than p.  Initially, segments L, E, and G will be empty, and each iteration will reduce the size of segment U. The partitioning will be finished when segment U is empty. We will need three local variables to keep track of where one segment ends and another segment begins, as shown in the following figure:\nWe have worded the descriptions of the three local variables so that they make sense even if some of the segments are empty. Thus, because all segments except U are initially empty, the location following segment L will initially be the first location in the array portion that we are sorting, and the other two variables will initially be the last location in this portion. We then need a loop that iterates as long as segment U is nonempty \u0026mdash; i.e., as long as the location following segment L is no greater than the location preceding segment E. Each iteration of this loop will compare the last element in segment U (i.e., the element at the location preceding segment E) with p. We will swap this element with another depending on how it compares with p:\n If it is less than p, we swap it with the element following segment L, and adjust the end of segment L to include it. If it is equal to p, we leave it where it is, and adjust the beginning of segment E to include it. If it is greater than p, we swap it with the element preceding segment G, adjust the beginning of segment G to include it, and adjust the beginning of segment E to account for the fact that we are shifting this segment to the left by 1.  Once this loop completes, the partitioning will be done. Furthermore, we can determine the two parts that need to be sorted from the final values of the local variables.\nThe first split sort implementation we will consider is fairly straightforward, given the above partitioning scheme. If we are sorting more than one element (otherwise, there is nothing to do), we will use as the pivot element the first element of the array portion to be sorted. After partitioning, we then sort the elements less than the pivot using a recursive call, and sort the elements greater than the pivot with another.\nThough we won\u0026rsquo;t give an analysis here, the above algorithm runs in $O(n^2)$ time in the worst case, where $n$ is the number of elements being sorted. However, as we saw with insertion sort, the worst-case running time doesn\u0026rsquo;t always tell the whole story. Specifically, the expected running time of quick sort (this implementation and others) on random arrays is in $O(n \\lg n)$.\nHowever, we don\u0026rsquo;t often need to sort random data. Let\u0026rsquo;s therefore take a closer look at what makes the worst case bad. In some ways this algorithm is like merge sort \u0026mdash; it does two recursive calls, and the additional work is proportional to the number of elements being sorted. The difference is that the recursive calls in merge sort are both on array portions that are about half the size of the portion being sorted. With this quick sort implementation, on the other hand, the sizes of the recursive calls depend on how the first element (i.e., the pivot element) compares to the other elements. The more elements that end up in one recursive call, the slower the algorithm becomes. Consequently, the worst case occurs when the array is already sorted, and is still bad if the array is nearly sorted. For this reason, this is a particularly bad implementation.\nBefore we look at how we can improve the performance, we need to consider one other aspect of this implementation\u0026rsquo;s performance. For a recursive method, the amount of data pushed on the runtime stack is proportional to the depth of the recursion. In the worst cases (i.e., on a sorted array), the recursion depth is $n$. Thus, for large $n$, if the array is sorted or nearly sorted, a StackOverflowException is likely. \nThe most important thing we can do to improve the performance, in terms of both running time and stack usage, is to be more careful about how we choose the pivot element. We want to choose an element that partitions the data elements roughly in half. The median element (i.e., the element that belongs in the middle after the array is sorted) will therefore give us the optimal split. It is possible to design an $O(n \\lg n)$ algorithm that uses the median as the pivot; however, the time it takes to find the median makes this algorithm slower than merge sort in practice. It works much better to find a quick approximation for the median.\nThe main technique for obtaining such an approximation is to examine only a few of the elements. For example, we can use median-of-three partitioning, which uses as its pivot element the median of the first, middle, and last elements of the array portion we are sorting. An easy way to implement this strategy is to place these three elements in an array of size 3, then sort this array using insertion sort. The element that ends up at location 1 is then the used as the pivot.\nWe can improve on the above strategy by doing a case analysis of the three values. If we do this, we don\u0026rsquo;t need a separate array \u0026mdash; we just find the median of three values, $a$, $b$, and $c$, as follows:\n If $a \\lt b$:  If $b \\lt c$, then $b$ is the median. Otherwise, because $b$ is the largest:  If $a \\lt c$, then $c$ is the median. Otherwise, $a$ is the median.     Otherwise, because $b \\leq a$:  If $a \\lt c$, then $a$ is the median. Otherwise, because $a$ is the largest:  If $b \\lt c$, then $c$ is the median. Otherwise, $b$ is the median.      The above algorithm is quite efficient, using at most three comparisons and requiring no values to be copied other than the result if we implement it in-line, rather than as a separate method (normally an optimizing compiler can do this method inlining for us). It also improves the sorting algorithm by tending to make the bad cases less likely.\nThis version of quick sort gives good performance most of the time, typically outperforming either heap sort or merge sort. However, it still has a worst-case running time in $O(n^2)$ and a worst-case stack usage in $O(n)$. Furthermore, it is unstable and does not perform as well as insertion sort on small or nearly sorted data sets. In the next section, we will show how quick sort can be combined with some of the other sorting algorithms to address some of these issues, including the bad worst-case performance.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/decimals/",
	"title": "The decimal Type",
	"tags": [],
	"description": "",
	"content": "The decimal Type A decimal is a structure representing a floating-point decimal number. The main difference between a decimal and a float or a double is that a decimal can store any value that can be written using no more than 28 decimal digits, a decimal point, and optionally a \u0026lsquo;-\u0026rsquo;, without rounding. For example, the value 0.1 cannot be stored exactly in either a float or a double because its binary representation is infinite (0.000110011\u0026hellip;); however, it can be stored exactly in a decimal. Various types, such as int, double, or string, may be converted to a decimal using a Convert.ToDecimal method; for example, if i is an int, we can convert it to a decimal with:\ndecimal d = Convert.ToDecimal(i); A decimal is represented internally with the following three components:\n A 96-bit value v storing the digits (0 ≤ v ≤ 79,228,162,514,264,337,593,543,950,335). A sign bit s, where 1 denotes a negative value. A scale factor d to indicate where the decimal point is (0 ≤ d ≤ 28).  The value represented is then (-1)sv/10d. For example, 123.456 can be represented by setting v to 123,456, s to 0, and d to 3.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/design-window/",
	"title": "The Design Window",
	"tags": [],
	"description": "",
	"content": "The Design Window The Design Window in Visual Studio is a window used to build graphical components. To open the Design Window for a graphical component, double-click on the component\u0026rsquo;s file name in the Solution Explorer. If you are working through the example from the previous two sections, double-click \u0026ldquo;UserInterface.cs\u0026rdquo; to open its Design Window. It will initially contain a blank form:\nYou can resize the form by dragging the handles on the right and bottom edges. You can also change the title of the form (\u0026ldquo;Form1\u0026rdquo; in the picture above) as follows:\n  Click on the form.\n  Open its Properties window by clicking on the \u0026ldquo;Properties\u0026rdquo; tab at the right, below the \u0026ldquo;Solution Explorer\u0026rdquo; tab (if you don\u0026rsquo;t see this tab, you can always get to this window from the \u0026ldquo;View\u0026rdquo; menu).\n  Look at the row of buttons near the top of the properties window, and make sure the second and third button are highlighted:\nIf either of these buttons isn\u0026rsquo;t highlighted, click it to highlight it. The first two buttons on this row toggle whether the information is arranged by category (the first button) or alphabetically (the second button). The next two buttons toggle whether the control\u0026rsquo;s properties (the third button) or events (the fourth button \u0026mdash; we\u0026rsquo;ll discuss these below) are shown.\n  Find \u0026ldquo;Text\u0026rdquo; in the left column of the Properties window - it will probably be highlighted. Click on the space to its right, and edit the text to give your desired title. If you are working through the example, give it a title of \u0026ldquo;Hello\u0026rdquo;.\n  For example, after resizing and changing the title, we might have a form that looks like this:\nTo add various graphical controls to the form, we use the Toolbox, which is normally available via a tab on the left edge (if not, you can always access it via the \u0026ldquo;View\u0026rdquo; menu). For example, let\u0026rsquo;s add a box that will contain text generated by the program. We open the Toolbox and click on the TextBox control, which can be found in the \u0026ldquo;Common Controls\u0026rdquo; section. We can then click on the design window (outside of the form) to bring it to the front, and drag an area on the form that we would like the TextBox to fill. After doing so, there will be a handle on the right and left edges to allow horizontal resizing (don\u0026rsquo;t worry about vertical resizing yet). You can also drag the TextBox to adjust its location. If you do this, as the edges of the TextBox approach the edges of the frame, struts will appear, helping you to leave an appropriate margin.\nAfter adding a control, we usually need to customize it to some degree. To do this, click on it, then open the Properties window again. This window will now display the properties of the TextBox. The first property we will always want to change is the name of the variable that the program will use to refer to this control. This property is called \u0026ldquo;(Name)\u0026rdquo;, and will be near the top. You will need to change this name so that it follows the naming convention for controls on forms.\nThere are various properties that can be changed to customize the appearance and behavior of a control. For example, we can change the font of a TextBox by changing its Font property. This in turn will affect the height of the TextBox. We can prevent the user from editing it by setting its ReadOnly property to True. If we want to allow multiple lines, we can set its Multiline property to True. This in turn will add handles to the top and bottom edges so that we can adjust its height. All of the properties of a GUI control are documented in that control\u0026rsquo;s API documentation within the .NET API browser.\nThus, continuing the above example, if we modify the TextBox\u0026rsquo;s variable name to uxDisplay, its Font property to Microsoft Sans Serif, 12pt and its ReadOnly property to True, we would have the following form:\nUsing a similar process, we can now add a Button to the form and name it uxGo. To change the text in the Button, we will need to change its Text property. This might give us the following:\nNow that we have a Button on our form, it would be appropriate to provide some functionality for that Button. Clicking on a Button signals an event to which our program may respond. In order to cause our program to respond to such an event, we need to provide an event handler for it. Because a mouse click is the default event for a Button, we can create an event handler for this event by simply double-clicking on the Button. Doing so will open a code window containing the contents of the source code file defining the current form. Furthermore, if the name of the Button is uxGo, the following method will have been added:\nprivate void uxGo_Click(object sender, EventArgs e) { } This method will be called whenever the Button is clicked (code causing this behavior will have been automatically added to the file containing the automatically-generated code for the form). Thus, to provide the appropriate functionality for the Button we just need to add code providing this functionality to this method. We will discuss this in more detail in the next section.\nBefore we leave the design window entirely, however, we need to talk about a more general way of accessing the event handlers associated with controls. Going back to the Properties window for a control, clicking the fourth button in the row of buttons near the top (the one that looks like a lightning bolt) will cause all of the possible events for that control to be displayed, and any event handler that has been created for that event. For example, if we have created the event handler described above, then the list of events for the Button looks like this:\nThis list is useful for two reasons. The more obvious reason is that we sometimes might want to handle an event that is not the default event for a control. For example, we might want a Button to react in some way (perhaps by changing color, for example) whenever the mouse enters or leaves it. In order to implement this functionality, we would need event handlers for the MouseEnter and MouseLeave events. We can add these event handlers by double-clicking these events in this list.\nThe less obvious use for this list is to remove an event handler. Often we find that we have added an event handler that we don\u0026rsquo;t need, perhaps by double-clicking in the wrong place. When this happens, shouldn\u0026rsquo;t just delete the code, because there is other automatically-generated code that refers to it. Deleting the code for an event handler would therefore lead to a syntax error. Instead, the proper way to remove an event handler is to go to the list of events, right-click on the name of the event, and select \u0026ldquo;Reset\u0026rdquo; from the resulting popup menu. This safely deletes the code and all automatically-generated references to it. (Sometimes it doesn\u0026rsquo;t delete the code, but if not, it is now safe to delete it.)\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/design-window/",
	"title": "The Design Window",
	"tags": [],
	"description": "",
	"content": "The Design Window The Design Window in Visual Studio is a window used to build graphical components. To open the Design Window for a graphical component, double-click on the component\u0026rsquo;s file name in the Solution Explorer. If you are working through the example from the previous two sections, double-click \u0026ldquo;UserInterface.cs\u0026rdquo; to open its Design Window. It will initially contain a blank form:\nYou can resize the form by dragging the handles on the right and bottom edges. You can also change the title of the form (\u0026ldquo;Form1\u0026rdquo; in the picture above) as follows:\n  Click on the form.\n  If the Properties window isn\u0026rsquo;t showing on the right, select \u0026ldquo;Properties Window\u0026rdquo; from the \u0026ldquo;View\u0026rdquo; menu.\n  Look at the row of buttons near the top of the properties window, and make sure the second and third button are highlighted:\nIf either of these buttons isn\u0026rsquo;t highlighted, click it to highlight it. The first two buttons on this row toggle whether the information is arranged by category (the first button) or alphabetically (the second button). The next two buttons toggle whether the control\u0026rsquo;s properties (the third button) or events (the fourth button \u0026mdash; we\u0026rsquo;ll discuss these below) are shown.\n  Find \u0026ldquo;Text\u0026rdquo; in the left column of the Properties window - it will probably be highlighted. Click on the space to its right, and edit the text to give your desired title. If you are working through the example, give it a title of \u0026ldquo;Hello\u0026rdquo;.\n  For example, after resizing and changing the title, we might have a form that looks like this:\nTo add various graphical controls to the form, we use the Toolbox, which is normally available via a tab on the left edge (if not, you can always access it via the \u0026ldquo;View\u0026rdquo; menu). For example, let\u0026rsquo;s add a box that will contain text generated by the program. We open the Toolbox and click on the TextBox control, which can be found in the \u0026ldquo;Common Controls\u0026rdquo; section. We can then click on the design window (outside of the form) to bring it to the front, and drag an area on the form that we would like the TextBox to fill. After doing so, there will be a handle on the right and left edges to allow horizontal resizing (don\u0026rsquo;t worry about vertical resizing yet). You can also drag the TextBox to adjust its location. If you do this, as the edges of the TextBox approach the edges of the frame, struts will appear, helping you to leave an appropriate margin.\nAfter adding a control, we usually need to customize it to some degree. To do this, click on it, then open the Properties window again. This window will now display the properties of the TextBox. The first property we will always want to change is the name of the variable that the program will use to refer to this control. This property is called \u0026ldquo;(Name)\u0026rdquo;, and will be near the top. You will need to change this name so that it follows the naming convention for controls on forms.\nThere are various properties that can be changed to customize the appearance and behavior of a control. For example, we can change the font of a TextBox by changing its Font property. This in turn will affect the height of the TextBox. We can prevent the user from editing it by setting its ReadOnly property to True. If we want to allow multiple lines, we can set its Multiline property to True. This in turn will add handles to the top and bottom edges so that we can adjust its height. All of the properties of a GUI control are documented in that control\u0026rsquo;s API documentation within the .NET API browser.\nThus, continuing the above example, if we modify the TextBox\u0026rsquo;s variable name to uxDisplay, its Font property to Microsoft Sans Serif, 12pt and its ReadOnly property to True, we would have the following form:\nUsing a similar process, we can now add a Button to the form and name it uxGo. To change the text in the Button, we will need to change its Text property. This might give us the following:\nNow that we have a Button on our form, it would be appropriate to provide some functionality for that Button. Clicking on a Button signals an event to which our program may respond. In order to cause our program to respond to such an event, we need to provide an event handler for it. Because a click is the default event for a Button, we can create an event handler for this event by simply double-clicking on the Button. Doing so will open a code window containing the contents of the source code file defining the current form. Furthermore, if the name of the Button is uxGo, the following method will have been added:\nprivate void uxGo_Click(object sender, EventArgs e) { } This method will be called whenever the Button is clicked (code causing this behavior will have been automatically added to the file containing the automatically-generated code for the form). Thus, to provide the appropriate functionality for the Button we just need to add code providing this functionality to this method. We will discuss this in more detail in the next section.\nBefore we leave the design window entirely, however, we need to talk about a more general way of accessing the event handlers associated with controls. Going back to the Properties window for a control, clicking the fourth button in the row of buttons near the top (the one that looks like a lightning bolt) will cause all of the possible events for that control to be displayed, and any event handler that has been created for that event. For example, if we have created the event handler described above, then the list of events for the Button looks like this:\nThis list is useful for two reasons. The more obvious reason is that we sometimes might want to handle an event that is not the default event for a control. For example, we might want a Button to react in some way (perhaps by changing color, for example) whenever the mouse enters or leaves it. In order to implement this functionality, we would need event handlers for the MouseEnter and MouseLeave events. We can add these event handlers by double-clicking these events in this list.\nThe less obvious use for this list is to remove an event handler. Often we find that we have added an event handler that we don\u0026rsquo;t need, perhaps by double-clicking in the wrong place. When this happens, shouldn\u0026rsquo;t just delete the code, because there is other automatically-generated code that refers to it. Deleting the code for an event handler would therefore lead to a syntax error. Instead, the proper way to remove an event handler is to go to the list of events, right-click on the name of the event, and select \u0026ldquo;Reset\u0026rdquo; from the resulting popup menu. This safely deletes the code and all automatically-generated references to it. (Sometimes it doesn\u0026rsquo;t delete the code, but if not, it is now safe to delete it.)\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/tries/",
	"title": "Tries",
	"tags": [],
	"description": "",
	"content": "Tries AVL trees give us an efficient mechanism for storage and retrieval, particularly if we need to be able to process the elements in order of their keys. However, there are special cases where we can achieve better performance. One of these special cases occurs when we need to store a list of words, as we might need in a word game, for example. For such applications, a trie provides for even more efficient storage and retrieval.\nIn this section, we first define a trie and give a rather straightforward implementation. We then show how to improve performance by implementing different nodes in different ways. We then examine the use of a preorder traversal to traverse a trie. We conclude by discussing an example of using a trie in a word game.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/tries/word-games/",
	"title": "Tries in Word Games",
	"tags": [],
	"description": "",
	"content": "Tries in Word Games One application of tries is for implementing word games such as Boggle® or Scrabble®. This section discusses how a trie can be used to reduce dramatically the amount of time spent searching for words in such games. We will focus specifically on Boggle, but the same principles apply to other word games as well.\nA Boggle game consists of either 16 or 25 dice with letters on their faces, along with a tray containing a 4 x 4 or 5 x 5 grid for holding these dice. The face of each die contains a single letter, except that one face of one die contains \u0026ldquo;Qu\u0026rdquo;. The tray has a large cover such that the dice can be placed in the cover and the tray placed upside-down on top of the cover. The whole thing can then be shaken, then inverted so that each die ends up in a different grid cell, forming a random game board such as:\nPlayers are then given a certain amount of time during which they compete to try to form as many unique words as they can from these letters. The letters of a word must be adjacent either horizontally, vertically, or diagonally, and no die may be used more than once in a single word. There is a minimum word length, and longer words are worth more points. For example, the above game board contains the words, \u0026ldquo;WITCH\u0026rdquo;, \u0026ldquo;ITCH\u0026rdquo;, \u0026ldquo;PELLET\u0026rdquo;, \u0026ldquo;TELL\u0026rdquo;, and \u0026ldquo;DATA\u0026rdquo;, among many others.\nSuppose we want to build a program that plays Boggle against a human opponent. The program would need to look for words on a given board. The dictionary of words can of course be stored in a trie. In what follows, we will show how the structure of a trie can be particularly helpful in guiding this search so that words are found more quickly.\nWe can think of a search from a given starting point as a traversal of a tree. The root of the tree is the starting point, and its children are searches starting from adjacent dice. We must be careful, however, to include in such a tree only those adjacent dice that do not already occur on the path to the given die. For example, if we start a search at the upper-left corner of the above board, its children would be the three adjacent dice containing \u0026ldquo;I\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, and \u0026ldquo;A\u0026rdquo;. The children of \u0026ldquo;I\u0026rdquo;, then, would not include \u0026ldquo;H\u0026rdquo; because it is already on the path to \u0026ldquo;I\u0026rdquo;. Part of this tree would look like this:\nNote that this tree is not a data structure - it need not be explicitly stored anywhere. Rather, it is a mathematical object that helps us to design an algorithm for finding all of the words. Each word on the board is simply a path in this tree starting from the root. We can therefore traverse this tree in much the same way as we outlined in the previous section for tries. For each node in the tree, we can look up the path leading to that node, and output it if it is a word in the dictionary.\nIn order to be able to implement such a traversal, we need to be able to find the children of a node. These children are the adjacent cells that are not used in the path to the node. An efficient way to keep track of the cells used in this path is with a bool[ , ] of the same size as the Boggle board - a value of true in this array will indicate that the corresponding cell on the board has been used in the current path. The children of a node are then the adjacent cells whose entries in this array are false.\nA preorder traversal of this tree will therefore need the following parameters (and possibly others, depending on how we want to output the words found):\n The row index of the current cell. The column index of the current cell. The bool[ , ] described above. The current cell will have a false entry in this array. A StringBuilder giving the letters on the path up to, but not including, the current cell.  The preorder traversal will first need to update the cells used by setting the location corresponding to the current cell to true. Likewise, it will need to update the StringBuilder by appending the contents of the current cell. Then it will need to process the root by looking up the contents of the StringBuilder - if this forms a word, it should output this word. Then it should process the children: for each adjacent cell whose entry in the bool[ , ] is false, it should make a recursive call on that cell. After all the children have been processed, it will need to return the bool[ , ] and the StringBuilder to their earlier states by setting the array entry back to false and removing the character(s) appended earlier.\nOnce such a method is written, we can call it once for each cell on the board. For each of these calls, all entries in the bool[ , ] should be false, and the StringBuilder should be empty.\nWhile the algorithm described above will find all the words on a Boggle board, a 5 x 5 board will require quite a while for the algorithm to process. While this might be acceptable if we are implementing a game that humans can compete with, from an algorithmic standpoint, we would like to improve the performance. (In fact, there are probably better ways to make a program with which humans can compete, as this search will only find words that begin near the top of the board.)\nWe can begin to see how to improve the performance if we observe the similarity between the trees we have been discussing and a trie containing the word list. Consider, for example, a portion of the child labeled \u0026lsquo;h\u0026rsquo; in a trie representing a large set of words:\nWe have omitted some of the children because they are irrelevant to the search we are performing (e.g., there is no die containing \u0026ldquo;E\u0026rdquo; adjacent to \u0026ldquo;H\u0026rdquo; on the above game board). Also, we are assuming a minimum word length of 4; hence, \u0026ldquo;ha\u0026rdquo;, \u0026ldquo;hi\u0026rdquo;, and \u0026ldquo;hit\u0026rdquo; are not shown as words in this trie.\nNotice the similarity between the trie portion shown above and the tree shown earlier. The root of the tree has children representing dice containing \u0026ldquo;I\u0026rdquo; and \u0026ldquo;A\u0026rdquo;, and the former node has children representing dice containing \u0026ldquo;T\u0026rdquo;, \u0026ldquo;C\u0026rdquo;, and \u0026ldquo;A\u0026rdquo;; likewise, though they are listed in a different order, the trie has children labeled \u0026lsquo;i\u0026rsquo; and \u0026lsquo;a\u0026rsquo;, and the former node has children labeled \u0026rsquo;t', \u0026lsquo;c\u0026rsquo;, and \u0026lsquo;a\u0026rsquo;.\nWhat is more important to our discussion, however, is that the trie does not have a child labeled \u0026lsquo;c\u0026rsquo;, as there is no English word beginning with \u0026ldquo;hc\u0026rdquo;. Similarly, the child labeled \u0026lsquo;i\u0026rsquo; does not have a child labeled \u0026lsquo;i\u0026rsquo;, as there is no English word beginning with \u0026ldquo;hii\u0026rdquo;. If there are no words in the word list beginning with these prefixes, there is no need to search the subtrees rooted at the corresponding nodes when doing the preorder traversal. Using the trie to prune the search in this way ends up avoiding many subtrees that don\u0026rsquo;t lead to any words. As a result, only a small fraction of the original tree is searched.\nIn order to take advantage of the trie in this way, we need a method in the trie implementation to return the child having a given label, or null if there is no such child. Alternatively, we might provide a method that takes a string and returns the trie that this string leads to, or null if there is no such trie (this method would make it easier to handle the die containing \u0026ldquo;Qu\u0026rdquo;). Either way, we can then traverse the trie as we are doing the preorder traversal described above, and avoid searching a subtree whenever the trie becomes null.\nThis revised preorder traversal needs an extra parameter - a trie giving all completions of words beginning with the prefix given by the StringBuilder parameter. We will need to ensure that this parameter is never null. The algorithm then proceeds as follows:\n From the given trie, get the subtrie containing the completions of words beginning with the contents of the current cell. If this subtrie is not null:  Set the location in the bool[ , ] corresponding to the current cell to true. Append the contents of the current cell to the StringBuilder. If the subtrie obtained above contains the empty string, output the contents of the StringBuilder as a word found. Recursively traverse each adjacent cell whose corresponding entry in the bool[ , ] is false. The recursive calls should use the subtrie obtained above. Set the location in the bool[ , ] corresponding to the current cell to false. Remove the contents of the current cell from the end of the StringBuilder (i.e., decrease its Length by the appropriate amount).    We would then apply the above algorithm to each cell on the board. For each cell, we would use a bool[ , ] whose entries are all false, an empty StringBuilder, and the entire trie. Note that we have designed the preorder traversal so that it leaves each of these parameters unchanged; hence, we only need to initialize them once. The resulting search will find all of the words on the board quickly.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/",
	"title": "Trees",
	"tags": [],
	"description": "",
	"content": "Trees Binary search provides an efficient way to find elements in a sorted array-like structure. However, inserting or removing from an array-like structure can be expensive because all subsequent data elements must be moved to accommodate the change. On the other hand, linked lists can be modified efficiently, provided we have a reference to the cell preceding the insertion or deletion point. However, finding a cell can be expensive because the only way to search a linked list is to start at the front and work through it a cell at a time. We would like a data structure that provides both efficient lookups and efficient insertions and deletions.\nTo meet this challenge, we want a linked structure so that changes can be made cheaply by changing a few references. However, we want the individual cells in the structure to be arranged in a way that supports something like a binary search. The specific structure that we want is called a binary search tree, which is a particular kind of tree. In this chapter, we will examine various kinds of trees. We will start by defining trees and developing a strategy for processing them. We will then present binary search trees, which will provide a partial solution to our challenge of finding a data structure to support efficient lookups, insertions, and deletions. However, there will be cases in which binary search trees have poor performance. We will therefore give a refinement known as AVL trees, which give good performance in all cases. We will then examine two other uses of trees - tries and priority queues.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/const/",
	"title": "Constant Fields",
	"tags": [],
	"description": "",
	"content": "Constant Fields Field declarations may contain the keyword const to indicate that these fields will always contain the same values. Such declarations are useful for defining a value that is to be used throughout a class or structure definition, or throughout an entire program. For example, we might define:\npublic class ConstantsExample { public const int VerticalPadding = 12; private const string _humanPlayer = \u0026#34;X\u0026#34;; . . . } Subsequently throughout the above class, the identifier _humanPlayer will refer to the string, \u0026ldquo;X\u0026rdquo;. Because VerticalPadding is public, ConstantsExample.VerticalPadding will contain the value 12 throughout the program. Such defintions are useful for various reasons, but perhaps the most important is that they make the program more maintainable. For example, ConstantsExample.VerticalPadding may represent some distance within a graphical layout. At some point in the lifetime of the software, it may be decided that this distance should be chaged to 10 in order to give a more compact layout. Because we are using a constant field rather than a literal 12 everywhere this distance is needed, we can make this change by simply changing the 12 in the above definition to 10.\nWhen defining a constant field, an initializer is required. The value assigned by the initializer must be a value that can be computed at compile time. For this reason, the only values that a constant field of a reference type can be are a string or null. The assigned value may be an expression, and this expression may contain other constant fields, provided these definitions don\u0026rsquo;t mutually depend on each other. Thus, for example, we could add the following to the above definition:\npublic const int HorizontalPadding = VerticalPadding / 2; Constant fields may not be declared as static, as they are already implicitly static.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/hash-functions/",
	"title": "Hash Codes",
	"tags": [],
	"description": "",
	"content": "Hash Codes Whenever equality is redefined for a type, the hash code computation for that type needs to be redefined in a consistent way. This is done by overriding that type\u0026rsquo;s GetHashCode method. In order for hashing to be implemented correctly and efficiently, this method should satisfy the following goals:\n Equal keys must have the same hash code. This is necessary in order for the Dictionary\u0026lt;TKey, TValue\u0026gt; class to be able to find a given key that it has stored. On the other hand, because the number of possible keys is usually larger than the number of possible hash codes, unequal keys are also allowed to have the same hash code. The computation should be done quickly. Hash codes should be uniformly distributed even if the keys are not.  The last goal above may seem rather daunting, particularly in light of our desire for a quick computation. In fact, it is impossible to guarantee in general \u0026mdash; provided there are more than $2^{32}(k - 1)$ possible keys from which to choose, no matter how the hash code computation is implemented, we can always find at least $k$ keys with the same hash code. However, this is a problem that has been studied a great deal, and several techniques have been developed that are effective in practice. We will caution, however, that not every technique that looks like it should be effective actually is in practice. It is best to use techniques that have been demonstrated to be effective in a wide variety of applications. We will examine one of these techniques in what follows.\nA guiding principle in developing hashing techniques is to use all information available in the key. By using all the information, we will be sure to use the information that distinguishes this key from other keys. This information includes not just the values of the individual parts of the the key, but also the order in which they occur, provided this order is significant in distinguishing unequal keys. For example, the strings, \u0026ldquo;being\u0026rdquo; and \u0026ldquo;begin\u0026rdquo; contain the same letters, but are different because the letters occur in a different order.\nOne specific technique initializes the hash code to 0, then processes the key one component at a time. These components may be bytes, characters, or other parts no larger than 32 bits each. For example, for the Nim board positions discussed in “Memoization”, the components would be the number of stones on each pile, the limit for each pile, and the total number of piles (to distinguish between a board ending with empty piles and a board with fewer piles). For each component, it does the following:\n Multiply the hash code by some fixed odd integer. Add the current component to the hash code.  Due to the repeated multiplications, the above computation will often overflow an int. This is not a problem \u0026mdash; the remaining bits are sufficient for the hash code.\nIn order to understand this computation a little better, let\u0026rsquo;s first ignore the effect of this overflow. We\u0026rsquo;ll denote the fixed odd integer by $x$, and the components of the key as $k_1, \\dots, k_n$. Then this is the result of the computation:\n$$(\\dots ((0x + k_1)x + k_2) \\dots)x + k_n = k_1 x^{n-1} + k_2 x^{n-2} + \\dots + k_n.$$\nBecause the above is a polynomial, this hashing scheme is called polynomial hashing. While the computation itself is efficient, performing just a couple of arithmetic operations on each component, the result is to multiply each component by a unique value ($x^i$ for some $i$) depending on its position within the key.\nNow let\u0026rsquo;s consider the effect of overflow on the above polynomial. What this does is to keep only the low-order 32 bits of the value of the polynomial. Looking at it another way, we end up multiplying $k_i$ by only the low-order 32 bits of $x^{n-i}$. This helps to explain why $x$ is an odd number \u0026mdash; raising an even number to the $i$th power forms a number ending in $i$ 0s in binary. Thus, if there are more than 32 components in the key, all but the last 32 will be multiplied by $0$, and hence, ignored.\nThere are other potential problems with using certain odd numbers for $x$. For example, we wouldn\u0026rsquo;t want to use $1$, because that would result in simply adding all the components together, and we would lose any information regarding their positions within the key. Using $-1$ would be almost as bad, as we would multiply all components in odd positions by $-1$ and all components in even positions by $1$. The effect of overflow can cause similar behavior; for example, if we place $2^{31} - 1$ in an int variable and square it, the overflow causes the result to be 1. Successive powers will then alternate between $2^{31} - 1$ and $1$.\nIt turns out that this cyclic behavior occurs no matter what odd number we use for $x$. However, in most cases the cycle is long enough that keys of a reasonable size will have each component multiplied by a unique value. The only odd numbers that result in short cycles are those that are adjacent to a multiple of a large power of $2$ (note that $0$ is a multiple of any integer).\nThe other potential problem occurs when we are hashing fairly short keys. In such cases, if $x$ is also small enough, the values computed will all be much smaller than the maximum possible integer value $(2^{31} - 1)$. As a result, we will not have a uniform distribution of values. We therefore want to avoid making $x$ too small.\nPutting all this together, choosing $x$ to be an odd number between $30$ and $40$ works pretty well. These values are large enough so that seven key components will usually overflow an int. Furthermore, they all have a cycle length greater than $100$ million.\nWe should always save the hash code in a private field after we compute it so that subsequent requests for the same hash code don\u0026rsquo;t result in repeating the computation. This can be done in either of two ways. One way is to compute it in an eager fashion by doing it in the constructor. When doing it this way, the GetHashCode method simply needs to return the value of the private field. While this is often the easiest way, it sometimes results in computing a hash code that we end up not using. The alternative is to compute it in a lazy fashion. This requires an extra private field of type bool. This field is used to indicate whether the hash code has been computed yet or not. With this approach, the GetHashCode method first checks this field to see if the hash code has been computed. If not, it computes the hash code and saves it in its field. In either case, it then returns the value of the hash code field.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/hashing/",
	"title": "Hash Tables",
	"tags": [],
	"description": "",
	"content": "Hash Tables Throughout our discussion of dictionaries over the last three chapters, we have taken advantage of the fact that the keys were sorted when looking up specific keys. In this chapter, we examine a rather surprising result \u0026mdash; that we can achieve better performance if we don\u0026rsquo;t have to keep the keys in any particular order (i.e., so that we can process them in that order). The technique uses a data structure known as a hash table, which is the underlying data structure in the .NET Framework\u0026rsquo;s Dictionary\u0026lt;TKey,TValue\u0026gt; class.\nA hash table is typically organized as an array of linked lists. The individual cells in the linked lists each store a key and a value. Associated with this structure is a hash function, which takes a key as its parameter and computes an array location. This array location contains a reference to the beginning of the linked list that will contain the given key if it is in the hash table. Thus, in order to find a key in a hash table, we first apply the hash function to the key, then search the linked list at the location computed by the hash function. The following picture illustrates the layout of a hash table in which the keys are strings and the values are ints, and the hash function is denoted by h:\nNote\nIn order to avoid cluttering the above picture, the strings are shown inside the linked list cells, even though string is a reference type.\n In order to achieve good performance, we want all of the linked lists to be short. This requires, among other things, that we make the array sufficiently large. We therefore increase the size of the array as the number of elements increases.\nThe above overview of hash tables reveals one of the challenges in using a dictionary implemented using a hash table. Specifically, whenever we define a new key type, this type is unknown to the dictionary implementation. How then can it compute a hash function on an instance of this type? The short answer to this question is that the hash function is divided into two parts. The first part of the hash function is implemented within the key type itself, where code can access the implementation details of the key. Specifically, every type in C# has a public GetHashCode method, which takes no parameters and returns an int. Any new type that redefines how its elements are compared for equality should override this method so as to ensure that it returns the same value whenever it is called on equal instances. The second part of the hash function is implemented within the dictionary itself. This part takes the int from the first part and uses it to compute an array location. We will discuss both parts of the hash function computation in more detail in later sections.\nIn the next few sections, we will present the implementation details of a hash table. We will then discuss how a dictionary can facilitate a technique called memoization, which can be used to improve dramatically the performance of certain algorithms. This discussion will provide a motivation for defining a new key type. We then take a close look at how equality is handled in C#, as we will need to be able to implement equality tests if we are to define new types that can be used as keys. We then complete the discussion on defining new key types by illustrating how the GetHashCode method can be implemented.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/huffman-trees/",
	"title": "Huffman Trees",
	"tags": [],
	"description": "",
	"content": "Huffman Trees In this section, we\u0026rsquo;ll consider an application of min-priority queues to the general problem of compressing files. Consider, for example, a plain text file like this copy of the U. S. Constitution. This file is encoded using UTF-8, the most common encoding for plain text files. The characters most commonly appearing in English-language text files are each encoded as one byte (i.e., eight bits) using this scheme. For example, in the text file referenced above, every character is encoded as a single byte (the first three bytes of the file are an optional code indicating that it is encoded in UTF-8 format). Furthermore, some byte values occur much more frequently than others. For example, the encoding of the blank character occurs over 6000 times, whereas the encoding of \u0026lsquo;$\u0026rsquo; occurs only once, and the encoding of \u0026lsquo;=\u0026rsquo; doesn\u0026rsquo;t occur at all.\nOne of the techniques used by most file compression schemes is to find a variable-width encoding scheme for the file. Such a scheme uses fewer bits to encode commonly-occurring byte values and more bits to encode rarely-occurring byte values. Byte values that do not occur at all in the file are not given an encoding.\nConsider, for example, a file containing the single string, \u0026ldquo;Mississippi\u0026rdquo;, with no control characters signaling the end of the line. If we were to use one byte for each character, as UTF-8 would do, we would need 11 bytes (or 88 bits). However, we could encode the characters in binary as follows:\n M: 100 i: 0 p: 101 s: 11  Obviously because each character is encoded with fewer than 8 bits, this will give us a shorter encoding. However, because \u0026lsquo;i\u0026rsquo; and \u0026rsquo;s', which each occur four times in the string, are given shorter encodings than \u0026lsquo;M\u0026rsquo; and \u0026lsquo;p\u0026rsquo;, which occur a total of three times combined, the number of bits is further reduced. The encoded string is\n100011110111101011010  which is only 21 bits, or less than 3 bytes.\nIn constructing such an encoding scheme, it is important that the encoded string can be decoded unambiguously. For example, it would appear that the following scheme might be even better:\n M: 01 i: 0 p: 10 s: 1  This scheme produces the following encoding:\n01011011010100  which is only 14 bits, or less than 2 bytes. However, when we try to decode it, we immediately run into problems. Is the first 0 an \u0026lsquo;i\u0026rsquo; or the first bit of an \u0026lsquo;M\u0026rsquo;? We could decode this string as \u0026ldquo;isMsMsMisii\u0026rdquo;, or a number of other possible strings.\nThe first encoding above, however, has only one decoding, \u0026ldquo;Mississippi\u0026rdquo;. The reason for this is that this encoding is based on the following binary tree:\nTo get the encoding for a character, we trace the path to that character from the root, and record a 0 each time we go left and a 1 each time we go right. Thus, because the path to \u0026lsquo;M\u0026rsquo; is right, left, left, we have an encoding of 100. To decode, we simply use the encoding to trace out a path in the tree, and when we reach a character (or more generally, a byte value), we record that value. If we form the tree such that each node has either two empty children or two nonempty children, then when tracing out a path, we will always either have a choice of two alternatives or be at a leaf storing a byte value. The decoding will therefore be unambiguous. Such a tree that gives an encoding whose length is minimized over all such encodings is called a Huffman tree.\nBefore we can find a Huffman tree for a file, we need to determine how many times each byte value occurs. There are 256 different byte values possible; hence we will need an array of 256 elements to keep track of the number of occurrences of each. Because files can be large, this array should be a long[ ]. We can then use element i of this array to keep track of the number of occurrences of byte value i. Thus, after constructing this array, we can read the file one byte at a time as described in “Other File I/O”, and for each byte b that we read, we increment the value at location b of the array.\nHaving built this frequency table, we can now use it to build a Huffman tree. We will build this tree from the bottom up, storing subtrees in a min-priority queue. The priority of each subtree will be the total number of occurrences of all the byte values stored in its leaves. We begin by building a 1-node tree from each nonzero value in the frequency table. As we iterate through the frequency table, if we find that location i is nonzero, we construct a node containing i and add that node to the min-priority queue. The priority we use when adding the node is the number of occurrences of i, which is simply the value at location i of the frequency table.\nOnce the min-priority queue has been loaded with the leaves, can begin combining subtrees into larger trees. We will need to handle as a special case an empty min-priority queue, which can result only from an empty input file. In this case, there is no Huffman tree, as there are no byte values that need to be encoded. Otherwise, as long as the min-priority queue has more than one element, we:\n Get and remove the two smallest priorities and their associated trees. Construct a new binary tree with these trees as its children and 0 as its data (which will be unused). Add the resulting tree to the min-priority queue with a priority equal to the sum of the priorities of its children.  Because each iteration removes two elements from the min-priority queue and adds one, eventually the min-priority queue will contain only one element. It can be shown that this last remaining element is a Huffman tree for the file.\nMost file compression schemes involve more than just converting to a Huffman-tree encoding. Furthermore, even if this is the only technique used, simply writing the encoded data is insufficient to compress the file, as the Huffman tree is needed to decompress it. Therefore, some representation of the Huffman tree must also be written. In addition, a few extra bits may be needed to reach a byte boundary. Because of this, the length of the decompressed file is also needed for decompression so that the extra bits are not interpreted as part of the encoded data. Due to this additional output, compressing a short file will likely result in a longer file than the original.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/hybrid/",
	"title": "Hybrid Sorting Algorithms",
	"tags": [],
	"description": "",
	"content": "Hybrid Sorting Algorithms The best versions of quick sort are competitive with both heap sort and merge sort on the vast majority of inputs. However, quick sort has a very bad worst case \u0026mdash; $O(n^2)$ running time and $O(n)$ stack usage. By comparison, both heap sort and merge sort have $O(n \\lg n)$ worst-case running time, together with a stack usage of $O(1)$ for heap sort or $O(\\lg n)$ for merge sort. Furthermore, insertion sort performs better than any of these algorithms on small data sets. In this section, we look at ways to combine some of these algorithms to obtain a sorting algorithm that has the advantages of each of them.\nWe will start with quick sort, which gives the best performance for most inputs. One way of improving its performance is to make use of the fact that insertion sort is more efficient for small data sets. Improving the performance on small portions can lead to significant performance improvements for large arrays because quick sort breaks large arrays into many small portions. Hence, when the portion we are sorting becomes small enough, rather than finding a pivot and splitting, we instead call insertion sort.\nAn alternative to the above improvement is to use the fact that insertion sort runs in $O(n)$ time when the number of inversions is linear in the number of array elements. To accomplish this, we modify quick sort slightly so that instead of sorting the array, it brings each element near where it belongs. We will refer to this modified algorithm as a partial sort. After we have done the partial sort, we then sort the array using insertion sort. The modification we make to quick sort to obtain the partial sort is simply to change when we stop sorting. We only sort portions that are larger than some threshold \u0026mdash; we leave other portions unsorted.\nSuppose, for example, that we choose a threshold of $10$. Once the partial sort reaches an array portion with nine or fewer elements, we do nothing with it. Note, however, that these elements are all larger than the elements that precede this portion, and they are all smaller than the elements that follow this portion; hence, each element can form an inversion with at most eight other elements \u0026mdash; the other elements in the same portion. Because each inversion contains two elements, this means that there can be no more than $4n$ inversions in the entire array once the partial sort finishes. The subsequent call to insertion sort will therefore finish the sorting in linear time.\nBoth of the above techniques yield performance improvements over quick sort alone. In fact, for many years, such combinations of an optimized version of quick sort with insertion sort were so efficient for most inputs that they were the most commonly-used algorithms for general-purpose sorting. On modern hardware architectures, the first approach above tends to give the better performance.\nNevertheless, neither of the above approaches can guarantee $O(n \\lg n)$ performance \u0026mdash; in the worst case, they are all still in $O(n^2)$. Furthermore, the bad cases still use linear stack space. To overcome these shortfalls, we can put a limit on the depth of recursion. Once this limit is reached, we can finish sorting this portion with an $O(n \\lg n)$ algorithm such as heap sort. The idea is to pick a limit that is large enough that it is rarely reached, but still small enough that bad cases will cause the alternative sort to be invoked before too much time is spent. A limit of about $2 \\lg n$, where $n$ is the size of the entire array, has been suggested. Because arrays in C# must have fewer than $2^{31}$ elements, this value is always less than $62$; hence, it is also safe to use a constant for the limit. The resulting algorithm has a worst-case running time in $O(n \\lg n)$ and a worst-case stack usage of $O(\\lg n)$. This logarithmic bound on the stack usage is sufficient to avoid a StackOverflowException.\nThe combination of quick sort using median-of-three partitioning with insertion sort for small portions and heap sort when the recursion depth limit is reached is known as introsort (short for introspective sort). Other improvements exist, but we will not discuss them here. The best versions of introsort are among the best sorting algorithms available, unless the array is nearly sorted. Of course, if the data won\u0026rsquo;t fit in an array, we can\u0026rsquo;t use introsort \u0026mdash; we should use external merge sort instead. Furthermore, like quick sort and heap sort, introsort is not stable. When a stable sort is not needed, however, and when none of the above special cases applies, introsort is one of the best choices available.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queues/",
	"title": "Introduction to Queues",
	"tags": [],
	"description": "",
	"content": "Introduction to Queues Stacks provide LIFO access to data, but sometimes we need first-in-first-out, or FIFO, access. Consider, for example, the computation of capital gains from stock sales. Typically an investor will buy shares of a stock commodity at various times and for different prices. When shares are sold, the amount of money received doesn\u0026rsquo;t depend on which shares of a given commodity are sold, as each share is worth the same amount at that time. Likewise, the unsold shares of that commodity each have the same value. However, for accounting purposes, it does matter. Specifically, the capital gain for that sale is defined to be the amount received from the sale minus the amount originally paid for those shares, assuming the shares sold are the oldest shares of that commodity owned by the investor.\nSuppose now that we want to compute the capital gains from sales of stock. As shares are purchased, we need to record the purchase price of each share, along with the order in which the shares were purchased. As shares are sold, we need to retrieve the original purchase price of the oldest shares of each commodity sold. We therefore need first-in-first-out access to the purchase prices of the shares of each commodity owned. To keep this relatively simple, in what follows we will assume that we only need to keep track of one stock commodity.\nA queue provides FIFO access to data items. Like a stack, a queue is a sequence of data items. However, a queue behaves more like a line of people at a ticket counter. Each person who enters the queue enters at the back, and the next person who is served is the person at the front. Thus, the people in the queue are served in FIFO order. Likewise, new data items are added to the back of a queue, and data items are retrieved from the front.\nThe .NET Framework provides both a non-generic queue of objects (System.Collections.Queue) and a generic queue (System.Collections.Generic.Queue\u0026lt;T\u0026gt;). For simplicity, we will focus on the generic version. The non-generic version is the same, except that wherever the type parameter T is used in the generic version, object is used in the non-generic version.\nLike Stack\u0026lt;T\u0026gt;, Queue\u0026lt;T\u0026gt; has a public constructor that takes no parameters and constructs an empty queue, along with a public Count property that gets the number of elements in the queue (as an int). It also has the following public methods:\n An Enqueue method that takes a single parameter of type T and places it at the back of the queue. A Peek method that takes no parameters and returns the element (of type T) at the front of the queue without changing the queue\u0026rsquo;s contents. If the queue is empty, this method throws an InvalidOperationException. A Dequeue method, which takes no parameters and removes and returns the element at the front of the queue. If the queue is empty, this method throws an InvalidOperationException.  To implement a capital gain calculator using a Queue\u0026lt;T\u0026gt;, we first need to determine what type to make the elements. We will need to store the purchase price of each share we buy in the queue. An appropriate type for storing monetary amounts is the decimal type. Therefore, we will use an initially empty Queue\u0026lt;decimal\u0026gt;. Each time we buy shares, we enqueue the purchase price of each share onto the queue. When we sell shares, we need to compute the sum of the capital gains for all of the shares we sold. To get the capital gain for a single share, we dequeue its original purchase price from the queue, and subtract that purchase price from the selling price. Using the queue in this way ensures that we sell the shares in FIFO order.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/io/other-file-io/",
	"title": "Other File I/O",
	"tags": [],
	"description": "",
	"content": "Other File I/O Not all files are plain text files \u0026mdash; often we need to read and/or write binary data. The .NET Framework provides the FileStream class for this purpose.\nThe FileStream class provides constructors for creating a FileStream for reading, writing, or both. These constructors can be used to specify how the file is to be opened or created, the type of access to be allowed (i.e., reading/writing), and how the file is to be locked. In most cases, however, a simpler way to construct an appropriate FileStream is to use one of the following static methods provided by the the File class:\n File.OpenRead(string fn): returns a FileStream for reading the file with the given path name. A FileNotFoundException is thrown if the file does not exist. File.OpenWrite(string fn): returns a FileStream for writing to the file with the given path name. If the file exists, it will be replaced; otherwise, it will be created.  Two of the most commonly-used methods of a FileStream are ReadByte and WriteByte. The ReadByte method takes no parameters and returns an int. If there is at least one byte available to read, the next one is read and its value (a nonnegative integer less than 256) is returned; otherwise, the value returned is -1 (this is the only way to detect when the end of the stream has been reached). The WriteByte method takes a byte as its only parameter and writes it to the file. It returns nothing.\nBecause a FileStream has no EndOfStream property, we must code a loop to read to the end of the stream somewhat differently from what we have seen before. We can take advantage of the fact that in C#, an assignment statement can be used within an expression. When this is done, the value of the assignment statement is the value that it assigns. Thus, if input is a FileStream opened for input, we can set up a loop to read a byte at a time to the end of the stream as follows:\nint k; while ((k = input.ReadByte()) != -1) { byte b = (byte)k; . . . } In the above code, the ReadByte method reads a byte from the file as long as there is one to read, and assigns it to the int variable k. If there is no byte to read, it assigns -1 to k. In either case, the value of the assignment statement is the value assigned to k. Thus, if the ReadByte method is at the end of the stream, it returns -1, which is assigned to k, and the loop terminates. Otherwise, the loop iterates, assigning k to b as a byte. The remainder of the iteration can then use the byte read, which is in b.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/trees/priority-queues/",
	"title": "Priority Queues",
	"tags": [],
	"description": "",
	"content": "Priority Queues Often we need a data structure that supports efficient storage of data items and their subsequent retrieval in order of some pre-determined priority. We have already seen two instances of such data structures: stacks and queues. With a stack, the later the item is stored, the higher its priority. With a queue, the earlier the item is stored, the higher its priority. More generally, we would like to be able to set priorities arbitrarily, in a way that may be unrelated to the order in which they were stored.\nThe general name for such a data structure is a priority queue. Priority queues typically support the following operations:\n Adding a data element, together with a priority. Obtaining the number of data elements currently in the structure. Obtaining the maximum of all priorities of elements in the structure. Removing a data element having maximum priority.  Obviously, the last two operations above can only be done when the structure is nonempty. A variation on the above focuses on minimum priority rather than maximum priority. This variation is called a min-priority queue. Because we will later cover applications of min-priority queues, we will focus on this variation in this section. In the sub-sections that follow, we will first consider a general structure that can be used in various ways to give efficient priority queue implementations. We will then look at one specific implementation. We will conclude by giving an example of how min-priority queues are used in file compression algorithms.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/style/prohibited/",
	"title": "Prohibited Features",
	"tags": [],
	"description": "",
	"content": "Prohibited Features The following features of C# should not be used on assignments or quizzes unless otherwise stated:\n The goto statement: It has been over 45 years since Dijkstra published “Go To Statement Considered Harmful” (Communications of the ACM, vol. 11 (1968), pp. 147-148). I am amazed that languages continue to include this statement. The unsafe keyword: The name pretty much says it all. The var keyword: There are very few contexts in which this is needed, and these contexts won\u0026rsquo;t occur in this class. For all other contexts, it makes the code less readable. Virtual methods: These are useful in large-scale software development; however, they are overused. They will not be needed in the programming we will be doing. (However, virtual methods in the .NET class library may be overridden.) Extension methods: These methods are not defined within the class on which they operate, but elsewhere. Consequently, they tend to be much less efficient than the methods defined within the class. If the Visual Studio® auto-complete gives you a method that looks like it gives you what you want, first click on it and take a look at its popup documentation. If it is an extension method, this documentation will begin with \u0026ldquo;(extension)\u0026rdquo;.  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/code-window/",
	"title": "The Code Window",
	"tags": [],
	"description": "",
	"content": "The Code Window In the previous section, we designed the following GUI:\nWe also indicated briefly how functionality could be added to the button by double-clicking it in the design window to create an event handler. Creating this event handler also opens the code window to display it. The code window for this file can also be displayed by pressing F7 in the design window or by right-clicking the source code file name in the Solution Explorer and selecting \u0026ldquo;View Code\u0026rdquo;. Once a code window has been opened, it can be brought to the front by clicking the tab containing its file name near the top of the Visual Studio window. This window should look something like this:\nHere is a ZIP archive containing the entire Visual Studio solution. After downloading and expanding it, you may need to navigate through a folder or two, but you should be able to find a file, Ksu.Cis300.HelloWorld.sln (the \u0026ldquo;.sln\u0026rdquo; suffix may not be visible, but it should show as type \u0026ldquo;Microsoft Visual Studio Solution\u0026rdquo;). If you double-click on this file, Visual Studio 2019 should open the solution.\nNote in the class statement the keyword, partial. This indicates that not all of this class definition is in this file. The remainder of the definition is in the file, UserInterface.Design.cs. Recall that that file contains code for laying out the GUI and making the uxGo_Click method an event handler for the \u0026ldquo;Go\u0026rdquo; button. One of the method definitions that it contains is the InitializeComponent method, which does the layout of the GUI and sets up the event handlers. Recall also that the Main method in Program.cs constructs an instance of this class, then displays it and begins processing events for it. Because the constructor (see the code window above) calls the InitializeComponent method, everything will be set up to run the application - all that is needed is code for the event handler. This code will then be executed every time the \u0026ldquo;Go\u0026rdquo; button is clicked.\nIn order for this code to provide meaningful functionality, it will need to interact with the controls on the GUI. It needs to use their variable names to do this. The name of the TextBox in this code is uxDisplay (recall that you can find this variable name by opening the design window, clicking on the control, and finding its \u0026ldquo;(Name)\u0026rdquo; property in its Properties window). Suppose we want to respond to the event by placing the text, \u0026ldquo;Hello world!\u0026rdquo;, in this TextBox. We therefore need to change its Text property to contain this string; i.e.:\nprivate void uxGo_Click(object sender, EventArgs e) { uxDisplay.Text = \u0026#34;Hello world!\u0026#34;; } Notice that when you type a quote mark, a matching quote is automatically added following the text cursor. As long as you don\u0026rsquo;t reposition the text cursor, you can just type the closing quote as you normally would after typing the text string \u0026mdash; Visual Studio won\u0026rsquo;t insert another quote mark, but will move the text cursor past the one it inserted automatically. The same behavior occurs when you type open parentheses, brackets, or braces.\nWhile we are here, we should also add appropriate comments to this method, the constructor, the class, and the file; for example:\n/* UserInterface.cs * Author: Rod Howell */ using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace Ksu.Cis300.HelloWorld { /// \u0026lt;summary\u0026gt;  /// A GUI for a Hello World program.  /// \u0026lt;/summary\u0026gt;  public partial class UserInterface : Form { /// \u0026lt;summary\u0026gt;  /// Constructs the GUI.  /// \u0026lt;/summary\u0026gt;  public UserInterface() { InitializeComponent(); } /// \u0026lt;summary\u0026gt;  /// Handles a Click event on the \u0026#34;Go\u0026#34; button.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void uxGo_Click(object sender, EventArgs e) { uxDisplay.Text = \u0026#34;Hello world!\u0026#34;; } } } The code window has several features that help with code writing. One of these features is auto-completion. Often while you are typing code, an auto-complete list appears, often with an entry highlighted. When an entry is highlighted (either automatically or by your selecting it manually), pressing \u0026ldquo;Enter\u0026rdquo; or typing a code element that can\u0026rsquo;t be part of the name (such as \u0026ldquo;.\u0026rdquo; or \u0026ldquo;+\u0026quot;) will insert the completion into your code. Once you get used to this feature, it can greatly speed up your code entry. Furthermore, it can be a helpful reminder of what you might need to type next. If you don\u0026rsquo;t want a name to auto-complete (perhaps because it is a name you haven\u0026rsquo;t defined yet), you can press \u0026ldquo;Esc\u0026rdquo;, and the auto-complete list will disappear.\nAnother feature of the code window is parameter information that shows as a popup box when you are typing a parameter list in a method call; for example:\nThis popup box gives the return type of the method, followed by the name of the method, followed by the parameter list, with the type of each parameter shown and the current parameter in bold face. When there are more than one method with the same name, this is indicated in the upper-left corner of the popup box (\u0026ldquo;1 of 21\u0026rdquo; in the figure above \u0026mdash; the method shown is the first of 21 methods having that name). You can use either the arrows in the popup box or the up and down arrows on the keyboard to scroll through these different methods.\nA related feature allows certain information to be obtained by hovering the mouse over different code elements. For example, hovering the mouse over an identifier will display the declaration and documentation for that identifier in a popup box. Also, hovering the mouse over a syntax error (indicated by a red underline, as shown under \u0026ldquo;Show\u0026rdquo; in the above figure) will display an explanation of the error, in addition to any information on the code element.\nFinally, Visual Studio gives rich support for renaming identifiers in a consistent way. For example, suppose we have a method called DoSomething, and we want to rename it to DoSomethingElse. We can make this change easily by right-clicking on the name, DoSomething, and selecting \u0026ldquo;Rename\u0026hellip;\u0026rdquo; from the resulting popup menu. Then change the name, which will now be highlighted, and press \u0026ldquo;Enter\u0026rdquo;. Doing this will rename the method consistently throughout your solution, changing only those instances that refer to this method if there are other identifiers with the same name. The same mechanism can be used to rename variables safely.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/code-window/",
	"title": "The Code Window",
	"tags": [],
	"description": "",
	"content": "The Code Window In the previous section, we designed the following GUI:\nWe also indicated briefly how functionality could be added to the button by double-clicking it in the design window to create an event handler. Creating this event handler also opens the code window to display it. The code window for this file can also be displayed by pressing F7 in the design window or by right-clicking the source code file name in the Solution Explorer and selecting \u0026ldquo;View Code\u0026rdquo;. Once a code window has been opened, it can be brought to the front by clicking the tab containing its file name near the top of the Visual Studio window. This window should look something like this:\nHere is a ZIP archive containing the entire Visual Studio solution. After downloading and expanding it, you may need to navigate through a folder or two, but you should be able to find a file, Ksu.Cis300.HelloWorld.sln (the \u0026ldquo;.sln\u0026rdquo; suffix may not be visible, but it should show as type \u0026ldquo;Microsoft Visual Studio Solution\u0026rdquo;). If you double-click on this file, Visual Studio 2022 should open the solution (if you have an older version of Visual Studio on your machine, you may need to right-click the file and select \u0026ldquo;Open with -\u0026gt; Microsoft Visual Studio 2022\u0026rdquo;).\nNote in the class statement the keyword, partial. This indicates that not all of this class definition is in this file. The remainder of the definition is in the file, UserInterface.Design.cs. Recall that that file contains code for laying out the GUI and making the uxGo_Click method an event handler for the \u0026ldquo;Go\u0026rdquo; button. One of the method definitions that it contains is the InitializeComponent method, which does the layout of the GUI and sets up the event handlers. Recall also that the Main method in Program.cs constructs an instance of this class, then displays it and begins processing events for it. Because the constructor (see the code window above) calls the InitializeComponent method, everything will be set up to run the application - all that is needed is code for the event handler. This code will then be executed every time the \u0026ldquo;Go\u0026rdquo; button is clicked.\nIn order for this code to provide meaningful functionality, it will need to interact with the controls on the GUI. It needs to use their variable names to do this. The name of the TextBox in this code is uxDisplay (recall that you can find this variable name by opening the design window, clicking on the control, and finding its \u0026ldquo;(Name)\u0026rdquo; property in its Properties window). Suppose we want to respond to the event by placing the text, \u0026ldquo;Hello world!\u0026rdquo;, in this TextBox. We therefore need to change its Text property to contain this string; i.e.:\nprivate void uxGo_Click(object sender, EventArgs e) { uxDisplay.Text = \u0026#34;Hello world!\u0026#34;; } Notice that when you type a quote mark, a matching quote is automatically added following the text cursor. As long as you don\u0026rsquo;t reposition the text cursor, you can just type the closing quote as you normally would after typing the text string \u0026mdash; Visual Studio won\u0026rsquo;t insert another quote mark, but will move the text cursor past the one it inserted automatically. The same behavior occurs when you type open parentheses, brackets, or braces.\nWhile we are here, we should also add appropriate comments to this method, the constructor, the class, and the file; for example:\n/* UserInterface.cs * Author: Rod Howell */ using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace Ksu.Cis300.HelloWorld { /// \u0026lt;summary\u0026gt;  /// A GUI for a Hello World program.  /// \u0026lt;/summary\u0026gt;  public partial class UserInterface : Form { /// \u0026lt;summary\u0026gt;  /// Constructs the GUI.  /// \u0026lt;/summary\u0026gt;  public UserInterface() { InitializeComponent(); } /// \u0026lt;summary\u0026gt;  /// Handles a Click event on the \u0026#34;Go\u0026#34; button.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;sender\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;e\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  private void uxGo_Click(object sender, EventArgs e) { uxDisplay.Text = \u0026#34;Hello world!\u0026#34;; } } } The code window has several features that help with code writing. One of these features is auto-completion. Often while you are typing code, an auto-complete list appears, often with an entry highlighted. When an entry is highlighted (either automatically or by your selecting it manually), pressing \u0026ldquo;Enter\u0026rdquo; or typing a code element that can\u0026rsquo;t be part of the name (such as \u0026ldquo;.\u0026rdquo; or \u0026ldquo;+\u0026quot;) will insert the completion into your code. Once you get used to this feature, it can greatly speed up your code entry. Furthermore, it can be a helpful reminder of what you might need to type next. If you don\u0026rsquo;t want a name to auto-complete (perhaps because it is a name you haven\u0026rsquo;t defined yet), you can press \u0026ldquo;Esc\u0026rdquo;, and the auto-complete list will disappear.\nAnother feature of the code window is parameter information that shows as a popup box when you are typing a parameter list in a method call; for example:\nThis popup box gives the return type of the method, followed by the name of the method, followed by the parameter list, with the type of each parameter shown and the current parameter in bold face. When there are more than one method with the same name, this is indicated in the upper-left corner of the popup box (\u0026ldquo;1 of 21\u0026rdquo; in the figure above \u0026mdash; the method shown is the first of 21 methods having that name). You can use either the arrows in the popup box or the up and down arrows on the keyboard to scroll through these different methods.\nA related feature allows certain information to be obtained by hovering the mouse over different code elements. For example, hovering the mouse over an identifier will display the declaration and documentation for that identifier in a popup box. Also, hovering the mouse over a syntax error (indicated by a red underline, as shown under \u0026ldquo;Show\u0026rdquo; in the above figure) will display an explanation of the error, in addition to any information on the code element.\nFinally, Visual Studio gives rich support for renaming identifiers in a consistent way. For example, suppose we have a method called DoSomething, and we want to rename it to DoSomethingElse. We can make this change easily by right-clicking on the name, DoSomething, and selecting \u0026ldquo;Rename\u0026hellip;\u0026rdquo; from the resulting popup menu. Then change the name, which will now be highlighted, and press \u0026ldquo;Enter\u0026rdquo;. Doing this will rename the method consistently throughout your solution, changing only those instances that refer to this method if there are other identifiers with the same name. The same mechanism can be used to rename variables safely.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/graphs/",
	"title": "Graphs",
	"tags": [],
	"description": "",
	"content": "Graphs In this chapter, we examine a data structure known as a graph, which can be used to represent a wide variety of data sets in which pairs of data items are related in a certain way. Examples of such data sets include road maps, data flows or control flows in programs, and representations of communication networks. Because graphs are so widely used, numerous algorithms on graphs have been devised. As a result, the same algorithm can often be applied to a variety of applications because the underlying data structure for each application is a graph.\nWe will begin by presenting the basic definitions and concepts, and describing the use of a data type that implements a graph. We will then examine how to use a graph to find shortest paths in a road map. We will then examine the related problem of finding shortest paths through a maze. We will conclude by discussing how to implement a graph.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queue-impl/",
	"title": "Implementing a Queue",
	"tags": [],
	"description": "",
	"content": "Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.e.:\nThis implementation works well as long as we are only enqueuing elements \u0026mdash; each element is placed at the back, much like pushing an element onto a stack. However, consider what happens when we dequeue an element. The element is easy to locate, as it must be at index 0, but in order to maintain the above picture, we would need to move all of the remaining elements one location to the left. This becomes less efficient as the number of elements in the queue increases.\nOne alternative is to modify the picture somewhat:\nWe can maintain this picture more efficiently, as there is now no need to move the elements when we dequeue an element. It does mean that we need to keep track of a bit more information, namely, the location of either the front or the back, in addition to the Count (note that we can compute the other end from these two values). But a more serious problem remains. Notice that as we enqueue and dequeue elements, the portion of the array that we are using works its way to the right. Eventually, the back element will be the last element in the array. However, this doesn\u0026rsquo;t mean that we are using the entire array, as the front can be anywhere in the array.\nTo solve this problem, when we need to enqueue an element but the back element is in the last array location, we place the next element at index 0. It is as if we are imagining the array as being circular, as the next location after the last is back at the beginning. The following picture gives two views of such a \u0026ldquo;circular array\u0026rdquo; implementation:\nWith this implementation, we only need to construct a larger array if we completely fill the current array, and unless we need to do this, we don\u0026rsquo;t need to move elements around. We need the following class members in order to keep track of everything:\n a private T[ ] field in which to store the elements; a public int Count property; and a private int field giving the index of the element at the front of the queue (if the queue is empty, this can be any valid index).  Let us now consider how we would implement Enqueue. We first need to determine whether the array is full by comparing the Count with the size of the array. If it is full, we need to construct a new array of twice the size, as we did for both the StringBuilder implementation and the stack implementation. However, we can\u0026rsquo;t simply copy the entire array to the beginning of the new array, as we did for these other two implementations. To do so would leave a gap in the middle of the queue, as shown in the following illustration:\nWhile there are several ways of copying the elements correctly, it may be helpful to copy in such a way that the index of the front of the queue remains unchanged; i.e., we copy as follows:\nIn order to copy the elements like this, we can use the static method, Array.Copy. This method takes the following parameters:\n The array to copy from. An int giving the index of the first element to copy. The array to copy to. An int giving the index in which to place the first element. An int giving the number of elements to copy.  Just figuring out how to fill in these parameters takes some work. Let\u0026rsquo;s first consider the part that begins with the front of the queue. The index of the first element to copy is the index of the front of the queue, which we have in a private field. We want to place this element at the same index in the new array. In order to compute the number of elements to copy, first observe that we know the number of elements in the original array (we can use either the Count property or the length of this array, as these values are equal whenever we need a larger array). To get the number of elements we want to copy, we can subtract from this value the number of elements we are not copying \u0026mdash; i.e., the number of elements preceding the index of the front of the queue. The number of elements preceding any index i is always i; hence, by subtracting the index of the front of the queue from the Count, we get the number of elements we are copying by this call.\nNow let\u0026rsquo;s see if we can figure out the parameters for the other call. The first element we want to copy is at index 0. We want to place it immediately following the elements we have already copied. Because the last of these elements occupies the last index of the original array, whose size is currently the same as the Count, the next index is just the Count. The number of elements we want to copy, as we have already argued, is the index of the front of the queue.\nOnce we have the elements copied to the new array, the hardest part is done. After we do this, we just need to copy the reference to the new array into the array field.\nOnce we have ensured that there is room in the array to add a new element, we can complete the Enqueue method. We need to place the element at the back of the queue. We can obtain the proper location by adding the Count to the index of the front of the queue, provided this value is not beyond the end of the array. If it is, then we need to wrap it around by subtracting the length of the array. We can then increment the number of elements, and we are (finally) done.\nThe Peek method is straightforward \u0026mdash; after verifying that the queue is nonempty, we simply return the element at the front. The Dequeue method isn\u0026rsquo;t much more difficult. We can obtain the element we want to return using the Peek method. We then need to place the default element of type T at the front, and update both the index of the front of the queue and the Count before returning the element we obtained ealier from Peek. The only slightly tricky part is making sure that when we update the index of the front of the queue, we don\u0026rsquo;t go outside of the array. If we do, we need to wrap it back around to 0.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/properties/",
	"title": "Properties",
	"tags": [],
	"description": "",
	"content": "Properties A property is used syntactically like a field of a class or structure, but provides greater flexibility in implementation. For example, the string class contains a public property called Length. This property is accessed in code much as if it were a public int field; i.e., if s is a string variable, we can access its Length property with the expression s.Length, which evaluates to an int. If Length were a public int field, we would access it in just the same way. However, it turns out that we cannot assign a value to this property, as we can to a public field; i.e., the statement,\ns.Length = 0; is not allowed. The reason for this limitation is that properties can be defined to restrict whether they can be read from or written to. The Length property is defined so that it can be read from, but not written to. This flexibility is one of the two main differences between a field and a property. The other main difference has to do with maintainability and is therefore easier to understand once we see how to define a property.\nSuppose we wish to provide full read/write access to a double value. Rather than defining a public double field, we can define a simple double property as follows:\npublic double X { get; set; } This property then functions just like a public field - the get keyword allows code to read from the property, and the set keyword allows code to write to the property. A property definition requires at least one of these keywords, but one of them may be omitted to define a read-only property (if set is omitted) or a write-only property (if get is omitted). For example, the following defines X to be a read-only property:\npublic double X { get; } Although this property is read-only, the constructor for the class or structure containing this definition is allowed to initialize it. Sometimes, however we want certain methods of the containing class or structure to be able to modify the property\u0026rsquo;s value without allowing user code to do so. To accomplish this, We can define X in this way:\npublic double X { get; private set; } The above examples are the simplest ways to define properties. They all rely on the default implementation of the property. Unlike a field, the name of the property is not actually a variable; instead, there is a hidden variable that is automatically defined. The only way this hidden variable can be accessed is through the property.\nThe distinction between a property and its hidden variable may seem artificial at first. However, the real flexibility of a property is revealed by the fact that we can define our own implementation, rather than relying on the default implementation. For example, suppose a certain data structure stores a StringBuilder called _word, and we want to provide read-only access to its length. We can facilitate this by defining the following property:\npublic int WordLength { get =\u0026gt; _word.Length; } In fact, we can abbreviate this definition as follows:\npublic int WordLength =\u0026gt; _word.Length; In this case, the get keyword is implied. In either case, the code to the right of the \u0026ldquo;=\u0026gt;\u0026rdquo; must be an expression whose type is the same as the property\u0026rsquo;s type. Note that when we provide such an expression, there is no longer a hidden variable, as we have provided explicit code indicating how the value of the property is to be computed.\nWe can also provide an explicit implementation for the set accessor. Suppose, for example, that we want to allow the user read/write access to the length of _word. In order to be able to provide write access, we must be able to acquire the value that the user wishes to assign to the length. C# provides a keyword value for this purpose - its type is the same as the type of the property, and it stores the value that user code assigns to the property. Hence, we can define the property as follows:\npublic int WordLength { get =\u0026gt; _word.Length; set =\u0026gt; _word.Length = value; } It is this flexibility in defining the implementation of a property that makes public properties more maintainable than public fields. Returning to the example at the beginning of this section, suppose we had simply defined X as a public double field. As we pointed out above, such a field could be used by user code in the same way as the first definition of the property X. However, a field is part of the implementation of a class or structure. By making it public, we have exposed part of the implementation to user code. This means that if we later change this part of the implementation, we will potentially break user code that relies on it. If, instead, we were to use a property, we can then change the implementation by modifying the get and/or set accessors. As long as we don\u0026rsquo;t remove either accessor (or make it private), such a change is invisible to user code. Due to this maintainability, good programmers will never use public fields (unless they are constants); instead, they will use public properties.\nIn some cases, we need more than a single to expression to define a get or set accessor. For example, suppose a data structure stores an int[ ] _elements, and we wish to provide read-only access to this array. In order to ensure read-only access, we don\u0026rsquo;t want to give user code a reference to the array, as the code would then be able to modify its contents. We therefore wish to make a copy of the array, and return that array to the user code (though a better solution might be to define an indexer). We can accomplish this as follows:\npublic int[ ] Elements { get { int[] temp = new int[_elements.Length]; _elements.CopyTo(temp, 0); return temp; } } Thus, arbitrary code may be included within the get accessor, provided it returns a value of the appropriate type; however, it is good programming practice to avoid changing the fields of a class or structure within the get accessor of one of its properties. In a similar way, arbitrary code may be used to implement a set accessor. As we can see from this most general way of defining properties, they are really more like methods than fields.\nGiven how similar accessors are to methods, we might also wonder why we don\u0026rsquo;t just use methods instead of properties. In fact, we can do just that - properties don\u0026rsquo;t give any functional advantage over methods, and in fact, some object-oriented languages don\u0026rsquo;t have properties. The advantage is stylistic. Methods are meant to perform actions, whereas properties are meant to represent entities. Thus, we could define methods GetX and SetX to provide access to the private field _x; however, it is stylistically cleaner to define a property called X.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/",
	"title": "Sorting",
	"tags": [],
	"description": "",
	"content": "Sorting We conclude this text with a look at a common activity in computing, namely, sorting data. While the .NET Framework provides several methods for sorting data, it is instructive to examine the implementation details of different techniques. While there is one sorting algorithm that is used more commonly than the others, none is best for all situations. An understanding of which algorithms perform better in different situations can help us to make better choices and thereby achieve better performance for the software we build. Furthermore, because there are so many different approaches to sorting, studying the various techniques can help us to see how different approaches can be used for the same problem in order to obtain different algorithms.\nIn this chapter, we will consider several sorting algorithms, but not nearly all of them. In the first four sections, we will focus on algorithms that can be applied to any data type that can sorted; thus, we will only consider algorithms that operate by comparing data elements to each other. Most of these algorithms can be divided into four general approaches. We consider each of these approaches separately. We then conclude with an algorithm designed specifically for sorting strings.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/sorting/strings/",
	"title": "Sorting Strings",
	"tags": [],
	"description": "",
	"content": "Sorting Strings We conclude our discussion of sorting with a look at a sorting algorithm designed specifically for sorting multi-keyed data. In such data there is a primary key, a secondary key, and so on. We want to sort the data so that element a precedes element b if:\n the primary key of a is less than the primary key of b; or their primary keys are equal, but the secondary key of a is less than the secondary key of b; etc.  An example of multi-keyed data is strings. The first character of a string is its primary key, its second character is its secondary key, and so on. The only caveat is that the strings may not all have the same length; hence, they may not all have the same number of keys. We therefore stipulate that a string that does not have a particular key must precede all strings that have that key.\nOne algorithm to sort multi-keyed data is known as multi-key quick sort. In this section, we will describe multi-key quick sort as it applies specifically to sorting strings; however, it can be applied to other multi-keyed data as well.\nOne problem with sorting strings using a version of quick sort described in \u0026ldquo;Split Sorts\u0026rdquo; is that string comparisons can be expensive. Specifically, they must compare the strings a character at a time until they reach either a mismatch or the end of a string. Thus, comparing strings that have a long prefix in common is expensive. Now observe that quick sort operates by splitting the array into smaller and smaller pieces whose elements belong near each other in the sorted result. It is therefore common to have some pieces whose elements all begin with the same long prefix.\nMulti-key quick sort improves the performance by trying to avoid comparing prefixes after they have already been found to be the same (though the suffixes may differ). In order to accomplish this, it uses an extra int parameter k such that all the strings being sorted match in their first k positions (and by implication, all strings have length at least k). We can safely use a value of 0 in the initial call, but this value can increase as recursive calls are made.\nBecause all strings begin with the same prefix of length k, we can focus on the character at location k (i.e., following the first k characters) of each string. We need to be careful, however, because some of the strings may not have a character at location k. We will therefore use an int to store the value of the character at location k of a string, letting $-1$ denote the absence of a character at that location.\nThe algorithm then proceeds a lot like those described in \u0026ldquo;Split Sorts\u0026rdquo;. If the number of elements being sorted is greater than $1$, a pivot element p is found. Note that p is not a string, but an int representing a character at location k, as described above. The elements are then partitioned into groups of strings whose character at location k is less than p, equal to p, or greater than p, respectively.\nAfter these three groups are formed, the first and third group are sorted recursively using the same value for k. Furthermore, the second group may not be completely sorted yet \u0026mdash; all we know is that all strings in this group agree on the first k + 1 characters. Thus, unless p is $-1$ (indicating that that these strings all have length k, and are therefore all equal), we need to recursively sort this group as well. However, because we know that the strings in this group all agree on the first k + 1 characters, we pass k + 1 as the last parameter.\nOne aspect of this algorithm that we need to address is whether the recursion is valid. Recall that when we introduced recursion, we stated that in order to guarantee termination, all recursive calls must be on smaller problem instances, where the size of a problem instance is given by a nonnegative integer. In the algorithm described above, we might reach a point at which all of the strings being sorted match in location k. In such a case, the second recursive call will contain all of the strings.\nBy being careful how we define the size of the problem instance, however, we can show that this recursion is, in fact, valid. Specifically, we define the size of the problem instance to be the number of strings being sorted, plus the total number of characters beginning at location k in all strings being sorted. Because there is at least one string containing p at location k, the number of strings in both the first and the third recursive call must be smaller, while the total number of characters beginning at location k can be no larger. Because k increases by $1$ in the second recursive call, the total number of characters past this location must be smaller, while the number of strings can be no larger. Hence, the size decreases in all recursive calls.\nThe fact that we are doing recursion on the length of strings, however, can potentially cause the runtime stack to overflow when we are sorting very long strings. For this reason, it is best to convert the recursive call on the second group to a loop. We can do this by changing the if-statement that controls whether the splitting will be done into a while-loop that iterates as long as the portion being sorted is large enough to split. Then at the bottom of the loop, after doing recursive calls on the first and third parts, we check to see if p is $-1$ \u0026mdash; if so, we exit the loop. Otherwise, we do the following:\n increment k; change the index giving the start of the portion we are sorting to the beginning of the second part; and change the length of the portion we are sorting to the length of the second part.  The next iteration will then sort the second part.\nThis algorithm can be combined with insertion sort and heap sort, as was done for introsort in the previous section. However, we should also modify insertion sort and heap sort to use the information we already have about equal prefixes when we are comparing elements. Specifically, rather than comparing entire strings, we should begin comparing after the equal prefix. Because of the way multi-key quick sort does comparisons, the result tends to perform better than the single-key versions, assuming similar optimizations are made; however, cutoffs for running insertion sort and/or heap sort may need to be adjusted.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/debugger/",
	"title": "The Debugger",
	"tags": [],
	"description": "",
	"content": "The Debugger In previous sections, we discussed how a Windows Forms Application can be built using Visual Studio. Having built an application, we need to be able to run and test it. To do this, we use the Visual Studio Debugger. When an application is loaded into Visual Studio, we can invoke the debugger by clicking the \u0026ldquo;Start\u0026rdquo; button near the top:\nNote\nA Visual Studio bug has sometimes caused this button to be missing. If this happens, you can instead click \u0026ldquo;Start Debugging\u0026rdquo; on the \u0026ldquo;Debug\u0026rdquo; menu.\n When the debugger starts, it attempts to do the following things:\n Save any unsaved files. Compile the source code into executable code. Run the compiled code as an application.  If everything works correctly, the application is complete. Rarely, however, does everything work correctly the first time. Through the remainder of this section, we will discuss some of the ways the debugger can be used to find and fix errors.\nOne of the problems that can occur is that the compiler can fail to produce executable code because the source code contains syntax errors. When this happens, the following dialog is displayed:\nUsually the best thing to do at this point is to click the \u0026ldquo;No\u0026rdquo; button. This will stop the debugger and open an Error List window containing all of the syntax errors found. Double-clicking on a syntax error will highlight the error in the code window. Normally, fixing the error will cause the corresponding entry in the Error List to disappear; however, there are times when the entry won\u0026rsquo;t disappear until the debugger is started again (i.e., by clicking the \u0026ldquo;Start\u0026rdquo; button).\nOnce the syntax errors are removed, the debugger will be able to generate executable code and run it. However, more problems can occur at this point. One common problem is that an exception is thrown. For example, the GitHub repository created by this invitation link (see \u0026ldquo;Git Repositories\u0026quot;) contains a Visual Studio solution for a program to convert decimal numbers to base-16. Don\u0026rsquo;t worry about understanding the code, although the numerous comments may help you to do that. Instead, note that an exception is thrown when we try to convert 256:\nThis message gives us quite a bit of information already. First, it tells us which line threw the exception - the line highlighted in green. The arrow in the left margin tells us the same thing, but more generally, when the debugger is running, it indicates the line that is currently being executed or that is ready to be executed. The popup window indicates what kind of exception was thrown: an ArgumentOutOfRangeException. It also provides the additional information that a length was less than zero when it should not have been.\nHaving this information, we can now use the debugger to investigate further the cause of the exception. First, in order to see the code more clearly, we might want to close the popup window (we can always get it back by clicking the red circle containing the white \u0026lsquo;X\u0026rsquo;). We can now examine the values of any of the variables at the time the exception was thrown by hovering the mouse over them. For example, if we hover over lowOrder, a popup appears indicating that it has a value of \u0026ldquo;0\u0026rdquo;. If we move the mouse to hover over its Length property, we can see that it has a value of 1. Hovering over power shows that it has a value of 2. Thus, we can see that the exception was thrown because we gave the Substring method a length of 1 - 2 = -1. This can be confirmed by hovering the mouse over the \u0026ldquo;-\u0026rdquo; in the expression - the popup indicates that the value of the expression is, in fact, -1.\nActually fixing the error requires a little more understanding of the code. In this case, however, the comment immediately above the line in question helps us out. It tells us that the low-order part of the hex string we are building may need to be padded with 0s - this padding is what we are constructing. Furthermore, it tells us that the number of hex digits we need is the value of power. In order to get this many digits, we need to subtract the number of hex digits we already have in lowOrder from power; i.e., we need to reverse the order of the subtraction. However, we can\u0026rsquo;t make the correction until we stop the debugger.\n To stop the debugger, notice the buttons that are available at the top of the Visual Studio window while the debugger is running:\nAs you might guess, the \u0026ldquo;Stop\u0026rdquo; button stops the debugger. In what follows, we will discuss each of the other buttons indicated in the above figure, as well as other features of the debugger.\n\nWhen debugging code, it is often useful to be able to pause execution at a particular place in order to be able to examine the values of variables as we did above. To accomplish this, we can set a breakpoint by clicking in the left margin of the code window at the line where we would like execution to pause. This places a large red dot in the margin where we clicked and colors the line red:\nWhenever execution reaches a breakpoint, execution stops prior to executing that line. At this point, we can examine the values of variables as we described above. When we are ready to continue execution of the program, we click the \u0026ldquo;Continue\u0026rdquo; button. A breakpoint can be deleted by clicking on the red dot, or all breakpoints may be deleted by selecting \u0026ldquo;Delete All Breakpoints\u0026rdquo; from the \u0026ldquo;Debug\u0026rdquo; menu.\nSometimes we only want the execution to pause at a breakpoint when a certain condition is met. Such a situation might occur if we have a bug that only surfaces after the code containing it has already executed many times. Rather than letting the program stop and clicking \u0026ldquo;Continue\u0026rdquo; until we reach the point we are interested in, we can instead specify a condition on the breakpoint. To do this, right-click on the breakpoint in the left margin, and select \u0026ldquo;Conditions\u0026hellip;\u0026rdquo; from the resulting popup menu. This causes a large box to be inserted into to the code below this line:\nIn this box, we can type an expression using variables visible at that program location. We can also choose whether we want execution to pause when that expression is true or whenever that expression has changed.\nFor example, we could add to the above breakpoint the condition:\npower == 8 Then when we run the debugger, execution will only pause at this breakpoint when power reaches a value of 8. Note that this line is executed at the top of each iteration of the loop; hence, the breakpoint condition is checked on each iteration.\nWhile hovering the mouse over variable names is a useful way to discover their current values, there are other mechanisms for doing this as well. For example, while the debugger is paused, you can go to the \u0026ldquo;Debug\u0026rdquo; menu and select \u0026ldquo;Windows -\u0026gt; Locals\u0026rdquo;. This will open a window displaying all of the local variables for the current method, property, or constructor, together with their current values. If the debugger is paused within a constructor or a non-static method or property, this window also contains this, which refers to the object that contains the constructor, method, or property. From this, you can access the non-static fields of this object.\nAnother mechanism for examining values of variables is through the \u0026ldquo;Immediate\u0026rdquo; window, which can also be accessed from the \u0026ldquo;Debug\u0026rdquo; menu via its \u0026ldquo;Windows\u0026rdquo; sub-menu. Within the Immediate window, you may type an expression involving the variables that are currently visible, press \u0026ldquo;Enter\u0026rdquo;, and it will display the value of that expression. This can be particularly useful when you have a large data structure, and you need to know a particular element in that structure. For example, suppose array is a large int[ ], and suppose i is an int. Using the \u0026ldquo;Locals\u0026rdquo; window, it might be rather tedious to find the value of array[i]. Using the Immediate window, however, you can just type in\narray[i] and it will display its value.\nWhen debugging, it is often useful to be able to step through the execution of a piece of code so that you can see exactly what it is doing. Three buttons are available for this purpose: \u0026ldquo;Step Into\u0026rdquo;, \u0026ldquo;Step Over\u0026rdquo;, and \u0026ldquo;Step Out\u0026rdquo;. Suppose we were to run the code in the GitHub repository provided above with the (unconditional) breakpoint shown in the above picture, and suppose we were to enter the value, 12345. Execution will then pause at this breakpoint with divisor equal to 16 and power equal to 1. Clicking either the \u0026ldquo;Step Into\u0026rdquo; button or the \u0026ldquo;Step Over\u0026rdquo; button will cause the debugger to evaluate the loop condition and, because its value is true, advance to the \u0026ldquo;{\u0026rdquo; on the next line. We may continue to walk through the execution a step at a time using either of these buttons - as long as we are in this loop, they will have the same effect. If the Locals window is open, whenever a variable changes value, this value will be shown in red.\nAfter one iteration, the loop will terminate, and execution will reach the line where highOrder is defined. At this point, the functionality of the \u0026ldquo;Step Into\u0026rdquo; and \u0026ldquo;Step Over\u0026rdquo; buttons becomes different because this line contains a method call. The \u0026ldquo;Step Over\u0026rdquo; button will cause execution to run normally through the method call, and pause again as soon as the method call returns (however, because this is a recursive call, if the breakpoint is still set, execution will pause when it reaches the breakpoint within the recursive call). Thus, we can see the net effect of this method call without having to walk through it a step at a time. On the other hand, we might want to step through it in order to see what it is doing. We can do this using the \u0026ldquo;Step Into\u0026rdquo; button. If at some point we want to finish executing the method we are in, but pause after it returns, we can click the \u0026ldquo;Step Out\u0026rdquo; button.\nWhen stepping through code, a \u0026ldquo;Watch\u0026rdquo; window is often a convenient way to keep track of the value of one or more specific variables and/or expressions. You can open a Watch window from the \u0026ldquo;Debug\u0026rdquo; menu under \u0026ldquo;Windows -\u0026gt; Watch\u0026rdquo; \u0026mdash; the four choices here are four different Watch windows that you may use (perhaps for debugging different parts of your program). A Watch window combines some of the advantages of the Locals window and the Immediate window. If you type in a value or expression, it will appear in the \u0026ldquo;Name\u0026rdquo; column, and if it can be evaluated in the current context, its value will be displayed in the \u0026ldquo;Value\u0026rdquo; column. Furthermore the value will be updated as the debugger executes code. You may list several values or expressions in the same Watch window, and their values will all be tracked. To delete an entry from a Watch window, right-click on it and select \u0026ldquo;Delete Watch\u0026rdquo;.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/debugger/",
	"title": "The Debugger",
	"tags": [],
	"description": "",
	"content": "The Debugger In previous sections, we discussed how a Windows Forms Application can be built using Visual Studio. Having built an application, we need to be able to run and test it. To do this, we use the Visual Studio Debugger. When an application is loaded into Visual Studio, we can invoke the debugger by clicking the \u0026ldquo;Start\u0026rdquo; button near the top:\nNote\nA Visual Studio bug has sometimes caused this button to be missing. If this happens, you can instead click \u0026ldquo;Start Debugging\u0026rdquo; on the \u0026ldquo;Debug\u0026rdquo; menu.\n When the debugger starts, it attempts to do the following things:\n Save any unsaved files. Compile the source code into executable code. Run the compiled code as an application.  If everything works correctly, the application is complete. Rarely, however, does everything work correctly the first time. Through the remainder of this section, we will discuss some of the ways the debugger can be used to find and fix errors.\nOne of the problems that can occur is that the compiler can fail to produce executable code because the source code contains syntax errors. When this happens, the following dialog is displayed:\nUsually the best thing to do at this point is to click the \u0026ldquo;No\u0026rdquo; button. This will stop the debugger. To see a list of the syntax errors, click the error list button at the bottom of the Visual Studio window:\nDouble-clicking on a syntax error will highlight the error in the code window. Normally, fixing the error will cause the corresponding entry in the Error List to disappear; however, there are times when the entry won\u0026rsquo;t disappear until the debugger is started again (i.e., by clicking the \u0026ldquo;Start\u0026rdquo; button).\nOnce the syntax errors are removed, the debugger will be able to generate executable code and run it. However, more problems can occur at this point. One common problem is that an exception is thrown. For example, the GitHub repository created by this invitation link (see \u0026ldquo;Git Repositories\u0026quot;) contains a Visual Studio solution for a program to convert decimal numbers to base-16. Don\u0026rsquo;t worry about understanding the code, although the numerous comments may help you to do that. Instead, note that an exception is thrown when we try to convert 256:\nThis message gives us quite a bit of information already. First, it tells us which line threw the exception - the line highlighted in green. The arrow in the left margin tells us the same thing, but more generally, when the debugger is running, it indicates the line that is currently being executed or that is ready to be executed. The popup window indicates what kind of exception was thrown: an ArgumentOutOfRangeException. It also provides the additional information that a length was less than zero when it should not have been.\nHaving this information, we can now use the debugger to investigate further the cause of the exception. First, in order to see the code more clearly, we might want to close the popup window (we can always get it back by clicking the red circle containing the white \u0026lsquo;X\u0026rsquo;). We can now examine the values of any of the variables at the time the exception was thrown by hovering the mouse over them. For example, if we hover over lowOrder, a popup appears indicating that it has a value of \u0026ldquo;0\u0026rdquo;. If we move the mouse to hover over its Length property, we can see that it has a value of 1. Hovering over power shows that it has a value of 2. Thus, we can see that the exception was thrown because we gave the Substring method a length of 1 - 2 = -1. This can be confirmed by hovering the mouse over the \u0026ldquo;-\u0026rdquo; in the expression - the popup indicates that the value of the expression is, in fact, -1.\nActually fixing the error requires a little more understanding of the code. In this case, however, the comment immediately above the line in question helps us out. It tells us that the low-order part of the hex string we are building may need to be padded with 0s - this padding is what we are constructing. Furthermore, it tells us that the number of hex digits we need is the value of power. In order to get this many digits, we need to subtract the number of hex digits we already have in lowOrder from power; i.e., we need to reverse the order of the subtraction. However, we can\u0026rsquo;t make the correction until we stop the debugger.\n To stop the debugger, notice the buttons that are available at the top of the Visual Studio window while the debugger is running:\nAs you might guess, the \u0026ldquo;Stop\u0026rdquo; button stops the debugger. In what follows, we will discuss each of the other buttons indicated in the above figure, as well as other features of the debugger.\nWhen debugging code, it is often useful to be able to pause execution at a particular place in order to be able to examine the values of variables as we did above. To accomplish this, we can set a breakpoint by clicking in the left margin of the code window at the line where we would like execution to pause. This places a large red dot in the margin where we clicked and colors the line red:\nWhenever execution reaches a breakpoint, execution stops prior to executing that line. At this point, we can examine the values of variables as we described above. When we are ready to continue execution of the program, we click the \u0026ldquo;Continue\u0026rdquo; button. A breakpoint can be deleted by clicking on the red dot, or all breakpoints may be deleted by selecting \u0026ldquo;Delete All Breakpoints\u0026rdquo; from the \u0026ldquo;Debug\u0026rdquo; menu.\nSometimes we only want the execution to pause at a breakpoint when a certain condition is met. Such a situation might occur if we have a bug that only surfaces after the code containing it has already executed many times. Rather than letting the program stop and clicking \u0026ldquo;Continue\u0026rdquo; until we reach the point we are interested in, we can instead specify a condition on the breakpoint. To do this, right-click on the breakpoint in the left margin, and select \u0026ldquo;Conditions\u0026hellip;\u0026rdquo; from the resulting popup menu. This causes a large box to be inserted into to the code below this line:\nIn this box, we can type an expression using variables visible at that program location. We can also choose whether we want execution to pause when that expression is true or whenever that expression has changed.\nFor example, we could add to the above breakpoint the condition:\npower == 8 Then when we run the debugger, execution will only pause at this breakpoint when power reaches a value of 8. Note that this line is executed at the top of each iteration of the loop; hence, the breakpoint condition is checked on each iteration.\nWhile hovering the mouse over variable names is a useful way to discover their current values, there are other mechanisms for doing this as well. For example, while the debugger is paused, you can go to the \u0026ldquo;Debug\u0026rdquo; menu and select \u0026ldquo;Windows -\u0026gt; Locals\u0026rdquo;. This will open a window displaying all of the local variables for the current method, property, or constructor, together with their current values. If the debugger is paused within a constructor or a non-static method or property, this window also contains this, which refers to the object that contains the constructor, method, or property. From this, you can access the non-static fields of this object.\nAnother mechanism for examining values of variables is through the \u0026ldquo;Immediate\u0026rdquo; window, which can also be accessed from the \u0026ldquo;Debug\u0026rdquo; menu via its \u0026ldquo;Windows\u0026rdquo; sub-menu. Within the Immediate window, you may type an expression involving the variables that are currently visible, press \u0026ldquo;Enter\u0026rdquo;, and it will display the value of that expression. This can be particularly useful when you have a large data structure, and you need to know a particular element in that structure. For example, suppose array is a large int[ ], and suppose i is an int. Using the \u0026ldquo;Locals\u0026rdquo; window, it might be rather tedious to find the value of array[i]. Using the Immediate window, however, you can just type in\narray[i] and it will display its value.\nWhen debugging, it is often useful to be able to step through the execution of a piece of code so that you can see exactly what it is doing. Three buttons are available for this purpose: \u0026ldquo;Step Into\u0026rdquo;, \u0026ldquo;Step Over\u0026rdquo;, and \u0026ldquo;Step Out\u0026rdquo;. Suppose we were to run the code in the GitHub repository provided above with the (unconditional) breakpoint shown in the above picture, and suppose we were to enter the value, 12345. Execution will then pause at this breakpoint with divisor equal to 16 and power equal to 1. Clicking either the \u0026ldquo;Step Into\u0026rdquo; button or the \u0026ldquo;Step Over\u0026rdquo; button will cause the debugger to evaluate the loop condition and, because its value is true, advance to the \u0026ldquo;{\u0026rdquo; on the next line. We may continue to walk through the execution a step at a time using either of these buttons - as long as we are in this loop, they will have the same effect. If the Locals window is open, whenever a variable changes value, this value will be shown in red.\nAfter one iteration, the loop will terminate, and execution will reach the line where highOrder is defined. At this point, the functionality of the \u0026ldquo;Step Into\u0026rdquo; and \u0026ldquo;Step Over\u0026rdquo; buttons becomes different because this line contains a method call. The \u0026ldquo;Step Over\u0026rdquo; button will cause execution to run normally through the method call, and pause again as soon as the method call returns (however, because this is a recursive call, if the breakpoint is still set, execution will pause when it reaches the breakpoint within the recursive call). Thus, we can see the net effect of this method call without having to walk through it a step at a time. On the other hand, we might want to step through it in order to see what it is doing. We can do this using the \u0026ldquo;Step Into\u0026rdquo; button. If at some point we want to finish executing the method we are in, but pause after it returns, we can click the \u0026ldquo;Step Out\u0026rdquo; button.\nWhen stepping through code, a \u0026ldquo;Watch\u0026rdquo; window is often a convenient way to keep track of the value of one or more specific variables and/or expressions. You can open a Watch window from the \u0026ldquo;Debug\u0026rdquo; menu under \u0026ldquo;Windows -\u0026gt; Watch\u0026rdquo; \u0026mdash; the four choices here are four different Watch windows that you may use (perhaps for debugging different parts of your program). A Watch window combines some of the advantages of the Locals window and the Immediate window. If you type in a value or expression, it will appear in the \u0026ldquo;Name\u0026rdquo; column, and if it can be evaluated in the current context, its value will be displayed in the \u0026ldquo;Value\u0026rdquo; column. Furthermore the value will be updated as the debugger executes code. You may list several values or expressions in the same Watch window, and their values will all be tracked. To delete an entry from a Watch window, right-click on it and select \u0026ldquo;Delete Watch\u0026rdquo;.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/",
	"title": "Appendices",
	"tags": [],
	"description": "",
	"content": "Appendices The appendices contain material that does not fit well into the flow of the main text. They may be used for reference as needed.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/indexers/",
	"title": "Indexers",
	"tags": [],
	"description": "",
	"content": "Indexers Recall that the System.Collections.Generic.Dictionary\u0026lt;TKey, TValue\u0026gt; class (see “The Dictionary\u0026lt;TKey, TValue\u0026gt; Class”) allows keys to be used as indices for the purpose of adding new keys and values, changing the value associated with a key, and retrieving the value associated with a key in the table. In this section, we will discuss how to implement this functionality.\nAn indexer in C# is defined using the following syntax:\npublic TValue this[TKey k] { get { // Code to retrieve the value with key k  } set { // Code to associate the given value with key k  } } Note the resemblance of the above code to the definition of a property. The biggest differences are:\n In place of a property name, an indexer uses the keyword this. The keyword this is followed by a nonempty parameter list enclosed in square brackets.  Thus, an indexer is like a property with parameters. The parameters are the indices themselves; i.e., if d is a Dictionary\u0026lt;TKey, TValue\u0026gt; and key is a TKey, d[key] invokes the indexer with parameter key. In general, either the get accessor or the set accessor may be omitted, but at least one of them must be included. As in a property definition, the set accessor can use the keyword value for the value being assigned - in this case, the value to be associated with the given key. The value keyword and the return type of the get accessor will both be of type TValue, the type given prior to the keyword this in the above code.\nWe want to implement the indexer to behave in the same way as the indexer for System.Collections.Generic.Dictionary\u0026lt;TKey, TValue\u0026gt;. Thus, the get accessor is similar to the TryGetValue method, as outlined in “A Simple Hash Table Implementation”, with a few important differences. First, the get accessor has no out parameter. Instead, it returns the value that TryGetValue assigns to its out parameter when the key is found. When the key is not found, because it can\u0026rsquo;t return a bool to indicate this, it instead throws a KeyNotFoundException.\nLikewise, the set accessor is similar to the Add method, as outlined in “A Simple Hash Table Implementation”. However, whereas the Add method has a TValue parameter through which to pass the value to be associated with the given key, the set accessor gets this value from the value keyword. Furthermore, we don\u0026rsquo;t want the set accessor to throw an exception if the key is found. Instead, we want it to replace the Data of the cell containing this key with a new KeyValuePair containing the key with the new value.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/submitting/",
	"title": "Submitting Assignments",
	"tags": [],
	"description": "",
	"content": "Submitting Assignments To submit a lab or homework assignment in CIS 300, you will need to do the following steps:\n  Refresh the changes tracked by Git. Do this by going to the Team Explorer and clicking on the circular arrow icon (i.e., ) at the top. Note that this refresh is normally done automatically; however, it occasionally is not. Doing this manual refresh helps to ensure that all of your code gets uploaded.\n  Commit your changes to your local Git repository. Do this by clicking the icon that looks like a pencil at the bottom of the Visual Studio window. The Team Explorer will now show a window titled, \u0026ldquo;Changes\u0026rdquo;. In the yellow box, type in a message to be associated with the changes you are committing. Then click \u0026ldquo;Commit All\u0026rdquo;.\n  Push your committed changes to GitHub. Do this by clicking the up-arrow icon at the bottom of the Visual Studio window. This will cause the Team Explorer to open. Click the \u0026ldquo;Push\u0026rdquo; link to push the repository to GitHub. Note that only committed changes will be pushed.\n  Submit the URL of the commit you want graded and (for lab assignments) your completed or attempted code using the submission form provided in the assignment instructions. This requires the following steps:\n  To reveal the submission form, click the \u0026ldquo;Submit Assignment\u0026rdquo; button at the top of the assignment instructions. This will cause the submission form to appear at the bottom of the page.\n  Reload the GitHub repository for this assignment in your web browser, and click on the link showing the number of commits (this is in the top right corner of the list of files and folders in the repository). This will show a list of commits, beginning with the latest. To the right of each commit is a button labeled \u0026ldquo;\u0026lt;\u0026gt;\u0026rdquo;. This button links to a web page displaying the entire contents of that commit. (It\u0026rsquo;s a good idea to check to see that all of your source code files are present, in case something went wrong.) The URL of this page will end in a 40-digit hexadecimal number giving a digital fingerprint of the commit. Copy this URL to the submission form.\n  To complete your submission, click the \u0026ldquo;Submit Assignment\u0026rdquo; button in the assignment submission form. The time at which this button was clicked will be the official submission time for your assignment.\n    Warning\nIt is important to do all four of these steps in this order. In particular, if you make any changes between your last commit and the push, these changes won\u0026rsquo;t be included in the submission. It is also important to include the correct URL. In particular, the digital fingerprint of the commit is the only reliable evidence we have that the commit was made prior to the form submission; hence, this digital fingerprint is required in order for you to receive any credit for the assignment. (For an example showing how unreliable time stamps on GitHub are, see this repository.)\n Tip\nYou can double-check that all changes have been pushed by looking at the numbers next to the up-arrow and pencil icons at the bottom of the Visual Studio window. If all changes have been pushed, both numbers should be 0.\n Occasionally, problems can occur with the interface between Visual Studio and GitHub. These problems can prevent your code from being pushed to GitHub. While the problems can often be fixed, it is often easier to bypass Visual Studio altogether, and use GitHub\u0026rsquo;s file upload mechanism.\nWarning\nThis is not the preferred assignment submission procedure because it is less automated (and hence more error-prone), and it creates a commit on GitHub that is not in your local git repository. However, it can be used if the above procedure doesn\u0026rsquo;t work for you.\n To use this alternative submission procedure, do the following steps:\n  If Visual Studio is running, exit this application, making sure all files are saved.\n  In your web browser, navigate to the repository for the assignment you are submitting. You should see a list of files and folders, including a file whose name ends with \u0026ldquo;.sln\u0026rdquo;.\n  In your Windows file browser, navigate to your project folder for this assignment. You should see the same list of files and folders as is shown in your web browser. (Depending on the settings for your local machine, you may not see file name suffixes such as \u0026ldquo;.sln\u0026rdquo; and \u0026ldquo;.gitignore\u0026rdquo;, and if you\u0026rsquo;ve added any projects that were not in the original repository, their folders may be shown in the file browser but not in the web browser.)\n  In your web browser, click the \u0026ldquo;Add file\u0026rdquo; button in the row of buttons above the list of files and folders, and select \u0026ldquo;Upload files\u0026rdquo; from the drop-down menu.\n  In your file browser, type Control-\u0026ldquo;A\u0026rdquo; to select all files and folders, and drag them to the web browser where it says, \u0026ldquo;Drag files here \u0026hellip;\u0026rdquo;. The web browser should indicate a number of files being uploaded.\n  Near the bottom of the web browser window, in the text box below \u0026ldquo;Commit changes\u0026rdquo;, type a commit message, then click the \u0026ldquo;Commit changes\u0026rdquo; at the bottom. It may take a little while to process, but eventually you should see the repository again.\n  Make sure all of your \u0026ldquo;.cs\u0026rdquo; files are present in the GitHub repository, and that they contain the code you want. (If you have removed or renamed any files, the original files may still be in the repository; however, they shouldn\u0026rsquo;t be in the solution, and therefore shouldn\u0026rsquo;t interfere with the program\u0026rsquo;s execution.)\n  Submit the URL of this commit by following Step 4 above.\n  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/submitting/",
	"title": "Submitting Assignments",
	"tags": [],
	"description": "",
	"content": "Submitting Assignments To submit a lab or homework assignment in CIS 300, you will need to do the following steps:\n  Commit your changes to your local Git repository. You will do this through the \u0026ldquo;Git Changes\u0026rdquo; tab in Visual Studio (if you don\u0026rsquo;t see this tab, click the icon that looks like a pencil at the bottom of the Visual Studio window). In the \u0026ldquo;Git Changes\u0026rdquo; tab, in the box that says \u0026ldquo;Enter a message \u0026lt;Required\u0026gt;\u0026rdquo;, type in a message to be associated with the changes you are committing. Then click \u0026ldquo;Commit All\u0026rdquo;. A message at the top of the \u0026ldquo;Git Changes\u0026rdquo; tab will indicate whether the commit was successful.\n  Push your committed changes to GitHub. Do this by clicking the up-arrow icon at the top of the \u0026ldquo;Git Changes\u0026rdquo; tab. Note that only committed changes will be pushed. A message at the top of the \u0026ldquo;Git Changes\u0026rdquo; tab will indicate whether the push was successful.\n  Submit the URL of the commit you want graded using the submission form provided in the assignment instructions. This requires the following steps:\n Reload the GitHub repository for this assignment in your web browser, and click on the link showing the number of commits (this is in the top right corner of the list of files and folders in the repository). This will show a list of commits, beginning with the latest. To the right of each commit is a button labeled \u0026ldquo;\u0026lt;\u0026gt;\u0026rdquo;. This button links to a web page displaying the entire contents of that commit. (It\u0026rsquo;s a good idea to check to see that all of your source code files are present, in case something went wrong.) The URL of this page will end in a 40-digit hexadecimal number giving a digital fingerprint of the commit. Copy this entire URL to the submission form at the bottom of the assignment. To complete your submission, click the \u0026ldquo;Submit Assignment\u0026rdquo; button in the assignment submission form. The time at which this button was clicked will be the official submission time for your assignment.    Warning\nIt is important to do all three of these steps in this order. In particular, if you make any changes between your last commit and the push, these changes won\u0026rsquo;t be included in the submission. It is also important to include the correct URL. In particular, the digital fingerprint of the commit is the only reliable evidence we have that the commit was made prior to the form submission; hence, this digital fingerprint is required in order for you to receive any credit for the assignment. (For an example showing how unreliable time stamps on GitHub are, see this repository.)\n Tip\nYou can double-check that all changes have been pushed by looking at the numbers next to the up-down-arrows and pencil icons at the bottom of the Visual Studio window. If all changes have been pushed, all numbers should be 0.\n Occasionally, problems can occur with the interface between Visual Studio and GitHub. These problems can prevent your code from being pushed to GitHub. While the problems can often be fixed, it is often easier to bypass Visual Studio altogether, and use GitHub\u0026rsquo;s file upload mechanism.\nWarning\nThis is not the preferred assignment submission procedure because it is less automated (and hence more error-prone), and it creates a commit on GitHub that is not in your local git repository. However, it can be used if the above procedure doesn\u0026rsquo;t work for you.\n To use this alternative submission procedure, do the following steps:\n  If Visual Studio is running, exit this application, making sure all files are saved.\n  In your web browser, navigate to the repository for the assignment you are submitting. You should see a list of files and folders, including a file whose name ends with \u0026ldquo;.sln\u0026rdquo;.\n  In your Windows file browser, navigate to your project folder for this assignment. You should see the same list of files and folders as is shown in your web browser. (Depending on the settings for your local machine, you may not see file name suffixes such as \u0026ldquo;.sln\u0026rdquo; and \u0026ldquo;.gitignore\u0026rdquo;, and if you\u0026rsquo;ve added any projects that were not in the original repository, their folders may be shown in the file browser but not in the web browser.)\n  In your web browser, click the \u0026ldquo;Add file\u0026rdquo; button in the row of buttons above the list of files and folders, and select \u0026ldquo;Upload files\u0026rdquo; from the drop-down menu.\n  In your file browser, type Control-\u0026ldquo;A\u0026rdquo; to select all files and folders, and drag them to the web browser where it says, \u0026ldquo;Drag files here \u0026hellip;\u0026rdquo;. The web browser should indicate a number of files being uploaded.\n  Near the bottom of the web browser window, in the text box below \u0026ldquo;Commit changes\u0026rdquo;, type a commit message, then click the \u0026ldquo;Commit changes\u0026rdquo; at the bottom. It may take a little while to process, but eventually you should see the repository again.\n  Make sure all of your \u0026ldquo;.cs\u0026rdquo; files are present in the GitHub repository, and that they contain the code you want. (If you have removed or renamed any files, the original files may still be in the repository; however, they shouldn\u0026rsquo;t be in the solution, and therefore shouldn\u0026rsquo;t interfere with the program\u0026rsquo;s execution.)\n  Submit the URL of this commit by following Step 3 of the assignment submission process given above.\n  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/static-this/",
	"title": "The Keywords static and this",
	"tags": [],
	"description": "",
	"content": "The Keywords static and this Object-oriented programming languages such as C# are centered on the concept of an object. Class and structure definitions give instructions for constructing individual objects of various types, normally by using the new keyword. When an object is constructed, it has its own fields in which values may be stored. Specifically, if type T has an int field called _length, then each object of type T will have have such a field, and each of these fields may store a different int. Thus, for example, if x and y are instances of type T, then x._length may contain 7, while y._length may contain 12.\nLikewise, we can think of each object as having its own methods and properties, as when any of these methods or properties use the fields of the containing class or structure, they will access the fields belonging to a specific object. For example, if type T contains an Add method that changes the value stored in the _length filed, then a call x.Add will potentially change the value stored in x._length.\nHowever, there are times when we want to define a field, method, or property, but we don\u0026rsquo;t want it associated with any specific object. For example, suppose we want to define a unique long value for each instance of some class C. We can define a private long field _id within this class and give it a value within its constructor. But how do we get this value in a way that ensures that it is unique? One way is to define a private static long field _nextId, as in the following code:\npublic class C { private static long _nextId = 0; private long _id; public C() { _id = _nextId; _nextId++; } // Other members could also be defined. } By defining _nextId to be static, we are specifying that each instance of C will not contain a _nextId field, but instead, there is a single _nextId field belonging to the entire class. As a result, code belonging to any instance of C can access this one field. Thus, each time an instance of C is constructed, this one field is incremented. This field therefore acts as a counter that keeps track of how many instances of C have been constructed. On the other hand, because _id is not static, each instance of C contains an _id field. Thus, when the assignment,\n_id = _nextId; is done, the value in the single _nextId field is copied to the value of the _id field belonging to the instance being constructed. Because the single _nextId field is incremented every time a new instance of C is constructed, each instance receives a different value for _id.\nWe can also define static methods or properties. For example, the MessageBox.Show(string text) method is static. Because it is static, we don\u0026rsquo;t need a MessageBox object in order to call this method - we simply call something like:\nMessageBox.Show(\u0026#34;Hello world!\u0026#34;); static methods can also be useful for avoiding NullReferenceExceptions. For example, there are times when we want to determine whether a variable x contains null, but x is of an unknown type (perhaps its type is defined by some type parameter T). In such a case, we cannot use == to make the comparison because == is not defined for all types. Furthermore, the following will never work:\nif (x.Equals(null)) { } Such code will compile, but if x is null, then calling its Equals method will throw a NullReferenceException. In all other cases, the if-condition will evaluate to false. Fortunately, a static Equals method is available to handle this situation:\nif (Equals(x, null)) { } Because this method is defined within the object class, which is a supertype of every other type in C#, we can refer to this method without specifying the containing class, just as if we had defined it in the class or structure we are writing. Because this method does not belong to individual objects, we don\u0026rsquo;t need any specific object available in order to call it. It therefore avoids a NullReferenceException.\nBecause a static method or property does not belong to any instance of its type, it cannot access any non-static members directly, as they all belong to specific instances of the type. If however, the code has access to a specific instance of the type (for example, this instance might be passed as a parameter), the code may reference non-static members of that instance. For example, suppose we were to add to the class C above a method such as:\npublic static int DoSomething(C x) { } Code inside this method would be able to access _nextID, but not _id. Furthermore, it would be able to access any static methods or properties contained in the class definition, as well as all constructors, but no non-static methods or properties. However, it may access x._id, as well as any other members of x.\nCode within a constructor or a non-static method or property can also access the object that contains it by using the keyword this. Thus, in the constructor code above, we could have written the line\n_id = _nextId; as\nthis._id = _nextId; In fact, the way we originally wrote the code is simply an abbreviation of the above line. Another way of thinking of the restrictions on code within a static method or property is that this code cannot use this, either explicitly or implicitly.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/nunit/",
	"title": "Unit Testing",
	"tags": [],
	"description": "",
	"content": "Unit Testing Some of the lab assignments in CIS 300 use a technique called unit testing for testing the correctness of your code. Unit testing is an automated technique for testing individual public methods and properties using a pre-defined set of test cases. We will be using an open-source unit-testing framework called NUnit.\nAn NUnit test suite is a separate project contained within the same solution as the project it is to test. The GitHub repositories for lab assignments that utilize unit testing will initially contain these projects, whose names will typically end with \u0026ldquo;.Tests\u0026rdquo;. You should not modify these test projects.\nA test project will contain one or more classes having the attribute, [TestFixture]. These classes will contain the specific tests, each of which is a method with the attribute, [Test]. The name of the method will briefly describe the test, and a more detailed explanation will be provided in comments.\nTo run all of the tests, go to the \u0026ldquo;Test\u0026rdquo; menu and select \u0026ldquo;Run All Tests\u0026rdquo;. This will open the Test Explorer showing output resembling the following:\nNote\nIf the \u0026ldquo;Run All Tests\u0026rdquo; menu item is disabled, you may need to open the Test Explorer first by selecting \u0026ldquo;Test Explorer\u0026rdquo; from the \u0026ldquo;Test\u0026rdquo; menu.\n Note\nTo see all of the output, you will need to open all of the elements by clicking on the small triangles to the left of each element.\n The above output shows that there were two tests in the test suite. The names of the tests are simply the names of the methods comprising the tests. The output further shows that one of the tests, LengthIsCorrect, failed, whereas the other test, FirstElementIs2, passed.\nThe goal, of course, is to get all the tests to pass. When a test fails, you will first want to refer to the comments on the test method in order to understand what it is testing. Then by clicking on the failed test in the Test Explorer, you can see exactly what failed in the test - this will appear in the panel on the right. In some cases, an unexpected result will have been produced. In such cases, the message will show what result was expected, and what it actually was. In other cases, an exception will have been thrown. In such cases, the exception will be displayed. A stack trace will also be displayed, so that you can tell what line of code threw the exception. Finally, you can run the debugger on the test itself by right-clicking on the test and selecting \u0026ldquo;Debug\u0026rdquo;. This will allow you to debug your code using the techniques describe in the section, \u0026ldquo;The Debugger”.\nTip\nYou can dock the Team Explorer into the main Visual Studio window by clicking on the small triangle in the far upper-right corner of the window and selecting either \u0026ldquo;Dock\u0026rdquo; or \u0026ldquo;Dock as Tabbed Document\u0026rdquo;.\n One potential error deserves special mention. Sometimes code will throw an exception that cannot be caught by a try-catch block. By far the most common of these exceptions is the StackOverflowException. When this exception is thrown during unit testing, the test explorer will simply show some or all of the tests in gray letters. This indicates that these tests were not completed. To see why the tests were not completed, you can open the \u0026ldquo;Output\u0026rdquo; window and change the drop-down menu at the top to \u0026ldquo;Tests\u0026rdquo;. This will indicate what error stopped the tests; for example, the following indicates that a StackOverflowException has occurred:\nUnfortunately, when this error occurs, it\u0026rsquo;s more difficult to determine which test caused the exception. You can run the debugger on each test individually to see if it throws a StackOverflowException. In many cases, however, it is easier to examine each recursive call to make sure the call is made on a smaller problem instance.\nWhen you believe you have fixed any errors in your code, you will usually want to run all the tests again, as fixing one error can sometimes introduce another. However, there are times, such as when some of the tests are slow, when you don\u0026rsquo;t want to run all the tests. In such cases, you can select an appropriate alternative from the \u0026ldquo;Run\u0026rdquo; drop-down at the top of the Test Explorer (i.e., from the drop-down button with the single green triangle on it). A useful option from this menu is \u0026ldquo;Run Failed Tests\u0026rdquo;. Alternatively, you can select one or more tests from the Test Explorer (use Ctrl-Click to select multiple tests), then right-click and select \u0026ldquo;Run\u0026rdquo;.\nWhenever you run fewer than all the tests, the tests that were not run are dimmed in the Test Explorer to indicate that these results are not up to date. Be sure you always finish by running all the tests to make sure they all pass on the same version of your code.\nNew Project...\". In the panel on the left, under \"Visual C#\", select \"Test\". Then in the large panel on the right, select \"NUnit 3 Unit Test Project\". At the bottom, select an appropriate name for the project, and click \"OK\". This will create a test project containing the class file, **TestClass.cs**, which you may rename if you wish. This class is initialized with a trivial test method, which you may either remove or edit. In order to allow your test project to access the project it is to test, you will need to add to your test project a reference to the project it will test. First, however, you need to correct a problem with the way Visual Studio creates the test project. In the Solution Explorer, double-click on \"Properties\" within the project you wish to test. Take note of the .NET Framework version that appears under \"Target framework:\". Now return to the Solution Explorer, and double-click \"Properties\" with your test project. Under \"Target framework:\", change the version to match the version for the project you wish to test, and click \"Yes\" in the resulting dialog. Return once more to the Solution Explorer, right-click on the test project name, and select \"Add-\\Reference...\". In the resulting dialog, click on \"Projects\" on the left, click the check box next to the project you wish to test, and click \"OK\". You are now ready to begin writing your tests. Each test should be a single method having the **\\[Test\\]** attribute and an empty parameter list. Each method will need to contain code to set up and conduct a single test for the code in your project. Once you have collected all the output from the test, you will need to check its correctness. Within NUnit 3, this is typically done with the **static** method **Assert.That**. There are several overloads for this method, but the one we will discuss takes two parameters. The first is the output that you wish to check - it may be of any type. The second is a *constraint* that specifies a condition that the first parameter must satisfy in order to be correct. Constraints are typically generated using one of the **static** classes **Is** or **Has**. For example, the **Is** class has a method **EqualTo** that takes an **object** as its only parameter, and returns a constraint that specifies equality to the given object. Thus, we can assert that the **int** variable `n` has a value of 10 with the following statement: ```C# Assert.That(n, Is.EqualTo(10)); ``` Each constraint contains the properties **And** and **Or**, which can be used to combine constraints logically. For example, we can assert that 0 ≤ n ≤ 10 as follows: ```C# Assert.That(n, Is.GreaterThanOrEqualTo(0).And.LessThanOrEqualTo(10)); ``` There is also a property **Not**, both in the **Is** class and in the objects returned by the **And** and **Or** properties. For example: ```C# Assert.That(n, Is.Not.InRange(0, 10).And.Not.InRange(100, 200)); ``` All of the constraints available are documented at . The constraints on that page are listed by their names; however, the names themselves are rarely used in writing assertions in test code. Because the names are descriptive, it is usually easy to find the one you want. Once you have found it, click on the link for documentation on how to use it. Pay attention to how it is used with **Is** or **Has**. It is usually not hard to express the assertion you need. When writing tests, it is possible to include multiple assertions within the same method. If one of the assertions fails, none of the subsequent assertions is checked. It is usually best, however, to include only one assertion within each method. -- "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/nunit/",
	"title": "Unit Testing",
	"tags": [],
	"description": "",
	"content": "Unit Testing Some of the lab assignments in CIS 300 use a technique called unit testing for testing the correctness of your code. Unit testing is an automated technique for testing individual public methods and properties using a pre-defined set of test cases. We will be using an open-source unit-testing framework called NUnit.\nAn NUnit test suite is a separate project contained within the same solution as the project it is to test. The GitHub repositories for lab assignments that utilize unit testing will initially contain these projects, whose names will typically end with \u0026ldquo;.Tests\u0026rdquo;. You should not modify these test projects.\nA test project will contain one or more classes having the attribute, [TestFixture]. These classes will contain the specific tests, each of which is a method with the attribute, [Test]. The name of the method will briefly describe the test, and a more detailed explanation will be provided in comments.\nTo run the tests, first go to the \u0026ldquo;Test\u0026rdquo; menu and select \u0026ldquo;Test Explorer\u0026rdquo;. This will open the Test Explorer, which should resemble the following:\nNote\nDepending on whether the test project has been successfully compiled, the tests in the large panel may or may not be shown.\n Then click the \u0026ldquo;Run All Tests in View\u0026rdquo; button in the upper-left corner of the Test Explorer. The Test Explorer should then show the results of all the tests:\nNote\nTo see all of the output, you will need to open all of the elements either by clicking on the small triangles to the left of each element or by clicking the icon containing the \u0026lsquo;+\u0026rsquo; symbol.\n The above output shows that there were two tests in the test suite. The names of the tests are simply the names of the methods comprising the tests. The output further shows that one of the tests, LengthIsCorrect, failed, whereas the other test, FirstElementIs2, passed.\nThe goal, of course, is to get all the tests to pass. When a test fails, you will first want to refer to the comments on the test method in order to understand what it is testing. Then by clicking on the failed test in the Test Explorer, you can see exactly what failed in the test - this will appear in the panel on the right. In some cases, an unexpected result will have been produced. In such cases, the message will show what result was expected, and what it actually was. In other cases, an exception will have been thrown. In such cases, the exception will be displayed. A stack trace will also be displayed, so that you can tell what line of code threw the exception. Finally, you can run the debugger on the test itself by right-clicking on the test and selecting \u0026ldquo;Debug\u0026rdquo;. This will allow you to debug your code using the techniques describe in the section, “The Debugger”.\nTip\nYou can dock the Team Explorer into the main Visual Studio window by clicking on the small triangle in the far upper-right corner of the window and selecting either \u0026ldquo;Dock\u0026rdquo; or \u0026ldquo;Dock as Tabbed Document\u0026rdquo;.\n One potential error deserves special mention. Sometimes code will throw an exception that cannot be caught by a try-catch block. By far the most common of these exceptions is the StackOverflowException. When this exception is thrown during unit testing, the test explorer will simply show some or all of the tests in gray letters. This indicates that these tests were not completed. To see why the tests were not completed, you can open the \u0026ldquo;Output\u0026rdquo; window from the \u0026ldquo;View\u0026rdquo; menu and change the drop-down menu at the top to \u0026ldquo;Tests\u0026rdquo;. This will indicate what error stopped the tests; for example, the following indicates that a StackOverflowException has occurred:\nUnfortunately, when this error occurs, it\u0026rsquo;s more difficult to determine which test caused the exception. You can run the debugger on each test individually to see if it throws a StackOverflowException. In many cases, however, it is easier to examine each recursive call to make sure the call is made on a smaller problem instance.\nWhen you believe you have fixed any errors in your code, you will usually want to run all the tests again, as fixing one error can sometimes introduce another. However, there are times, such as when some of the tests are slow, when you don\u0026rsquo;t want to run all the tests. In such cases, you can select an appropriate alternative from the \u0026ldquo;Run\u0026rdquo; drop-down at the top of the Test Explorer (i.e., from the drop-down button with the single green triangle on it). A useful option from this menu is \u0026ldquo;Run Failed Tests\u0026rdquo;. Alternatively, you can select one or more tests from the Test Explorer (use Ctrl-Click to select multiple tests), then right-click and select \u0026ldquo;Run\u0026rdquo;.\nWhenever you run fewer than all the tests, the tests that were not run are dimmed in the Test Explorer to indicate that these results are not up to date. Be sure you always finish by running all the tests to make sure they all pass on the same version of your code.\nNew Project...\". In the panel on the left, under \"Visual C#\", select \"Test\". Then in the large panel on the right, select \"NUnit 3 Unit Test Project\". At the bottom, select an appropriate name for the project, and click \"OK\". This will create a test project containing the class file, **TestClass.cs**, which you may rename if you wish. This class is initialized with a trivial test method, which you may either remove or edit. In order to allow your test project to access the project it is to test, you will need to add to your test project a reference to the project it will test. First, however, you need to correct a problem with the way Visual Studio creates the test project. In the Solution Explorer, double-click on \"Properties\" within the project you wish to test. Take note of the .NET Framework version that appears under \"Target framework:\". Now return to the Solution Explorer, and double-click \"Properties\" with your test project. Under \"Target framework:\", change the version to match the version for the project you wish to test, and click \"Yes\" in the resulting dialog. Return once more to the Solution Explorer, right-click on the test project name, and select \"Add-\\Reference...\". In the resulting dialog, click on \"Projects\" on the left, click the check box next to the project you wish to test, and click \"OK\". You are now ready to begin writing your tests. Each test should be a single method having the **\\[Test\\]** attribute and an empty parameter list. Each method will need to contain code to set up and conduct a single test for the code in your project. Once you have collected all the output from the test, you will need to check its correctness. Within NUnit 3, this is typically done with the **static** method **Assert.That**. There are several overloads for this method, but the one we will discuss takes two parameters. The first is the output that you wish to check - it may be of any type. The second is a *constraint* that specifies a condition that the first parameter must satisfy in order to be correct. Constraints are typically generated using one of the **static** classes **Is** or **Has**. For example, the **Is** class has a method **EqualTo** that takes an **object** as its only parameter, and returns a constraint that specifies equality to the given object. Thus, we can assert that the **int** variable `n` has a value of 10 with the following statement: ```C# Assert.That(n, Is.EqualTo(10)); ``` Each constraint contains the properties **And** and **Or**, which can be used to combine constraints logically. For example, we can assert that 0 ≤ n ≤ 10 as follows: ```C# Assert.That(n, Is.GreaterThanOrEqualTo(0).And.LessThanOrEqualTo(10)); ``` There is also a property **Not**, both in the **Is** class and in the objects returned by the **And** and **Or** properties. For example: ```C# Assert.That(n, Is.Not.InRange(0, 10).And.Not.InRange(100, 200)); ``` All of the constraints available are documented at . The constraints on that page are listed by their names; however, the names themselves are rarely used in writing assertions in test code. Because the names are descriptive, it is usually easy to find the one you want. Once you have found it, click on the link for documentation on how to use it. Pay attention to how it is used with **Is** or **Has**. It is usually not hard to express the assertion you need. When writing tests, it is possible to include multiple assertions within the same method. If one of the assertions fails, none of the subsequent assertions is checked. It is usually best, however, to include only one assertion within each method. -- "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/out-ref/",
	"title": "out and ref Parameters",
	"tags": [],
	"description": "",
	"content": "out and ref Parameters Normally, when a method is called, the call-by-value mechanism is used. Suppose, for example, we have a method:\nprivate void DoSomething(int k) { } We can call this method with a statement like:\nDoSomething(n); provided n is an initialized variable consistent with the int type. For example, suppose n is an int variable containing a value of 28. The call-by-value mechanism works by copying the value of n (i.e., 28) to k. Whatever the DoSomething method may do to k has no effect on n \u0026mdash; they are different variables. The same can be said if we had instead passed a variable k \u0026mdash; the k in the calling code is still a different variable from the k in the DoSomething method. Finally, if we call DoSomething with an expression like 9 + n, the mechanism is the same.\nIf a parameter is of a reference type, the same mechanism is used, but it is worth considering that case separately to see exactly what happens. Suppose, for example, that we have the following method:\nprivate void DoSomethingElse(int[] a) { a[0] = 1; a = new int[10]; a[1] = 2; } Further suppose that we call this method with\nint[] b = new int[5]; DoSomethingElse(b); The initialization of b above assigns to b a reference to an array containing five 0s. The call to DoSomethingElse copies the value of b to a. Note, however, that the value of b is a reference; hence, after this value is copied, a and b refer to the same five-element array. Therefore, when a[0] is assigned 1, b[0] also becomes 1. When a is assigned a new array, however, this does not affect b, as b is a different variable \u0026mdash; b still refers to the same five-element array. Furthermore, when a[1] is assigned a value of 2, because a and b now refer to different arrays, the contents of b are unchanged. Thus, when DoSomethingElse completes, b will refer to a five-element array whose element at location 0 is 1, and whose other elements are 0.\nWhile the call-by-value mechanism is used by default, another mechanism, known as the call-by-reference mechanism, can be specified. When call-by-reference is used, the parameter passed in the calling code must be a variable, not a property or expression. Instead of copying the value of this variable into the corresponding parameter within the method, this mechanism causes the variable within the method to be an alias for the variable being passed. In other words, the two variables are simply different names for the same underlying variable (consequently, the types of the two variables must be identical). Thus, whatever changes are made to the parameter within the method are reflected in the variable passed to the method in the calling code as well.\nOne case in which this mechanism is useful is when we would like to have a method return more than one value. Suppose, for example, that we would like to find both the maximum and minimum values in a given int[ ]. A return statement can return only one value. Although there are ways of packaging more than one value together in one object, a cleaner way is to use two parameters that use the call-by-reference mechanism. The method can then change the values of these variables to the maximum and minimum values, and these values would be available to the calling code.\nSpecifically, we can define the method using out parameters:\nprivate void MinimumAndMaximum(int[] array, out int min, out int max) { min = array[0]; max = array[0]; for (int i = 1; i \u0026lt; array.Length; i++) { if (array[i] \u0026lt; min) { min = array[i]; } if (array[i] \u0026gt; max) { max = array[i]; } } } The out keyword in the first line above specifies the call-by-reference mechanism for min and max. We could then call this code as follows, assuming a is an int[ ] containing at least one element:\nint minimum; int maximum; MinimumAndMaximum(a, out minimum, out maximum); When this code completes, minimum will contain the minimum element in a and maximum will contain the maximum element in a.\nWarning\nWhen using out parameters, it is important that the keyword out is placed prior to the variable name in both the method call and the method definition. If you omit this keyword in one of these places, then the parameter lists won\u0026rsquo;t match, and you\u0026rsquo;ll get a syntax error to this effect.\n Tip\nAs a shorthand, you can declare an out parameter in the parameter list of the method call. Thus, the above example could be shortened to the following single line of code:\nMinimumAndMaximum(a, out int minimum, out int maximum);  Note that out parameters do not need to be initialized prior to the method call in which they are used. However, they need to be assigned a value within the method to which they are passed. Another way of using the call-by-reference mechanism places a slightly different requirement on where the variables need to be initialized. This other way is to use ref parameters. The only difference between ref parameters and out parameters is that ref parameters must be initialized prior to being passed to the method. Thus, we would typically use an out parameter when we expect the method to assign it its first value, but we would use a ref parameter when we expect the method to change a value that the variable already has (the method may, in fact, use this value prior to changing it).\nFor example, suppose we want to define a method to swap the contents of two int variables. We use ref parameters to accomplish this:\nprivate void Swap(ref int i, ref int j) { int temp = i; i = j; j = temp; } We could then call this method as follows:\nint m = 10; int n = 12; Swap(ref m, ref n); After this code is executed, m will contain 12 and n will contain 10.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/multiple/",
	"title": "Using Multiple Machines",
	"tags": [],
	"description": "",
	"content": "Using Multiple Machines Source control provides one way to access your code from multiple machines. Before you decide to do this, however, you should consider whether this is the best approach. For example, if you have a CS Account, you have a network file system (the U: drive on CS Windows systems) that you can use whenever you have internet access. From off campus, you need to tunnel into campus using a Virtual Private Network, or VPN (see the KSU Information Technology Services page on Virtual Private Networking for instructions). Once on campus, you can mount this file system as a network drive by following the instructions on the CS support page, \u0026ldquo;DiskUsage\u0026rdquo;.\nAs an alternative to the U: drive or some cloud service, you can use your GitHub repositories to store a master copy of each assignment, and clone local copies as needed on the different machines you use. Once you have code in a GitHub repository, you can clone that repository to a local machine as described in \u0026ldquo;Git Repositories\u0026rdquo;. When you are finished working on that machine, commit all changes and push them to GitHub. If at some later point you need to resume working on a machine whose Git repository is out of date, you can update it as follows:\n  Open the Visual Studio Team Explorer.\n  Click the icon that looks like a house at the top.\n  Click the \u0026ldquo;Sync\u0026rdquo; button.\n  In the \u0026ldquo;Incoming Commits\u0026rdquo; section, click \u0026ldquo;Pull\u0026rdquo;.\n  If you are careful about pushing all changes to GitHub and updating each local copy whenever you begin working on it, everything should go smoothly. Problems can occur, however, if you have made changes to a local version that is out of date, then either try to update it by pulling the GitHub copy, or try to push these changes to GitHub. In such cases, there may be conflicts between the two versions. Git will try to resolve these conflicts, but in many cases it will need help from you in determining how to merge the conflicting changes.\nIf Git needs help in resolving conflicts, the Team Explorer will show a \u0026ldquo;Resolve Conflicts\u0026rdquo; page listing the files containing the conflicts. Clicking on a file will show two versions of the file - one obtained by applying the changes made on the the local copy, and one obtained by applying the changes recorded with the GitHub copy. You may select one of these versions by clicking either \u0026ldquo;Take Source\u0026rdquo; or \u0026ldquo;Keep Target\u0026rdquo; at the bottom, or you may click the \u0026ldquo;Merge\u0026rdquo; button to select changes individually from each version. If you click the \u0026ldquo;Merge\u0026rdquo; button, checkboxes will appear next to each change in each version. Check the boxes next to the changes you want to keep. As you do this, the changes you select will be reflected in the version shown below the two original versions. You may also edit this result directly. When you are finished, click the \u0026ldquo;Accept Merge\u0026rdquo; button at the top.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/multiple/",
	"title": "Using Multiple Machines",
	"tags": [],
	"description": "",
	"content": "Using Multiple Machines Source control provides one way to access your code from multiple machines. Before you decide to do this, however, you should consider whether this is the best approach. For example, if you have a CS Account, you have a network file system (the U: drive on CS Windows systems) that you can use whenever you have internet access. From off campus, you need to tunnel into campus using a Virtual Private Network, or VPN (see the KSU Information Technology Services page on Virtual Private Networking for instructions). Once on campus, you can mount this file system as a network drive by following the instructions on the CS support page, \u0026ldquo;DiskUsage\u0026rdquo;.\nAs an alternative to the U: drive or some cloud service, you can use your GitHub repositories to store a master copy of each assignment, and clone local copies as needed on the different machines you use. Once you have code in a GitHub repository, you can clone that repository to a local machine as described in \u0026ldquo;Git Repositories\u0026rdquo;. When you are finished working on that machine, commit all changes and push them to GitHub. If at some later point you need to resume working on a machine whose Git repository is out of date, you can update it by clicking the down-arrow icon in the Visual Studio \u0026ldquo;Git Changes\u0026rdquo; tab.\nIf you are careful about pushing all changes to GitHub and updating each local copy whenever you begin working on it, everything should go smoothly. Problems can occur, however, if you have made changes to a local version that is out of date, then either try to update it by pulling the GitHub copy, or try to push these changes to GitHub. In such cases, the following message will be shown:\nAt this point, you should click the \u0026ldquo;Pull then Push\u0026rdquo; button in the above message. This usually won\u0026rsquo;t fix the problem, as indicated by an error message at the top of the \u0026ldquo;Git Changes\u0026rdquo; tab. In order to resolve the conflicts in the two versions, look in the \u0026ldquo;Unmerged Changes\u0026rdquo; section of the \u0026ldquo;Git Changes\u0026rdquo; tab. This will list the files that are different in the two versions. To resolve the conflicts in a file, right-click on it, and select \u0026ldquo;Merge\u0026hellip;\u0026rdquo;. Visual Studio will then show the two versions of the file side by side with the conflicts highlighted. If you want the version you are currently trying to push, simply click the \u0026ldquo;Take Current\u0026rdquo; button at the top. Otherwise, you can select individual portions from the two versions - the result will be shown below the two versions. When you are satisfied with the result, click the \u0026ldquo;Accept Merge\u0026rdquo; button. Once you have merged all conflicting files, you will then need to commit and push again.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/checkpointing/",
	"title": "Checkpointing",
	"tags": [],
	"description": "",
	"content": "Checkpointing Sometimes when writing code, we see that we have gone down a wrong path and would like to undo some major changes we have made. Source control can help us with this if we checkpoint by committing our changes from time to time, using commit messages that clearly describe the changes made in that commit. (Note that it is not necessary to push these commits to GitHub until you are ready to submit the assignment.) Git\u0026rsquo;s revert feature allows us to undo any of these commits.\nTo access Git\u0026rsquo;s revert feature, open the Visual Studio Team Explorer, click on the icon that looks like a house at the top, and click on \u0026ldquo;Changes\u0026rdquo;. Within the resulting \u0026ldquo;Changes\u0026rdquo; window, click on \u0026ldquo;Actions\u0026rdquo;, and select \u0026ldquo;View History\u0026hellip;\u0026rdquo; from the resulting drop-down list. This will reveal a list of all the commits for this local Git repository, with the most recent commit listed at the top. To undo all of the changes in any commit, right-click on that commit, and select \u0026ldquo;Revert\u0026rdquo; from the popup menu. The result is automatically committed.\nNote that reverting a commit only undoes changes made within that commit. If code changed in that commit was changed again later, this may result in a conflict that will need to be resolved as described in the previous section.\nSometimes what you really want to do is to roll your code back to a previous state. If you have any uncommitted changes, you will first want to discard them by going to the \u0026ldquo;Changes\u0026rdquo; window as described above, right-clicking on the top folder in the \u0026ldquo;Changes\u0026rdquo; section, and selecting \u0026ldquo;Undo Changes\u0026hellip;\u0026rdquo; from the resulting popup menu. You will then be given a confirmation dialog. Once you have discarded these changes, you can revert commits starting with the most recent, and working back to the point you want. Note that because each revert is also a commit, you can later revert a reverted commit if necessary.\nIt is also possible to undo changes to a specific file, rather than in the entire solution. You can obtain a history of the commits on a specific file by going to the Solution Explorer, right-clicking on that file, and selecting \u0026ldquo;View History\u0026hellip;\u0026rdquo; from the resulting popup menu. You can then revert any of these commits as above. You can also discard uncommitted changes to a single file by right-clicking on that file in the \u0026ldquo;Changes\u0026rdquo; list and selecting \u0026ldquo;Undo Changes\u0026hellip;\u0026rdquo; from the resulting popup menu. Be careful, however, about undoing or discarding changes on a \u0026ldquo;.Designer.cs\u0026rdquo; file, as usually when you make changes in the designer, changes are also made to the file, Resources.resx.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/checkpointing/",
	"title": "Checkpointing",
	"tags": [],
	"description": "",
	"content": "Checkpointing Sometimes when writing code, we see that we have gone down a wrong path and would like to undo some major changes we have made. Source control can help us with this if we checkpoint by committing our changes from time to time, using commit messages that clearly describe the changes made in that commit. (Note that it is not necessary to push these commits to GitHub until you are ready to submit the assignment.) Git\u0026rsquo;s revert feature allows us to undo any of these commits.\nBefore you access Git\u0026rsquo;s revert feature, you should undo any uncommitted changes. To do this, go to the \u0026ldquo;Git Changes\u0026rdquo; tab, right-click on the first line under \u0026ldquo;\u0026ldquo;Changes\u0026rdquo;, and select \u0026ldquo;Undo Changes\u0026rdquo;. You will be asked to confirm this action. This will undo any changes to that folder. If you have more folders containing changes, repeat this process for each changed folder.\nTo access Git\u0026rsquo;s revert feature, select \u0026ldquo;View Branch History\u0026rdquo; from the \u0026ldquo;Git\u0026rdquo; menu. This will reveal a list of all the commits for this local Git repository, with the most recent commit listed at the top. To undo all of the changes in any commit, right-click on that commit, and select \u0026ldquo;Revert\u0026rdquo; from the popup menu. The result is automatically committed.\nWarning\nYou should always revert commits starting with the most recent and working backwards (i.e., from the top of the list toward the bottom). Otherwise, you will probably encounter conflicts that need to be resolved, as described in the previous section. You may even reach a state in which no commits can be reverted.\n "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/foreach/",
	"title": "The foreach Statement",
	"tags": [],
	"description": "",
	"content": "The foreach Statement C# provides a foreach statement that is often useful for iterating through the elements of certain data structures. A foreach can be used when all of the following conditions hold:\n The data structure is a subtype of either IEnumerable or IEnumerable\u0026lt;T\u0026gt; for some type T. You do not need to know the locations in the data structure of the individual elements. You do not need to modify the data structure with this loop.  Warning\nMany of the data structures provided to you in CIS 300, as well as many that you are to write yourself for this class, are not subtypes of either of the types mentioned in 1 above. Consequently, we cannot use a foreach loop to iterate through any of these data structures. However, most of the data structures provided in the .NET Framework, as well as all arrays, are subtypes of one of these types.\n For example, the string class is a subtype of both IEnumerable and IEnumerable\u0026lt;Char\u0026gt;. To see that this is the case, look in the documentation for the string class. In the \u0026ldquo;Implements\u0026rdquo; section, we see all of the interfaces implemented by string. Because string implements both of these interfaces, it is a subtype of each. We can therefore iterate through the elements (i.e., the characters) of a string using a foreach statement, provided we don\u0026rsquo;t need to know the location of each character in the string (because a string is immutable, we can\u0026rsquo;t change its contents).\nSuppose, for example, that we want to find out how many times the letter \u0026lsquo;i\u0026rsquo; occurs in a string s. Because we don\u0026rsquo;t need to know the locations of these occurrences, we can iterate through the characters with a foreach loop, as follows:\nint count = 0; foreach (char c in s) { if (c == \u0026#39;i\u0026#39;) { count++; } } The foreach statement requires three pieces of information:\n The type of the elements in the data structure (char in the above example). The name of a new variable (c in the above example). The type of this variable will be the type of the elements in the data structure (i.e., char in the above example). It will take on the values of the elements as the loop iterates. Following the keyword in, the data structure being traversed (s in the above example).  The loop then iterates once for each element in the data structure (unless a statement like return or break causes it to terminate prematurely). On each iteration, the variable defined in the foreach statement stores one of the elements in the data structure. Thus, in the above example, c takes the value of a different character in s on each iteration. Note, however, that we have no access to the location containing c on any particular iteration - this is why we don\u0026rsquo;t use a foreach loop when we need to know the locations of the elements. Because c takes on the value of each character in s, we are able to count how many of them equal \u0026lsquo;i\u0026rsquo;.\nOccasionally, it may not be obvious what type to use for the foreach loop variable. In such cases, if the data structure is a subtype of IEnumerable\u0026lt;T\u0026gt;, then the type should be whatever type is used for T. Otherwise, it is safe to use object. Note, however, that if the data structure is not a subtype of IEnumerable\u0026lt;T\u0026gt;, but you know that the elements are some specific subtype of object, you can use that type for the loop variable - the type will not be checked until the code is executed. For example, ListBox is a class that implements a GUI control displaying a list of elements. The elements in the ListBox are accessed via its Items property, which gets a data structure of type ListBox.ObjectCollection. Any object can be added to this data structure, but we often just add strings. ListBox.ObjectCollection is a subtype of IEnumerable; however, it is permissible to set up a foreach loop as follows:\nforeach (string s in uxList.Items) { } where uxList is a ListBox variable. As long as all of the elements in uxList.Items are strings, no exception will be thrown.\nWhile the foreach statement provides a clean way to iterate through a data structure, it is important to keep in mind its limitations. First, it can\u0026rsquo;t even be used on data structures that aren\u0026rsquo;t subtypes of IEnumerable or IEnumerable\u0026lt;T\u0026gt;. Second, there are many cases, especially when iterating through arrays, where the processing we need to do on the elements depends on the locations of the elements. For example, consider the problem of determining whether two arrays contain the same elements in the same order. For each element of one array, we need to know if the element at the same location in the other array is the same. Because the locations are important, a foreach loop isn\u0026rsquo;t appropriate - we should use a for loop instead. Finally, a foreach should never be used to modify a data structure, as this causes unpredictable results.\nEven when a foreach would work, it is not always the best choice. For example, in order to determine whether a data structure contains a given element, we could iterate through the structure with a foreach loop and compare each element to the given element. While this would work, most data structures provide methods for determining whether they contain a given element. These methods are often far more efficient than using a foreach loop.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs-2019/class-libraries/",
	"title": "Class Libraries",
	"tags": [],
	"description": "",
	"content": "Class Libraries Besides Windows Forms Applications, the other type of Visual Studio project that we will be building in CIS 300 is a Class Library. A Class Library is not a stand-alone application, but rather a collection of code that can be used by various applications. The .NET Framework is a collection of class libraries. When we implement a data structure, we often want to place it in a class library so that it is available to a variety of applications.\nWhile it is possible to create a solution containing a single project that is a class library, in CIS 300, we will also work with solutions containing both a Class Library project and a Windows Forms Application project that will use the class library. We therefore need to know how to create a new class library project within an existing solution.\nSuppose, for example, that we have a solution containing the program from the section, \u0026ldquo;StringBuilders\u0026rdquo; (this solution may be obtained by creating Git repository using this URL). We wish to replace the implementation of StringBuilder from the .NET Framework with the class defined in \u0026ldquo;Implementation of StringBuilders\u0026rdquo;. Furthermore, we wish to place this class in a new class library. To create a new Class Library project within this solution, right-click on the solution name in the Solution Explorer (i.e., on the top line), and select \u0026ldquo;Add -\u0026gt; New Project\u0026hellip;\u0026rdquo;. From the resulting dialog, select \u0026ldquo;Class Library (.NET Framework)\u0026rdquo; and name it Ksu.Cis300.StringBuilderLibrary. For the location, use the folder containing the Git repository that includes the Visual Studio solution, so that this project will be included in the same Git repository. When the project is created, a code window containing a template for a public class definition will appear. There will be no Design window, as you are not building a graphical application (although graphical controls can be built within a class library). The names of the source file and the class should now be changed to StringBuilder using the Solution Explorer in the same way as for a Windows Forms Application. Code for the StringBuilder class can now be copied either from the section, “Implementation of StringBuilders” or the Git repository created using this URL. Although we don\u0026rsquo;t need them for this example, additional class files can be added to the project by going to the Solution Explorer, right-clicking on the project name (not the solution name), and selecting \u0026ldquo;Add -\u0026gt; Class\u0026hellip;\u0026rdquo;.\nJust having this project in the same solution isn\u0026rsquo;t enough to allow the Ksu.Cis300.StringsAndStringBuilders project to access it. In order to enable this access, we need to go back to the Solution Explorer, right-click on the Ksu.Cis300.StringsAndStringBuilders project, and select, \u0026ldquo;Add -\u0026gt; Reference\u0026hellip;\u0026rdquo;. In the resulting dialog, we open the \u0026ldquo;Project\u0026rdquo; group on the left and select \u0026ldquo;Solution\u0026rdquo; from that group, then click the box next to \u0026ldquo;Ksu.Cis300.StringBuilderLibrary\u0026rdquo; in the main panel, and click the \u0026ldquo;OK\u0026rdquo; button at the lower right. Once this is done, we can edit \u0026ldquo;UserInterface.cs\u0026rdquo; in the Ksu.Cis300.StringsAndStringBuilders project we just added, and change\nusing System.Text; to\nusing Ksu.Cis300.StringBuilderLibrary; Then wherever the class StringBuilder occurs in this file, the implementation in our class library will be used.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/vs/class-libraries/",
	"title": "Class Libraries",
	"tags": [],
	"description": "",
	"content": "Class Libraries Besides Windows Forms Applications, the other type of Visual Studio project that we will be building in CIS 300 is a Class Library. A Class Library is not a stand-alone application, but rather a collection of code that can be used by various applications. The .NET Framework is a collection of class libraries. When we implement a data structure, we often want to place it in a class library so that it is available to a variety of applications.\nWhile it is possible to create a solution containing a single project that is a class library, in CIS 300, we will also work with solutions containing both a Class Library project and a Windows Forms Application project that will use the class library. We therefore need to know how to create a new class library project within an existing solution.\nSuppose, for example, that we have a solution containing the program from the section, \u0026ldquo;StringBuilders\u0026rdquo; (this solution may be obtained by creating a Git repository using this URL). We wish to replace the implementation of StringBuilder from the .NET Framework with the class defined in \u0026ldquo;Implementation of StringBuilders\u0026rdquo;. Furthermore, we wish to place this class in a new class library. To create a new Class Library project within this solution, right-click on the solution name in the Solution Explorer (i.e., on the top line), and select \u0026ldquo;Add -\u0026gt; New Project\u0026hellip;\u0026rdquo;. From the resulting dialog, select \u0026ldquo;Class Library (.NET Framework)\u0026rdquo; and name it Ksu.Cis300.StringBuilderLibrary. For the location, use the folder containing the Git repository that includes the Visual Studio solution, so that this project will be included in the same Git repository.\nWhen the project is created, a code window containing a template for a public class definition will appear. There will be no Design window, as you are not building a graphical application (although graphical controls can be built within a class library). The names of the source file and the class should now be changed to StringBuilder using the Solution Explorer in the same way as for a Windows Forms Application. Code for the StringBuilder class can now be copied either from the section, “Implementation of StringBuilders” or the Git repository created using this URL. Although we don\u0026rsquo;t need them for this example, additional class files can be added to the project by going to the Solution Explorer, right-clicking on the project name (not the solution name), and selecting \u0026ldquo;Add -\u0026gt; Class\u0026hellip;\u0026rdquo;.\nJust having this project in the same solution isn\u0026rsquo;t enough to allow the Ksu.Cis300.StringsAndStringBuilders project to access it. In order to enable this access, we need to go back to the Solution Explorer, right-click on the Ksu.Cis300.StringsAndStringBuilders project, and select, \u0026ldquo;Add -\u0026gt; Reference\u0026hellip;\u0026rdquo;. In the resulting dialog, we open the \u0026ldquo;Project\u0026rdquo; group on the left and select \u0026ldquo;Solution\u0026rdquo; from that group, then click the box next to \u0026ldquo;Ksu.Cis300.StringBuilderLibrary\u0026rdquo; in the main panel, and click the \u0026ldquo;OK\u0026rdquo; button at the lower right. Once this is done, we can edit \u0026ldquo;UserInterface.cs\u0026rdquo; in the Ksu.Cis300.StringsAndStringBuilders project we just added, and change\nusing System.Text; to\nusing Ksu.Cis300.StringBuilderLibrary; Then wherever the class StringBuilder occurs in this file, the implementation in our class library will be used.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/enumerators/",
	"title": "Enumerators",
	"tags": [],
	"description": "",
	"content": "Enumerators As we saw in the previous section, in order for a data structure to support a foreach loop, it must be a subtype of either IEnumerable or IEnumerable\u0026lt;T\u0026gt;, where T is the type of the elements in the data structure. Thus, because Dictionary\u0026lt;TKey, TValue\u0026gt; is a subtype of IEnumerable\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt;, we can use a foreach loop to iterate through the key-value pairs that it stores. Likewise, because its Keys and Values properties get objects that are subtypes of IEnumerable\u0026lt;TKey\u0026gt; and IEnumerable\u0026lt;TValue\u0026gt;, respectively, foreach loops may be used to iterate these objects as well, in order to process all the keys or all the values stored in the dictionary. IEnumerable and IEnumerable\u0026lt;T\u0026gt; are interfaces; hence, we must define any subtypes so that they implement these interfaces. In this section, we will show how to implement the IEnumerable\u0026lt;T\u0026gt; interface to support a foreach loop.\nThe IEnumerable\u0026lt;T\u0026gt; interface requires two methods:\n public IEnumerator\u0026lt;T\u0026gt; GetEnumerator() IEnumerator IEnumerable.GetEnumerator()  The latter method is required only because IEnumerable\u0026lt;T\u0026gt; is a subtype of IEnumerable, and that interface requires a GetEnumerator method that returns a non-generic IEnumerator. Both of these methods should return the same object; hence, because IEnumerator\u0026lt;T\u0026gt; is also a subtype of IEnumerator, this method can simply call the first method:\nIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } The public GetEnumerator method returns an IEnumerator\u0026lt;T\u0026gt;. In order to get instances of this interface, we could define a class that implements it; however, C# provides a simpler way to define a subtype of this interface, or, when needed, the IEnumerable\u0026lt;T\u0026gt; interface.\nDefining such an enumerator is as simple as writing code to iterate through the elements of the data structure. As each element is reached, it is enumerated via a yield return statement. For example, suppose a dictionary implementation uses a List\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; called _elements to store its key-value pairs. We can then define its GetEnumerator method as follows:\npublic IEnumerator\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; GetEnumerator() { foreach (KeyValuePair\u0026lt;TKey, TValue\u0026gt; p in _elements) { yield return p; } } Suppose user code contains a Dictionary\u0026lt;string, int\u0026gt; called d and a foreach loop structured as follows:\nforeach (KeyValuePair\u0026lt;string, int\u0026gt; x in d) { } Then the GetEnumerator method is executed until the yield return is reached. The state of this method is then saved, and the value p is used as the value for x in the first iteration of the foreach in the user code. When this loop reaches its second iteration, the GetEnumerator method resumes its execution until it reaches the yield return a second time, and again, the current value of p is used as the value of x in the second iteration of the loop in user code. This continues until the GetEnumerator method finishes; at this point, the loop in user code terminates.\nBefore continuing, we should mention that there is a simpler way of implementing the public GetEnumerator method in the above example. Because List\u0026lt;T\u0026gt; implements IEnumerable\u0026lt;T\u0026gt;, we can simply use its enumerator:\npublic IEnumerator\u0026gt; GetEnumerator() { return _elements.GetEnumerator(); } However, the first solution illustrates a more general technique that can be used when we don\u0026rsquo;t have the desired enumerator already available. For instance, continuing the above example, suppose we wish to define a Keys property to get an IEnumerable\u0026lt;TKey\u0026gt; that iterates through the keys in the dictionary. Because the dictionary now supports a foreach loop, we can define this code to iterate through the key-value pairs in the dictionary, rather than the key-value pairs stored in the List\u0026lt;KeyVauePair\u0026lt;TKey, TValue\u0026gt;\u0026gt;:\npublic IEnumerable\u0026lt;TKey\u0026gt; Keys { get { foreach (KeyValuePair\u0026lt;TKey, TValue\u0026gt; p in this) { yield return p.Key; } } } The above code is more maintainable than iterating through the List\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; as it doesn\u0026rsquo;t depend on the specific implementation of the dictionary.\nWhile this technique usually works best with iterative code, it can also be used with recursion, although the translation usually ends up being less direct and less efficient. Suppose, for example, our dictionary were implemented as in “Binary Search Trees”, where a binary search tree is used. The idea is to adapt the inorder traversal algorithm. However, we can\u0026rsquo;t use this directly to implement a recursive version of the GetEnumerator method because this method does not take any parameters; hence, we can\u0026rsquo;t apply it to arbitrary subtrees. Instead, we need a separate recursive method that takes a BinaryTreeNode\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; as its parameter and returns the enumerator we need. Another problem, though, is that the recursive calls will no longer do the processing that needs to be done on the children - they will simply return enumerators. We therefore need to iterate through each of these enumerators to include their elements in the enumerator we are returning:\nprivate static IEnumerable\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; GetEnumerable(BinaryTreeNode\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; t) { if (t != null) { foreach (KeyValuePair\u0026lt;TKey, TValue\u0026gt; p in GetEnumerable(t.LeftChild)) { yield return p; } yield return t.Data; foreach (KeyValuePair\u0026lt;TKey, TValue\u0026gt; p in GetEnumerable(t.RightChild)) { yield return p; } } } Note that we\u0026rsquo;ve made the return type of this method IEnumerable\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; because we need to use a foreach loop on the result of the recursive calls. Then because any instance of this type must have a GetEnumerator method, we can implement the GetEnumerator method for the dictionary as follows:\npublic IEnumerator\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; GetEnumerator() { return GetEnumerable(_elements).GetEnumerator(); } In transforming the inorder traversal into the above code, we have introduced some extra loops. These loops lead to less efficient code. Specifically, if the binary search tree is an AVL tree or other balanced binary tree, the time to iterate through this enumerator is in $O(n \\lg n)$, where $n$ is the number of nodes in the tree. The inorder traversal, by contrast, runs in $O(n)$ time. In order to achieve this running time with an enumerator, we need to translate the inorder traversal to iterative code using a stack. However, this code isn\u0026rsquo;t easy to understand:\npublic IEnumerator\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; GetEnumerator() { Stack\u0026lt;BinaryTreeNode\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt;\u0026gt; s = new Stack\u0026lt;BinaryTreeNode\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt;\u0026gt;(); BinaryTreeNode\u0026lt;KeyValuePair\u0026lt;TKey, TValue\u0026gt;\u0026gt; t = _elements; while (t != null || s.Count \u0026gt; 0) { while (t != null) { s.Push(t); t = t.LeftChild; } t = s.Pop(); yield return t.Data; t = t.RightChild; } } "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/switch/",
	"title": "The switch Statement",
	"tags": [],
	"description": "",
	"content": "The switch Statement The switch statement provides an alternative to the if statement for certain contexts. It is used when different cases must be handled based on the value of an expression that can have only a few possible results.\nFor example, suppose we want to display a MessageBox containing \u0026ldquo;Abort\u0026rdquo;, \u0026ldquo;Retry\u0026rdquo;, and \u0026ldquo;Ignore\u0026rdquo; buttons. The user can respond in only three ways, and we need different code in each case. Assuming message and caption are strings, we can use the following code:\nswitch (MessageBox.Show(message, caption, MessageBoxButtons.AbortRetryIgnore)) { case DialogResult.Abort: // Code for the \u0026#34;Abort\u0026#34; button  break; case DialogResult.Retry: // Code for the \u0026#34;Retry\u0026#34; button  break; case DialogResult.Ignore: // Code for the \u0026#34;Ignore\u0026#34; button  break; } The expression to determine the case (in this example, the call to MessageBox.Show) is placed within the parentheses following the keyword switch. Because the value returned by this method is of the enumeration type DialogResult, it will be one of a small set of values; in fact, given the buttons placed on the MessageBox, this value must be one of three possibilities. These three possible results are listed in three case labels. Each of these case labels must begin with the keyword case, followed by a constant expression (i.e., one that can be fully evaluated by the compiler, as explained in the section, “Constant Fields”), followed by a colon (:). When the expression in the switch statement is evaluated, control jumps to the code following the case label containing the resulting value. For example, if the result of the call to MessageBox.Show is DialogResult.Retry, control jumps to the code following the second case label. If there is no case label containing the value of the expression, control jumps to the code following the switch statement. The code following each case label must be terminated by a statement like break or return, which causes control to jump elsewhere. (This arcane syntax is a holdover from C, except that C allows control to continue into the next case.) A break statement within a switch statement causes control to jump to the code following the switch statement.\nThe last case in a switch statement may optionally have the case label:\ndefault: This case label is analogous to an else on an if statement in that if the value of the switch expression is not found, control will jump to the code following the default case label. While this case is not required in a switch statement, there are many instances when it is useful to include one, even if you can explicitly enumerate all of the cases you expect. For example, if each case ends by returning a value, but no default case is included, the compiler will detect that not all paths return a value, as any case that is not enumerated will cause control to jump past the entire switch statement. There are various ways of avoid this problem:\n Make the last case you are handling the default case. Add a default case that explicitly throws an exception to handle any cases that you don\u0026rsquo;t expect. Add either a return or a throw following the switch statement (the first two options are preferable to this one).  It is legal to have more than one case label on the same code block. For example, if i is an int variable, we can use the following code:\nswitch (i) { case 1: // Code for i = 1  break; case 2: case 3: case 5: case 7: // Code for i = 2, 3, 5, or 7  break; case 4: case 6: case 8: // Code for i = 4, 6, or 8  break; default: // Code for all other values of i  break; } If the value of the switch expression matches any one of the case labels on a block, control jumps to that block. The same case label may not appear more than once.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/appendix/syntax/remainder/",
	"title": "The Remainder Operator",
	"tags": [],
	"description": "",
	"content": "The Remainder Operator The remainder operator (%) computes the remainder that results when one number is divided by another. Specifically, suppose m and n are of some numeric type, where n ≠ 0. We can then define a quotient q and a remainder r as the unique values such that:\n qn + r = m; q is an integer; |qn| ≤ |m|; and |r| \u0026lt; |n|.  Then m % n gives r, and we can compute q by:\n(m - r) / n Another way to think about m % n is through the following algorithm to compute it:\n Compute |m| / |n|, and remove any fractional part. If m and n have the same sign, let q be the above result; otherwise, let q be the negative of the above result. m % n is m - qn.  Examples:\n 7 % 3 = 1 -9 % 5 = -4 8 % -3 = 2 -10 % -4 = -2 6.4 % 1.3 = 1.2  "
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Data Structures in C# Rod Howell\nDept. of Computer Science\nKansas State University\nManhattan, KS 66506\nUSA\nEmail: rhowell@ksu.edu\nThis text is supplemental material for CIS 300 at Kansas State University. Its purpose is to provide a written summary of the material covered, with additional explanation and code examples beyond what are presented in class. A background of programming in Java is assumed, and an appendix summarizing some of the syntax of C# is provided. Because CIS 300 is a lab class, no attempt is made here to provide examples for all of the topics covered; instead, students are expected to provide many of their own examples through the lab exercises (in most cases, solutions to these exercises will be provided to enrolled students following the lab). We assume the use of either Visual Studio® Community 2022 or Visual Studio® Enterprise 2019.\nPlease send to Rod Howell any corrections, including typographical errors, missing images and broken links.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/homework/jjfhhsduuerqo1239jas/hw2-connectfour-description/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "User Requirements This assignment will focus on the game called Connect Four, also referred to as four in a row or four in a line. It is a two player game where each player takes turns in placing chips in a vertically standing board that has six rows and seven columns. The person who gets four of their chips in a row (diagonally, vertically, or horizontally) wins. This game can also be drawn. If the board fills up without either player getting four in a row or if there are no more moves left that enable a player to win, then that game is considered a draw. For the purposes of this assignment, you only need to worry about a draw when the board is full. You will be writing a program that lets two humans play against each other in a game of Connect Four.\n\nStarting the Assignment Begin by creating a GitHub repository using this URL, and clone it to your local machine. This repository contains a new Windows Forms Application and test cases.\nUser Interface The initial user interface of the game is quite bare. Before the program executes, the interface should look like this:\nYou can see that it is quite empty. This is because most of the UI is going to be added dynamically at run time. This image shows what you need to build in the Designer window in Visual Studio. The rest will be added through code later. The form should be locked from being able to be resized (set the FormBorderStyle property for the form to FixedSingle). The overall form should be about 430 wide by 440 tall. The initial interface has three **FlowLayoutPanel**s that will help organize our dynamic controls once they are loaded.\n The top FlowLayoutPanel has two Labels that keep track of the user\u0026rsquo;s turn. Note that to turn the background color of a Label to white, modify the BackColor property. The FlowDirection property of this panel should be set to flow from right to left. The second FlowLayoutPanel will contain all of the buttons that will place game pieces on the board. The FlowDirection property of this panel should be set to flow from left to right. The bottom FlowLayoutPanel will be used to contain all of the Labels that represent the slots on the Connect Four board. The FlowDirection property of this panel should be set to flow from top down.  The final user interface once the game is loaded should look like the following:\nInstructions for populating the UI at run time will be found below.\nThe interactions with the UI, overall, are quite simple. Each of the place buttons above each column should be bound to the uxPlaceButtonClick method described later in this assignment. This will cause a chip (GamePiece) to be placed in the last available slot. This chip should be the same color as the Player. After each click of a place button, the next player gets their turn. The label in the top right hand corner of the UI indicates who\u0026rsquo;s turn it is by using a label filled with the text and color of that player. Once a player wins or the game is a draw, a message box should appear stating who won the game. Once the user presses OK, the program should exit.\nSoftware Architecture Your program should contain these four classes, as shown in the following class diagram. Each class will\nDoubly Linked Lists We have done a lot of work with single linked lists thus far. A major drawback of the single linked list data structure is that you can only traverse the structure in a single direction. This doesn\u0026rsquo;t make it very flexible. To solve this problem, we can use a double linked list. The cells that make up the linked list are very similar to the single linked list, but in addition to the pointer to the next cell in the list, it also contains a reference to the previous cell in the list like so:\nRepresenting the Board The game board will be represented by using only double linked lists. Each cell on the board is stored in a DoubleLinkedListCell\u0026lt;GamePiece\u0026gt; in each column. The occupied cells of a single column are linked together into a doubly linked list. For each of these columns, you will have a DoubleLinkedListCell\u0026lt;DoubleLinkedListCell\u0026lt;GamePiece\u0026gt;\u0026gt; whose Data property contains the DoubleLinkedListCell\u0026lt;GamePiece\u0026gt; at the top of the column. Below is an example of a game where the red player wins diagonally (last piece placed was in column D), along with what the game looks like as the double linked lists:\nSee that the cells in each row are not connected to the adjacent columns. This means that in order to get to a particular cell, you will have to find the correct column first. This is not the most efficient representation of the Connect Four game board; however, its designed as an exercise to test your ability to navigate through linked lists and work with references.\nCode Requirements Your program should be organized into the following classes. Note that many things here are made public (not all) in order to improve accessibility for unit testing. It is important to name everything as listed since the provided unit tests will be expecting them as such. You may add additional private methods to any of the classes that help you with your implementation.\nDoubleLinkedListCell Class This is a generic class that represents a cell in a doubly linked list as described above in \u0026ldquo;Doubly Linked Lists.\u0026rdquo; Note that the Id of the cell varies depending on where the cell was created. Cells that represent a slot on the game board should have an Id that contains the column letter and the row number, ex: \u0026ldquo;A4\u0026rdquo;. The cells that are made in the constructor of the Game class keep track of only columns; therefore, these cells with have an Id that only has the column letter, ex: \u0026ldquo;A\u0026rdquo;.\nProperties   public DoubleLinkedListCell\u0026lt;T\u0026gt; Next: The publicly accessibly property that is a reference to the next cell in the list. This should have both get and set accessors using the default implementation.\n  public DoubleLinkedListCell\u0026lt;T\u0026gt; Previous: The publicly accessibly property that stores a reference to the previous cell in the list. This should have both get and set accessors using the default implementation.\n  public T Data: The publicly accessibly property for storing the information in this cell. This should have both get and set accessors using the default implementation\n  public string Id: The publicly accessibly property that is the unique identifier for the cell (see above for description). This should have both get and set accessors using the default implementation\n  Constructors  public DoubleLinkedListCell(string identifier): The public constructor for the DoubleLinkedListCell class. It should set Id to the given identifier string.  GamePiece Class The GamePiece class is a public class that represents a chip the player places in the board:\nProperties  public Color PieceColor: The public property that keeps track of what color this game piece is. This should have both get and set accessors using the default implementation public int Row: The public property that keeps track of the row that this game piece is associated with. This should have both get and set accessors using the default implementation public char Column: The public property that keeps track of which column this game piece is in. This should have both get and set accessors using the default implementation  Constructors  public GamePiece(Color color, int row, char column): The public constructor to the GamePiece class. It should initialize each of the GamePiece properties above.  PlayersTurn Enum An enumeration to make it easier to identify who\u0026rsquo;s turn it is. Should contain Red and Black. The enum keyword is used to declare an enumeration. An enumeration is a type that consists of a set of named constants. The first name (in this case Red) would have a value of 0, the second, a value of 1, and so on. But instead of using numbers to compare, we can just use the canonical representation (i.e. Red and Black). The PlayersTurn enumerator can be declared like:\npublic enum PlayersTurn { Red, Black } This enum should be placed directly inside the namespace and not inside of a class.\nGame Class The Game class is a public class to represent the game board.\nFields  public const int ColumnSize: The number of slots in each column. This should be set to 6. The const keyword is used to declare a constant. A constant field cannot be changed or modified once it is declared. public const string ColumnLabels: A string that represents all of the column labels. This should be set to ABCDEFG. public readonly Color[] PlayerColors: A readonly array that keeps track of the available colors for the players. The array should contain Color.Red and Color.Black in that order. As a refresher, see this page for how to initialize an array with values. The readonly keyword is a modifier that prevents a field from being modified except when declared or in the constructor of the class it belongs to.  Properties  public PlayersTurn Turn: The public facing property that keeps track of who\u0026rsquo;s turn it is. This should be defaulted to Red\u0026rsquo;s turn. This should have both get and set accessors using the default implementation public DoubleLinkedListCell\u0026lt;DoubleLinkedListCell\u0026lt;GamePiece\u0026gt;\u0026gt; Column: Public facing property that holds a reference to the active column header cell (this is a cell in the double linked list at the top of the image under the \u0026ldquo;Representing the Board\u0026rdquo; section). This should have both get and set accessors using the default implementation and be initialized to null.  Constructors  public Game(): This is the constructor for the Game class. For each of the column labels, use the Columns property to create the column headers double linked list as outlined in \u0026ldquo;Representing the Board\u0026rdquo; section above. Note that the columns will not have any thing placed in them, so the Data property will not need to be set here. The unit tests will be expecting that the Column property to be referencing the last column (column G) once the constructor has finished.  Methods  public void ChangeColumn(string columnId): This method sets Columns to the cell that corresponds to the given column ID. This should be a cell in the column headers doubly linked list as shown in \u0026ldquo;Representing the Board\u0026rdquo; above. You will need to search, potentially in both directions, starting from the current column. public string PlaceNewPiece(Color color, string col, out int row): This method is used to put a new GamePiece into the double linked list and should return the ID of the piece that is placed. Before creating and placing the piece, you will need to call the ChangeColumn method to make sure you are placing the piece in the right column. If the Data in that column is null then you are placing the first piece into that double linked list, otherwise, it is not the first piece so you will have to link the new piece to the existing ones in that column. public bool FindCell (char col, int row, out DoubleLinkedListCell\u0026lt;GamePiece\u0026gt; found): This method will return true/false if there is a cell from Column that matches the given row and column. This method should call ChangeColumn first in order to set Column to the correct column you should be searching in. The cell found should be returned through the out parameter. If no cell is found or the given row or column is outside the bounds of the game, the out parameter should be set to null and the method should return false. private bool Check(int row, char col, int rowDirection, int colDirection, Color color): This is a helper method to the CheckWin method. This method checks whether there are four in a row of the given color in the given direction containing the given location. The Check method should start looking at the cell at the given row and col location. Traverse through the game board in the direction given by rowDirection and colDirection and compare color to each cell. If it finds four of the given color in a row, then return true. If there are not four of the given color in the given direction, reverse direction to check the other way. If this doesn\u0026rsquo;t yield four in a row, then you can safely return false.  Note: The direction parameters help identify which axis you are checking for four in a row. There are four different axes: horizontal (rowDirection=1, colDirection=0), vertical(rowDirection=0, colDirection=1), top-right to bottom-left diagonal(rowDirection=-1, colDirection=-1), and top-left to bottom-right diagonal(rowDirection=-1, colDirection=1). It is important to remember that a winning piece may be placed in the middle of a winning sequence of pieces, so you will need to check both directions on the axis to be sure there is or is not four in a row.   public bool CheckWin(DoubleLinkedListCell\u0026lt;GamePiece\u0026gt; cell): This method checks to see if the given cell was placed in a spot that connected four game pieces of the same color in a row. It should check vertically, horizontally, diagonally from left to right, and diagonally from right to left by calling the Check helper method below.  UserInterface Class This class serves as the UI class. Overall, it will populate the UI dynamically, as well as handle all of the in-game events. The ux fields referenced relate back to the UI components as described in the above \u0026ldquo;User Interface\u0026rdquo; section.\nFields  private Game _game: Declare and instantiate this field within the UserInterface class to a new Game object. This will give the UI class access to all of the aspects of the Game class.  Methods/Event Handlers   private void SetColor(string id, Color color): This method searches for the slot Label corresponding to the given Name through the id parameter. To do this, use the Find method of the Controls property of the uxBoardContainer (the board layout panel). Cast the result of find and then set the BackColor to the given color parameter.\n  private void uxPlaceButtonClick(object sender, EventArgs e): This is the click event handler for the dynamically generated place buttons above. This event handler takes care of placing a new game piece on the board in the corresponding column. You can figure out which column you are working with by type casting the sender object to a Button and getting the Text property. You will need to place the new piece into the board\u0026rsquo;s linked list by calling PlaceNewPiece (described above in the Game class). After it is placed, be sure to set the color for the slot on the game board by calling SetColor, switch the player\u0026rsquo;s turn, and checking if this last move caused the player to win by calling CheckWin in the Game class. If the player won, display an appropriate message like \u0026ldquo;Red Wins!\u0026rdquo; and exit the game by using the code Environment.Exit(0). Also, if all of the slots were filled in that column, disable the place button so the players can\u0026rsquo;t place any more chips in that column. If the board is completely full, display that the game was a draw and exit. Hint: You can easily keep track of when the board is full by remembering the number of columns place buttons you disable.\n  private void MakeUI():This needs to be modified to load all of the buttons that place the game pieces, as well as the slots on the board. To do this, use two nested loops. The outer loop should take care of loading each place button into the second FlowLayoutPanel. The Buttons should have the following properties set:\n Text: The letter for that column Width: 45 Height: 20 Margin: 5 (top, left, right, and bottom). Note: You will need to construct a new Padding object for this value. Click: Bound to the uxPlaceButtonClick event handler. This can be done using this syntax:  theButton.Click += new EventHandler(uxPlaceButtonClick); You can add the newly created Button to the panel by calling the Add method from the Controls property of the panel. Before moving onto the next column, be sure to load this column\u0026rsquo;s slots on the board by using another loop based off of the Game.ColumnSize constant. Each slot is represented by a Label. They should be added to the UI in descending order These labels should have the following properties set\n Width: 45 Height: 45 Margin: 5 (top, right, bottom, and left) BackColor: Color.White Name: Column letter + row number  Make sure you also set the turn Label text to \u0026ldquo;Red\u0026rdquo;, the BackColor to Color.Red, and the ForColor to Color.Black before exiting the method.\n  Constructors  public UserInterface(): The default constructor that initializes the UI components. You will be modifying this constructor so that it makes a new game and calls the MakeUI method. Note that this should be done after the InitializeComponent call.  Testing There are a good number of unit tests (particularly for the Game class) that will help you in debugging and testing. Please note that while these cover a good number of cases, they are not completely exhaustive and do not test the UserInterface. You should double check the performance and behavior with the executable that was provided with the starting repository. Each player should be able to win the game in any vertical, horizontal, or diagonal direction. If a column is full, the button for placing chips in that column should be disabled to prevent any more chips from being placed in that column. If the board fills completely, make sure the game recognizes it as a draw. An example of the draw looks like this:\nSubmitting Your Assignment Be sure you commit all your changes and push your commits to your GitHub repository. (Note: Prior to committing changes, it is a good idea to refresh the Team Explorer by clicking the circular arrow icon at the top.) Then submit the entire URL of the commit that you want graded. There is no need to submit a comment, as you will not have a completion code.\nImportant: If the URL you submit does not contain the 40-hex-digit fingerprint of the commit you want graded, you will receive a 0, as this fingerprint is the only way we can verify that you completed your code prior to submitting your assignment. We will only grade the source code that is included in the commit that you submit. Therefore, be sure that the commit on GitHub contains all four \u0026ldquo;.cs\u0026rdquo; files, and that they are the version you want graded. This is especially important if you had any trouble committing or pushing your code.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/homework/needsmorecoffee44123/hw4-veb-tree-description/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "User Requirements The task for this assignment is to implement a minimum priority queue implemented using a van Emde Boas tree. The algorithms described below are adapted from Introduction to Algorithms - 3rd edition by Corman, T.H, Leiserson, C.E., Rivest, R.L., and Stein, C.\nvan Emde Boas Trees The van Emde Boas tree, aka vEB tree, is a tree that utilizes an associative array with $u$-bit integer keys. This data structure is very efficient in operations it is able to perform (this includes search, predecessor, successor, insert, and delete). Each of these operations are performed in $O($lg lg $u)$ time where $u$ is referred to as the universe of keys or maximum number of keys that can be stored. vEB trees are bounded by this universe, so the tree will always take up space of size $u$ and once created, cannot be grown or shrunk (there are some alternatives to help get around this problem, but they are not explored in this implementation). This makes vEB trees very efficient in terms of space when the tree is full, but not so much when the tree is sparse. This, along with the restriction that keys may only be positive integers, make the vEB tree impractical for many applications. However, due to its construction, it can be used to implement a priority queue faster than normal heap implementations.\nA vEB tree is constructed by segmenting its universe into $\\sqrt{u}$ vEB trees, where each subtree would be responsible for containing keys $i\\sqrt{u}$ through $(i+1)\\sqrt{u}-1$. Since the structure is implemented recursively, at each level of the tree, the universe shrinks by a factor of $\\sqrt{u}$. We can start to sketch out the basis of this segmentation like so:\nIn the above image, we have a 16 element universe where the bit $1$ indicates the presence of the corresponding number. As such, we can see that the above image contains the set of numbers ${2,3,4,5,6,14,15}$. The contents of the summary node indicate whether the corresponding child is nonempty – a 0 denotes an empty child, and a 1 denotes a nonempty child\nThe above structure could still be more efficient though. By making it a recursive tree structure, we can reduce the universe in each level by $\\sqrt{u}$, where $u = 2^k$. This would leave the root to have a universe of size $\\sqrt{u}$, then down one level, the universe would be of size $u^{1/4}$ then $u^{1/8}$… all the way down until $u = 2$. This works well for even powers of two; however, the square root of any odd power of 2 is not a whole number. Rounding up (ceiling, denoted by $\\left \\lceil{value}\\right \\rceil $) or rounding down (floor denoted by $\\left \\lfloor{value}\\right \\rfloor $ ) doesn\u0026rsquo;t always produce a universe that is a power of two. For example, $\\sqrt{8}=2.83$ rounded up or rounded down would not give the root node the correct universe. In order to allow odd powers of 2, we need to define the root of our tree to have a universe equal to the upper square root of $u$ (defined as $2^{\\left \\lceil{k/2}\\right \\rceil }$), pointing to the upper square root of $u$ subtrees containing a universe equal to the lower square root of $u$ (defined as $2^{\\left \\lfloor{k/2}\\right \\rfloor }$).\nWe also keep track of the minimum and maximum element within each tree node. Note that an element stored in min is not stored in any child of that node if the tree contains two or more elements, but the element stored in max does. We also store with each node a summary, which is another vEB tree storing as its keys the indices of the nonempty subtrees of the node. Note that its universe is therefore the upper square root of u. When an element is inserted into a subtree that is empty, the index of that subtree is also inserted into the summary. For nodes where $u = 2$ (i.e. leaf nodes), we can use $min$ and $max$ to store the elements, therefore all leaves will have a null summary and cluster. The vEB tree node structure can be seen below (Note that clusters can also be referred to as subtrees or children). The notation $vEB(u)$ indicates a vEB tree node with universe size $u$.\n![veb-tree-node-Introduction_to_algorithms-3rd Edition](veb-tree-node-Introduction_to_algorithms-3rd Edition.png)\nBut how do we know where any element gets placed within a tree? To do this, we will utilize three different functions: $$ high(key) = \\left \\lfloor{key/lowerSqrt(u)}\\right \\rfloor\\ low(key) = key\\ %\\ lowerSqrt(u)\\ index(subtree,offset) = subtree*lowerSqrt(u) + offset $$ These functions help segment out the bits in each level. We want to separate them into least significant and most significant bits in order to determine where a given key is placed. The $high$ function references the most significant $\\left \\lfloor{k/2}\\right \\rfloor $ bits, which tells us what subtree/cluster the $key$ belongs to. The $low$ function references the least $\\left \\lceil{k/2}\\right \\rceil $significant bits, which tells us the position of $key$ within that subtree (i.e., low(key) is the key added to this subtree). Finally, $index$ will compute the value of a key given the index of the subtree and the position of that key within that subtree, treating the $subtree$ index as the most significant bits and $offset$ as the least significant bits of the element.\nWe can see how these work in a vEB tree that contains the following set of numbers: $2,3,4,5,7,14,15$.The writing in orange gives the original key represented by a value. For example, 7 is expressed as a 4-bit binary number as 0111. The high-order portion tells us that it belongs in subtree 1 of the root. Its value in this node is 3 (the low-order half of 7, or 11 in binary). The high-order part of 11 tells us it is stored in subtree 1 of this subtree, and the low-order portion tells us it is stored as the value 1 in this node. Green writing indicates the cluster that the summary corresponds to. And purple writing indicates the position in the original bit vector from our earlier image. A slash indicates that that value has not been set (in our implementation, that would be -1).\nStarting the Assignment Begin by creating a GitHub repository using this URL, and clone it to your local machine. This repository contains a new C# library for a vEB tree priority queue and test cases.\nSoftware Architecture Your program should contain these four classes, as shown in the following class diagram.\nCode Requirements Your program should be organized into the following classes. Note that many things here are made public (not all) in order to improve accessibility for unit testing. It is important to name everything as listed since the provided unit tests will be expecting them as such. You may add additional private methods to any of the classes that help you with your implementation.\nVebTreeNode Class Properties  public int Min: This property stores the smallest key in this tree. This should have a public get accessor and a private set accessor using the default implementation. public int Max: This property stores the largest key in this tree. This should have a public get accessor and a private set accessor using the default implementation. public VebTreeNode[] Clusters: This property stores subtrees that correspond to clusters of bits in the vEB Tree. The number of subtrees is equal to the upper square root of the universe for a universe greater than 2. For a universe of size 2, no clusters are stored. This property should have a public get accessor and a private set accessor using the default implementation. public VebTreeNode Summary: This property stores an auxiliary tree that keeps track of which clusters contain elements. This should have a public get accessor and a private set accessor using the default implementation. public int Universe: This property keeps track of maximum number of bits/keys this tree can contain. This should have a public get accessor and a private set accessor using the default implementation.  Fields  private int _power: This private field stores the power of 2 the tree\u0026rsquo;s universe. In the discussion of the vEB tree earlier, this field represents $k$ in $2^k$.  Methods  public double LowerSquareRoot(): This method calculates the lower square root of the Universe as defined in $2^{\\left \\lfloor{k/2}\\right \\rfloor }$ public int UpperSquareRoot(): This method calculates the lower square root of the Universe, cast as an integer, as defined in $2^{\\left \\lceil{k/2}\\right \\rceil }$  Constructors   public VebTreeNode(int universeSize): This is the only constructor for the VebTreeNode class. Since the structure of a vEB tree is dependent on the size of its universe, once a tree is created, the size of its universe cannot be changed. The universe should be restricted to only positive powers of 2. If it is not, an ArgumentException should be thrown. You can check for this in a couple of ways: you can do a bit-wise and between the universe and the universe - 1. If this result is is not 0, then it is not a power of 2. You can also compare $\\left \\lfloor{\\log_2universe}\\right \\rfloor$ to $\\left \\lceil{\\log_2universe}\\right \\rceil$. If they differ, then it is not a power of 2. Note that in each of these ways, you will need to have a special case for 0.\nSince no elements have been inserted into the tree at this point, Min and Max should be initialized to -1. If the Universe is less than or equal to 2, then this node does not need a Summary or Clusters. Otherwise, the length of Clusters and the universe of Summary is equal to the upper square root of Universe. Each subtree contained in Clusters should be initialized to a VebTreeNode with a universe equal to the lower square root of Universe.\n  Methods (continued)   public int High(int key): returns which subtree the given key belongs to as described in the earlier \u0026ldquo;van Embde Boas Trees\u0026rdquo; section.\n  public int Low(int key): returns the position the given key is at within a subtree as described in the earlier \u0026ldquo;van Embde Boas Trees\u0026rdquo; section.\n  public int Index(int subtree, int offset): returns the element based from the given subtree and offset values as described in the earlier \u0026ldquo;van Embde Boas Trees\u0026rdquo; section.\n  public void Insert(int key): This recursive method inserts the given key into the tree. The key must be a positive integer that is strictly less than the Universe. If it is not, an argument exception should be thrown.\n If the value of Min has not been set, then this key is the first element to be inserted into this node, therefore we only need to set the min and max to the value of the key. Otherwise,  if the key is strictly less than the minimum element, then the key is the new smallest element so swap it with Min (i.e. key becomes the new Min and Min becomes the key we are inserting). if we are on an internal tree node (the universe is larger than 2), then we need to calculate which cluster the key should be inserted into (utilize the High and Low functions above). If this is the first key to be inserted into the corresponding cluster, then the index of that cluster should be inserted into the Summary. Recursion should be used to insert into the summary and cluster. Note that you are not strictly inserting the key into the cluster, but the position of the key within that cluster. Lastly, if the key being inserted is larger than the current maximum element, update Max.      public bool Find(int key): This recursive method searches the tree to determine whether or not the given key exists in this tree. If the key is larger than or equal to the universe, then return false as this key is outside the possible universe of keys this tree can hold. If the Min or Max are equal to the key, then this key exists in the tree, but if not, and the universe is of size 2, then the key does not exists in this tree. Otherwise, we recursively call Find on the key\u0026rsquo;s corresponding cluster, passing the position of the key in that cluster as a parameter (utilize the High and Low functions).\n  public int Successor(int key): This recursive method returns the next largest key stored in the tree after the given key. If no successor is found, then -1 is returned. Note that this key does not have to be in the tree in order for it to have a successor.\nThis method has two base cases. The first base case is that the universe is of size 2. Then if the key is 0 and Max is 1, then the successor must be 1; otherwise, no successor exists. (because if the key is 1 then no element exists here larger than the key, similar reasoning applies if the key is 0 but the Max is not set). The second base case, when the universe is not of size 2, is that if the key is greater than -1 but less than Min, then the Min is key\u0026rsquo;s successor.\nOtherwise the successor may be contained in the subtree containing the the key. Compute the index of the subtree by utilizing the High method. If the subtree at this index has Max defined and the position of the key (utilize the Low method) is less than this maximum then the successor is somewhere in that subtree, then to compute that successor, we will utilize the Index method, where the offset is the result of recursively calculating the successor of the position of the original key within the subtree.\nOtherwise, if the key\u0026rsquo;s position in the subtree is greater or equal to than the subtree\u0026rsquo;s maximum, then we compute the successors cluster (referred to as successorClusterIndex) by recursively calculating the successor of the subtree index within the Summary. If successorClusterIndex is -1 then no successor exists. Otherwise, the successor is found by by calling the Index method, using the successorClusterIndex as the subtree and the Min value contained in the subtree located at successorClusterIndex as the offset.\n  public void Remove(int keyToRemove): This recursive method handles removing the given key from the tree.\n  This method has two base cases First, if the minimum and maximum elements are the same and the keyToRemove is equal to Min, then key is the last element being removed in this node, so Min and Max should be reset to -1. Otherwise, if the universe size is 2, then we are removing the key from a leaf node, so Min and Max get set to the remaining value (this would be either 0 or 1).\n  (recursive case) Otherwise we will need to find where the key is located in the tree. If the minimum element in this node is the key, then we will be deleting the minimum value. As such, we will need to replace Min by the next smallest element in the cluster. This is done by using the Index method, where subtree is the minimum element (referred to as minIndex in this description) in the Summary and the offset is the minimum value of the cluster located at minIndex. The value returned by Index is not only the new Min, but it is also the new key we need to remove. (Remember that the minimum value is not stored anywhere in a vebTree\u0026rsquo;s children, so we will need to remove it)\nWe can now recursively remove the keyToRemove from its corresponding cluster (note that when recursively calling Remove here, you will need to pass the position of the key in the cluster, not the key itself).\nAfter the key has been removed, we will need to do a couple of checks. First, if the key removed was the last in its cluster, then we also need to remove that cluster from the summary. If this is the case, we need will also need to update Max. If the Summary\u0026rsquo;s maximum element is -1, then Max gets set to Min. Otherwise Max should be set to the maximum element in the highest numbered cluster (calculated using the Index method, using Summary.Max as the subtree and the Max of the cluster located at Summary.Max).\nOtherwise, if the key that we removed was this node\u0026rsquo;s Max, then we just deleted the maximum element. Max should then be replaced by the next largest element in the cluster (calculated using the Index method, using the subtree index of the key we removed and that subtree\u0026rsquo;s Max).\n    MinPriorityQueue Class The **MinPriorityQueue ** class is a public class that implements a minimum priority queue utilizing a vEB tree. Note that our queue can only store positive integers due to the restriction of the vEB tree implementation.\nFields  private VebTreeNode _elements: This field stores the vEB tree that represents all the elements in the minimum priority queue.  Properties  public int MinimumPriority: This property has only a get accessor that returns the minimum element from the vEB tree. If the queue is empty, this property should throw an InvalidOperationException. public int Count: This property keeps track of how many elements are in the queue. This should have a public get accessor and a private set accessor using the default implementation.  Constructors  MinPriorityQueue(int maxSize): The constructor of this class takes in the maximum number of elements the queue can have as a parameter. This is used to initialize the vEB tree stored in _elements.  Methods  public void Enqueue(int num): This method inserts the given number into the queue. public int Dequeue(): This method removes the element with the minimum priority (the smallest element) from the queue and returns it. This method should throw an InvalidOperationException if there are no elements in the queue.  Testing The unit tests given with this project provide high code coverage for both the MinPriorityQueue and the VebTreeNode classes. However, passing all of the test cases does not guarantee 100% on the homework assignment. The torture tests that verify efficiency of your solution should be able to be ran successfully on the remote desktop server within the allotted time. Most computers will be able to complete those tests well under the time limits.\nSubmitting Your Assignment Be sure you commit all your changes and push your commits to your GitHub repository. (Note: Prior to committing changes, it is a good idea to refresh the Team Explorer by clicking the circular arrow icon at the top.) Then submit the entire URL of the commit that you want graded. There is no need to submit a comment, as you will not have a completion code.\nImportant: If the URL you submit does not contain the 40-hex-digit fingerprint of the commit you want graded, you will receive a 0, as this fingerprint is the only way we can verify that you completed your code prior to submitting your assignment. We will only grade the source code that is included in the commit that you submit. Therefore, be sure that the commit on GitHub contains all four \u0026ldquo;.cs\u0026rdquo; files, and that they are the version you want graded. This is especially important if you had any trouble committing or pushing your code.\n"
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ksu-cs-textbooks.github.io/cis300/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]