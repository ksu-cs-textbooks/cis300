<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing Undo and Redo for a TextBox :: Data Structures in C#"><meta name=twitter:description content="Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/stacks-queues/undo/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing Undo and Redo for a TextBox :: Data Structures in C#"><meta property="og:description" content="Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Stacks and Queues"><meta property="article:modified_time" content="2023-06-01T15:44:17-05:00"><meta itemprop=name content="Implementing Undo and Redo for a TextBox :: Data Structures in C#"><meta itemprop=description content="Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations."><meta itemprop=dateModified content="2023-06-01T15:44:17-05:00"><meta itemprop=wordCount content="2743"><title>Implementing Undo and Redo for a TextBox :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737579063 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737579063 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737579063 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737579063 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737579063 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737579063 rel=stylesheet><link href=/cis300/css/fonts.css?1737579063 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737579063 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737579063 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1737579063 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1737579063 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737579063 rel=stylesheet><link href=/cis300/css/print.css?1737579063 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737579063 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/stacks-queues/undo/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=implementing-undo-and-redo-for-a-textbox>Implementing Undo and Redo for a <strong>TextBox</strong></h2><p>A <strong>TextBox</strong> has a rather crude Undo/Redo feature. By right-clicking on
a <strong>TextBox</strong>, a popup menu containing an Undo entry is presented. This
Undo will undo only one action, which may include several edits. An
immediate subsequent Undo will undo the Undo - in essence, a Redo. The
same behavior can be achieved using <code>Ctrl</code>+<code>Z</code>. A more powerful Undo/Redo
feature would allow an arbitrary sequence of edits to be undone, with
the option of redoing any of these Undo operations. This section
outlines various ways of implementing such a feature.</p><p>We first observe that when we perform an Undo, we want to undo the most
recent edit that has not been undone; i.e., we need LIFO access to the
edits. Likewise, when we perform a Redo, we want to redo the most recent
Undo that has not been redone. Again, we need LIFO access to the Undo
operations. We will therefore use two stacks, one to keep the edit
history, and one to keep the Undo history (i.e., the history of Undo
operations that can be redone).</p><p>Before we can define these stacks, we need to determine what we will be
storing in them; i.e., we need to determine how we will represent an
edit. We will consider several ways of doing this, but the simplest way
is to store the entire contents of the <strong>TextBox</strong> after each edit.
Proceeding in this way, we really aren&rsquo;t representing edits at all, but
we certainly would have the information we need to undo the edits.
Likewise, the Undo history would store the entire contents of the
<strong>TextBox</strong> prior to each Undo. Because the contents of the <strong>TextBox</strong>
form a <strong>string</strong>, we need two <strong>private</strong> fields, each referring to a
stack of <strong>string</strong>s:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The history of the contents of the TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Stack</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>_editingHistory</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The history of TextBox contents that have been undone and can be redone.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Stack</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>_undoHistory</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span></span></span></code></pre></div><p>Before we can proceed to implementing the Undo and Redo operations, we
need to do a bit more initialization. Note that by the way we have
defined <code>_editingHistory</code>, this stack needs to contain the initial
contents of the <strong>TextBox</strong>. Therefore, assuming the <strong>TextBox</strong> field
is named <code>uxEditBuffer</code>, we need to add the following line to the end of
the constructor of our user interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span><span class=p>);</span></span></span></code></pre></div><p>In order to support Undo and Redo, we need to be able to record the
content of <code>uxEditBuffer</code> each time it is modified. We can do this via an
event handler for the <strong>TextChanged</strong> event on the <strong>TextBox</strong>. Because
this event is the default event for a <strong>TextBox</strong>, we can add such an
event handler by double-clicking on the <strong>TextBox</strong> within the Visual
Studio® Design window. This event handler will then be called every
time the contents of the <strong>TextBox</strong> are changed.</p><p>We need to deal with one important issue before we can write the code
for this event handler. Whenever we perform an Undo or Redo operation,
we will change the contents of the <strong>TextBox</strong>. This will cause the
<strong>TextChanged</strong> event handler to be called. However, we don&rsquo;t want to
treat an Undo or a Redo in the same way as an edit by the user. For
example, if the user does an Undo, we don&rsquo;t want that Undo to be
considered an edit, or a subsequent Undo would just undo the Undo; i.e.,
it would perform a Redo rather than an Undo.</p><p>Fortunately, there is an easy way to distinguish between an edit made by
the user and a change made by the program code. A <strong>TextBox</strong> has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.modified?view=windowsdesktop-6.0#system-windows-forms-textboxbase-modified" rel=external target=_blank><strong>Modified</strong></a>
property, which is set to <strong>true</strong> when the user modifies the
<strong>TextBox</strong> contents, and is set to <strong>false</strong> when the program modifies
the contents. Thus, we only want to record the <strong>TextBox</strong> contents when
this property is <strong>true</strong>. Assuming the <strong>TextBox</strong> is named
<code>uxEditBuffer</code>, we can then set up the event handler as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a TextChanged event on the edit buffer.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>EditBufferTextChanged</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Modified</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RecordEdit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now let&rsquo;s consider how to write the <code>RecordEdit</code> method. Suppose there
are two GUI controls (e.g., menu items or buttons) called <code>uxUndo</code> and
<code>uxRedo</code>, which invoke the Undo and Redo operations, respectively. These
controls should be enabled only when there are operations to undo or
redo. Thus, initially these controls will be disabled. Whenever the user
modifies the contents of the <strong>TextBox</strong>, we need to do the following:</p><ul><li>Push the resulting text onto <code>_editingHistory</code>.</li><li>Enable <code>uxUndo</code>, as there is now an edit that can be undone.</li><li>Clear the contents of <code>_undoHistory</code>, as the last change to the
<strong>TextBox</strong> contents was not an Undo. (A <strong>Stack&lt;T></strong> has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.clear?view=net-6.0#system-collections-generic-stack-1-clear" rel=external target=_blank><strong>Clear</strong></a>
method for this purpose.)</li><li>Disable <code>uxRedo</code>.</li></ul><p>We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Records an edit made by the user.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>RecordEdit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now that we have a mechanism for recording the user&rsquo;s edits, we can
implement the Undo operation. The contents of the <strong>TextBox</strong> following
the last edit (i.e, the current contents of the <strong>TextBox</strong>) should
always be at the top of <code>_editingHistory</code>. An Undo should change the
current contents to the previous contents - i.e., to the <em>next</em>
<strong>string</strong> on <code>_editingHistory</code>. However, we don&rsquo;t want to lose the top
<strong>string</strong>, as this is the <strong>string</strong> that would need to be restored by
a subsequent Redo. Instead, we need to push this <strong>string</strong> onto
<code>_undoHistory</code>. We then need to enable <code>uxRedo</code>. In order to determine
whether <code>uxUndo</code> should be enabled, we need to know how many elements
remain in <code>_editingHistory</code>. We know there is at least one <strong>string</strong> on
this stack - the <strong>string</strong> that we placed in the <strong>TextBox</strong>. There is
an edit to undo if there is at least one more element on this stack -
i.e., if its <strong>Count</strong> is greater than 1. We therefore have the
following event handler for a Click event on <code>uxUndo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a Click event on Undo.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>UndoClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>_editingHistory</span><span class=p>.</span><span class=n>Pop</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Peek</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Count</span> <span class=p>&gt;</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The implementation of Redo is similar, but now we need to transfer a
<strong>string</strong> between the stacks in the opposite direction - we move the
top <strong>string</strong> from <code>_undoHistory</code> to <code>_editingHistory</code>. Then <code>uxRedo</code>
should be enabled if any more <strong>string</strong>s remain in <code>_undoHistory</code>. The
<strong>string</strong> we removed from <code>_undoHistory</code> should be placed in the
<strong>TextBox</strong>. Finally, <code>uxUndo</code> should be enabled. We therefore have the
following event handler for a Click event on <code>uxRedo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a Click event on Redo.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>RedoClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>_undoHistory</span><span class=p>.</span><span class=n>Pop</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Count</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Peek</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This solution will work, except that an Undo or Redo always brings the
text caret to the beginning of the <strong>TextBox</strong> contents. Furthermore, if
the <strong>TextBox</strong> contains a long <strong>string</strong>, each edit causes a long
<strong>string</strong> to be placed onto <code>_editingHistory</code>. This can quickly eat up
a lot of memory, and may eventually fill up all available storage. In
what follows, we will outline two better approaches.</p><p>The idea for both of these approaches is that instead of recording the
entire contents of the <strong>TextBox</strong> for each edit, we only record a
description of each edit. A single edit will either be an insertion or a
deletion of some text. The number of characters inserted/deleted may
vary, as the edit may be a cut or a paste (if we select a block of text
and do a paste, the <strong>TextChanged</strong> event handler is actually called
twice - once for the deletion of the selected text, and once for the
insertion of the pasted text). We can therefore describe the edit with
the following three values:</p><ul><li>A <strong>bool</strong> indicating whether the edit was an insertion or a
deletion.</li><li>An <strong>int</strong> giving the index of the beginning of the edit.</li><li>The <strong>string</strong> inserted or deleted.</li></ul><p>We can maintain this information in stacks in one of two ways. One way
is to use non-generic stacks and to push three items onto a stack for
each edit. If we do this, we need to realize that when we pop elements
from the stack, they will come out in reverse order from the way they
were pushed onto it. Alternatively, we can define a class or a
<a href=/cis300/appendix/syntax/structs/>structure</a> to represent an
edit using the three values above as <strong>private</strong> fields. We can then use
generic stacks storing instances of this type.</p><p>Whichever way we choose to represent the edits, we need to be able to
compute each of the three pieces of information describing the edit. In
order to compute this information, we need to compare the current
contents of the <strong>TextBox</strong> with its prior contents in order to see how
it changed. This means that, in addition to the two <strong>private</strong> fields
we defined for the stacks, we will also need a <strong>private</strong> field to
store the last <strong>string</strong> we saw in the <strong>TextBox</strong>. Rather than
initializing <code>_editingHistory</code> within the constructor, we should now
initialize this <strong>string</strong> in its place (because there will have been no
edits initially, both stacks should initially be empty). If we keep this
<strong>string</strong> field up to date, we will always have a &ldquo;before&rdquo; picture (the
contents of this field) and an &ldquo;after&rdquo; picture (the current contents of
the <strong>TextBox</strong>) for the edit we need to record.</p><p>To determine whether the edit was an insertion or a deletion, we can
compare the lengths of the current <strong>TextBox</strong> contents and its previous
contents. If the current content is longer, then the edit was an
insertion; otherwise, the edit was a deletion. We therefore have the
following method for this purpose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Returns whether text was deleted from the given string in order to</span>
</span></span><span class=line><span class=cl><span class=cs>/// obtain the contents of the given TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;Whether the edit was a deletion.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>bool</span> <span class=n>IsDeletion</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>TextLength</span> <span class=p>&lt;</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that the above code uses the <strong>TextBox</strong>&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.textlength?view=windowsdesktop-6.0#system-windows-forms-textboxbase-textlength" rel=external target=_blank><strong>TextLength</strong></a>
property. This is more efficient than finding the length of its <strong>Text</strong>
property because evaluating the <strong>Text</strong> property requires all the
characters to be copied to a new <strong>string</strong>.</p><p>Before getting either the location of the edit or the edit string
itself, it is useful to compute the length of the edit string. This
length is simply the absolute value of the difference in the lengths of
the <strong>string</strong> currently in the <strong>TextBox</strong> and the last <strong>string</strong> we
saw there. The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.math?view=net-6.0" rel=external target=_blank><strong>Math</strong></a>
class (in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system?view=net-6.0" rel=external target=_blank><strong>System</strong></a>
namespace) contains a
<a href=/cis300/appendix/syntax/static-this/><strong>static</strong></a> method
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.math.abs?view=net-6.0#system-math-abs(system-int32)" rel=external target=_blank><strong>Abs</strong></a>,
which computes the absolute value of an <strong>int</strong>. We therefore have the
following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the length of the text inserted or deleted.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The length of the edit.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=n>GetEditLength</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Math</span><span class=p>.</span><span class=n>Abs</span><span class=p>(</span><span class=n>editor</span><span class=p>.</span><span class=n>TextLength</span> <span class=p>-</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now that we can determine whether an edit is a deletion or an insertion,
and we can find the length of the edit string, it isn&rsquo;t hard to find the
beginning of the edit. First, suppose the edit is a deletion. The point
at which the deletion occurred is the point at which the text caret now
resides. We can find this point using the <strong>TextBox</strong>&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.selectionstart?view=windowsdesktop-6.0#system-windows-forms-textboxbase-selectionstart" rel=external target=_blank><strong>SelectionStart</strong></a>
property. When there is no current selection - and there never will be
immediately following an edit - this property gives the location of the
text caret in the <strong>TextBox</strong>. Now consider the case in which the edit
was an insertion. When text is inserted into a <strong>TextBox</strong>, the text
caret ends up at the <em>end</em> of the inserted text. We need to find its
beginning. We can do this by subtracting the length of the edit string
from the text caret position. We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the location of the beginning of the edit.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit was a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;len&#34;&gt;The length of the edit string.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The location of the beginning of the edit.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=n>GetEditLocation</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>-</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The last piece of information we need is the <strong>string</strong> that was deleted
or inserted. If the edit was a deletion, this <strong>string</strong> can be found in
the previous <strong>TextBox</strong> contents. Its beginning is the point at which
the edit occurred. We can therefore extract the deleted <strong>string</strong> from
the previous contents using its
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-6.0#system-string-substring(system-int32-system-int32)" rel=external target=_blank><strong>Substring</strong></a>
method. We pass this method the beginning index of the substring and its
length, and it returns the substring, which is the deleted <strong>string</strong>.
On the other hand, if the edit was an insertion, we can find the
inserted <strong>string</strong> in the current <strong>TextBox</strong> contents by using its
<strong>Substring</strong> in a similar way. We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the edit string.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;content&#34;&gt;The current content of the TextBox.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit was a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editLocation&#34;&gt;The location of the beginning of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;len&#34;&gt;The length of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The edit string.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>string</span> <span class=n>GetEditString</span><span class=p>(</span><span class=kt>string</span> <span class=n>content</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>editLocation</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Substring</span><span class=p>(</span><span class=n>editLocation</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>content</span><span class=p>.</span><span class=n>Substring</span><span class=p>(</span><span class=n>editLocation</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Using the methods above, we can modify the <strong>RecordEdit</strong> method to
obtain the three values listed above to describe an edit. Once we have
placed these three values onto the stack of editing history, we also
need to update the <strong>string</strong> giving the previous <strong>TextBox</strong> contents.
This should now be the current <strong>TextBox</strong> contents. We can then finish
the method as shown above.</p><p>In order to implement Undo and Redo, we need to be able to insert and
delete text in the <strong>TextBox</strong>. A <strong>string</strong> has two methods we can use
to accomplish this:</p><ul><li>The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.remove?view=net-6.0#system-string-remove(system-int32-system-int32)" rel=external target=_blank><strong>Remove</strong></a>
method takes as its parameters the beginning index and length of the
portion to remove, and returns the result.</li><li>The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.insert?view=net-6.0#system-string-insert(system-int32-system-string)" rel=external target=_blank><strong>Insert</strong></a>
method takes as its parameters the index at which the <strong>string</strong>
should be inserted, and the <strong>string</strong> to insert. It returns the
result.</li></ul><p>Given the location of the edit along with the edit string itself, we can
easily provide the parameters to the appropriate method above.
Furthermore, it is not hard to set the location of the text caret using
the <strong>TextBox</strong>&rsquo;s <strong>SelectionStart</strong> property - we just need to be sure
to add the length of the edit string if we are inserting text. The
following method therefore performs a given edit, updating the
<strong>string</strong> containing the last contents of the <strong>TextBox</strong> as well (we
assume this <strong>string</strong> is called <code>_lastText</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Performs the given edit on the contents of the given TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox to edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit is a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;loc&#34;&gt;The location of the beginning of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;text&#34;&gt;The text to insert or delete.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>DoEdit</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>loc</span><span class=p>,</span> <span class=kt>string</span> <span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_lastText</span> <span class=p>=</span> <span class=n>editor</span><span class=p>.</span><span class=n>Text</span><span class=p>.</span><span class=n>Remove</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_lastText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>=</span> <span class=n>loc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_lastText</span> <span class=p>=</span> <span class=n>editor</span><span class=p>.</span><span class=n>Text</span><span class=p>.</span><span class=n>Insert</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span> <span class=n>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_lastText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>=</span> <span class=n>loc</span> <span class=p>+</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We can now implement event handlers for Undo and Redo. We can obtain the
description of the edit from the stack of editing history for an Undo,
or from the stack of undo history for a Redo. This description gives us
the type of edit (i.e., either insertion or deletion), the beginning
position of the edit, and the inserted or deleted <strong>string</strong>. To
implement a Redo, we simply do this edit, but to implement an Undo, we
must do the opposite.</p><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1737579063 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737579063 defer></script><script src=/cis300/js/theme.js?1737579063 defer></script><script src=/cis300/js/embed-iframe.js?1737579063 defer></script></body></html>