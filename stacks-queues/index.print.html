<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an â€œUndoâ€ operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Stacks and Queues :: Data Structures in C#"><meta name=twitter:description content="Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an â€œUndoâ€ operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/stacks-queues/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Stacks and Queues :: Data Structures in C#"><meta property="og:description" content="Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an â€œUndoâ€ operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Stacks and Queues :: Data Structures in C#"><meta itemprop=description content="Stacks and Queues Often in solving problems, we need to access data items in a particular order. Consider, for example, the action of an â€œUndoâ€ operation in a text editor, spreadsheet, or similar application. If we want to be able to undo a sequence of these operations, we need to record each operation as it is done. When we want to undo an operation, we need to retrieve the operation to undo from the recorded sequence of operations."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="143"><title>Stacks and Queues :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1756138921 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1756138921 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1756138921 rel=stylesheet><link href=/cis300/css/auto-complete.css?1756138921 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1756138921 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1756138921 rel=stylesheet><link href=/cis300/css/fonts.css?1756138921 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1756138921 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1756138921 rel=stylesheet><link href=/cis300/css/theme-auto.css?1756138921 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1756138921 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1756138921 rel=stylesheet><link href=/cis300/css/print.css?1756138921 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1756138921 rel=stylesheet><script src=/cis300/js/variant.js?1756138921></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1756138921 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/stacks-queues/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Stacks and Queues</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/strings/stringbuilder-impl/ title="Implementation of StringBuilders (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/stacks-queues/stacks/ title="Introduction to Stacks (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=stacks-and-queues>Stacks and Queues</h1></div><h2 id=stacks-and-queues>Stacks and Queues</h2><p>Often in solving problems, we need to access data items in a particular
order. Consider, for example, the action of an &ldquo;Undo&rdquo; operation in a
text editor, spreadsheet, or similar application. If we want to be able
to undo a sequence of these operations, we need to record each operation
as it is done. When we want to undo an operation, we need to retrieve
the operation to undo from the recorded sequence of operations. However,
we don&rsquo;t want to undo just any operation in this sequence - we need to
undo the most recent one that hasn&rsquo;t yet been undone. We therefore need
to access the operations in <em>last-in-first-out</em>, or <em>LIFO</em>, order. Other
applications might need to access data items in <em>first-in-first-out</em>, or
<em>FIFO</em>, order. In this chapter, we will examine data structures that
support these kinds of access.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Stacks and Queues</h1><article class=default><header class=headline></header><div hidden><h1 id=introduction-to-stacks>Introduction to Stacks</h1></div><h2 id=introduction-to-stacks>Introduction to Stacks</h2><p>A <em>stack</em> provides last-in-first-out (LIFO) access to data items. We
usually think of a stack as arranging data items vertically, like a
stack of trays in a cafeteria. Access is normally provided only at the
top of the stack; hence, if we want to add an item, we <em>push</em> it onto
the top, and if we want to remove an item, we <em>pop</em> it from the top.
Because we only access the top of the stack, the item that we pop is
always the remaining item that we had pushed the most recently.</p><p>.NET provides two kinds of stacks. One is the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack?view=net-6.0" rel=external target=_blank><strong>Stack</strong></a>
class found in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections?view=net-6.0" rel=external target=_blank><strong>System.Collections</strong></a>
namespace. Because this namespace isn&rsquo;t typically included in the list of namespaces searched by the compiler, but the namespace containing the other <strong>Stack</strong> definition (discussed a bit later below) is included, we need to refer to it in code as <strong>System.Collections.Stack</strong>. This class provides a stack of <strong>object?</strong>s. Because every
type in C# is a subtype of <strong>object</strong>, we can push any data items we
want onto a <strong>Stack</strong>. Because <strong>object?</strong> is a <a href=/cis300/appendix/syntax/reference-value/#nullable-types>nullable</a> type, we can even push <strong>null</strong>. The most commonly-used <strong>public</strong> members of this
class are:</p><ul><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack.-ctor?view=net-6.0#system-collections-stack-ctor" rel=external target=_blank>constructor</a>
that takes no parameters and constructs an empty stack.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack.count?view=net-6.0#system-collections-stack-count" rel=external target=_blank><strong>Count</strong></a>
property, which gets the number of elements on the <strong>Stack</strong> as an
<strong>int</strong>.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack.push?view=net-6.0#system-collections-stack-push(system-object)" rel=external target=_blank><strong>Push</strong></a>
method, which takes a single parameter of type <strong>object?</strong>, and
pushes it onto the top of the <strong>Stack</strong>.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack.peek?view=net-6.0#system-collections-stack-peek" rel=external target=_blank><strong>Peek</strong></a>
method, which takes no parameters and returns the element at the top
of the <strong>Stack</strong> (as an <strong>object?</strong>) without changing the <strong>Stack</strong>&rsquo;s
contents. If the <strong>Stack</strong> is empty, this method throws an
<strong>InvalidOperationException</strong>.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.stack.pop?view=net-6.0#system-collections-stack-pop" rel=external target=_blank><strong>Pop</strong></a>
method, which takes no parameters, and removes and returns the
element at the top of the <strong>Stack</strong> (as an <strong>object?</strong>). If the
<strong>Stack</strong> is empty, this method throws an
<strong>InvalidOperationException</strong>.</li></ul><p>As we mentioned above, because the <strong>Push</strong> method takes an <strong>object?</strong>
as its parameter, we can push any data elements we want, including <strong>null</strong>, onto a
<strong>Stack</strong>. What this means, however, is that the compiler can&rsquo;t
determine the type of these elements when we retrieve them; i.e., both
the <strong>Peek</strong> and <strong>Pop</strong> methods return <strong>object?</strong>s. Thus, for example,
the following code will not compile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>System</span><span class=p>.</span><span class=n>Collections</span><span class=p>.</span><span class=n>Stack</span> <span class=n>s</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=m>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=n>s</span><span class=p>.</span><span class=n>Pop</span><span class=p>()</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span></span></span></code></pre></div><p>The problem is that the <strong>Pop</strong> method returns an <strong>object?</strong>, and we
can&rsquo;t add an <strong>int</strong> to an <strong>object?</strong>. Although it&rsquo;s pretty easy to see
from this code that <strong>Pop</strong> will return 7, in many cases it&rsquo;s impossible
to know at compile time the exact type of the element returned (for
example, the <strong>Stack</strong> may be a parameter to a <strong>public</strong> method, and that method
may be called by code that has not yet been written). Consequently, the
compiler simply uses the return type of <strong>Pop</strong> - it doesn&rsquo;t even try to
figure out the type any more precisely.</p><p><span id=cast></span> If you want to use the value returned by <strong>Pop</strong>
or <strong>Peek</strong> as something other than an <strong>object?</strong>, you need to tell the
compiler what its type actually is. You do this with a <em>cast</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>s</span><span class=p>.</span><span class=n>Pop</span><span class=p>()</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span></span></span></code></pre></div><p>This tells the compiler to assume that the value returned by <strong>Pop</strong> is
an <strong>int</strong>. The type is still checked, but now it is checked at run
time, rather than at compile time. If the runtime environment detects
that the value is not, in fact, an <strong>int</strong>, it will throw an
<strong>InvalidCastException</strong>.</p><p>While the above line of code will now compile, it generates a warning because <strong>Pop</strong> might return <strong>null</strong>, which cannot be cast to <strong>int</strong>. In order to avoid this warning, once we have determined that the call won&rsquo;t return a <strong>null</strong> value, we need to use the <code>!</code> operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=c1>// The element on the top of the stack is the int 7</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>s</span><span class=p>.</span><span class=n>Pop</span><span class=p>()!</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span></span></span></code></pre></div><p>Note that we include a comment explaining why <strong>Pop</strong> won&rsquo;t return <strong>null</strong> here.</p><p><span id=generic></span> Often when we need a stack, the data items
that we wish to store are all of the same type. In such a case, it is
rather awkward to include a cast whenever we retrieve an item from the
stack. In order to avoid this casting, .NET provides a
<em>generic</em> stack,
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1?view=net-6.0" rel=external target=_blank><strong>Stack&lt;T></strong></a>,
found in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic?view=net-6.0" rel=external target=_blank><strong>System.Collections.Generic</strong></a>
namespace. The <strong>T</strong> within angle brackets is a <em>type parameter</em> - we
may replace it with any type we want. This type tells what type of
elements may be placed in this stack. For example, if we want a stack
that will only contain <strong>int</strong>s, we can write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>Stack</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>s</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span></span></span></code></pre></div><p>This class has members similar to those listed above for the non-generic
<strong>Stack</strong> class, except that the <strong>Push</strong> method takes a parameter of
type <strong>T</strong> (i.e., whatever type we placed within the angle brackets in
the type declaration and constructor call), and the <strong>Peek</strong> and <strong>Pop</strong>
methods each return a value of type <strong>T</strong>. As a result, the following is
now legal code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>Stack</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>s</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=m>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=n>s</span><span class=p>.</span><span class=n>Pop</span><span class=p>()</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span></span></span></code></pre></div><p>We will show how you can define your own generic types in &ldquo;<a href=/cis300/stacks-queues/stack-impl/>Implementing
a Stack</a>&rdquo;. First, however,
we want to work through two example applications of stacks. We will do
that in the next two sections.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-undo-and-redo-for-a-textbox>Implementing Undo and Redo for a TextBox</h1></div><h2 id=implementing-undo-and-redo-for-a-textbox>Implementing Undo and Redo for a <strong>TextBox</strong></h2><p>A <strong>TextBox</strong> has a rather crude Undo/Redo feature. By right-clicking on
a <strong>TextBox</strong>, a popup menu containing an Undo entry is presented. This
Undo will undo only one action, which may include several edits. An
immediate subsequent Undo will undo the Undo - in essence, a Redo. The
same behavior can be achieved using <code>Ctrl</code>+<code>Z</code>. A more powerful Undo/Redo
feature would allow an arbitrary sequence of edits to be undone, with
the option of redoing any of these Undo operations. This section
outlines various ways of implementing such a feature.</p><p>We first observe that when we perform an Undo, we want to undo the most
recent edit that has not been undone; i.e., we need LIFO access to the
edits. Likewise, when we perform a Redo, we want to redo the most recent
Undo that has not been redone. Again, we need LIFO access to the Undo
operations. We will therefore use two stacks, one to keep the edit
history, and one to keep the Undo history (i.e., the history of Undo
operations that can be redone).</p><p>Before we can define these stacks, we need to determine what we will be
storing in them; i.e., we need to determine how we will represent an
edit. We will consider several ways of doing this, but the simplest way
is to store the entire contents of the <strong>TextBox</strong> after each edit.
Proceeding in this way, we really aren&rsquo;t representing edits at all, but
we certainly would have the information we need to undo the edits.
Likewise, the Undo history would store the entire contents of the
<strong>TextBox</strong> prior to each Undo. Because the contents of the <strong>TextBox</strong>
form a <strong>string</strong>, we need two <strong>private</strong> fields, each referring to a
stack of <strong>string</strong>s:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The history of the contents of the TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Stack</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>_editingHistory</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The history of TextBox contents that have been undone and can be redone.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Stack</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=n>_undoHistory</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span></span></span></code></pre></div><p>Before we can proceed to implementing the Undo and Redo operations, we
need to do a bit more initialization. Note that by the way we have
defined <code>_editingHistory</code>, this stack needs to contain the initial
contents of the <strong>TextBox</strong>. Therefore, assuming the <strong>TextBox</strong> field
is named <code>uxEditBuffer</code>, we need to add the following line to the end of
the constructor of our user interface:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span><span class=p>);</span></span></span></code></pre></div><p>In order to support Undo and Redo, we need to be able to record the
content of <code>uxEditBuffer</code> each time it is modified. We can do this via an
event handler for the <strong>TextChanged</strong> event on the <strong>TextBox</strong>. Because
this event is the default event for a <strong>TextBox</strong>, we can add such an
event handler by double-clicking on the <strong>TextBox</strong> within the Visual
StudioÂ® Design window. This event handler will then be called every
time the contents of the <strong>TextBox</strong> are changed.</p><p>We need to deal with one important issue before we can write the code
for this event handler. Whenever we perform an Undo or Redo operation,
we will change the contents of the <strong>TextBox</strong>. This will cause the
<strong>TextChanged</strong> event handler to be called. However, we don&rsquo;t want to
treat an Undo or a Redo in the same way as an edit by the user. For
example, if the user does an Undo, we don&rsquo;t want that Undo to be
considered an edit, or a subsequent Undo would just undo the Undo; i.e.,
it would perform a Redo rather than an Undo.</p><p>Fortunately, there is an easy way to distinguish between an edit made by
the user and a change made by the program code. A <strong>TextBox</strong> has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.modified?view=windowsdesktop-6.0#system-windows-forms-textboxbase-modified" rel=external target=_blank><strong>Modified</strong></a>
property, which is set to <strong>true</strong> when the user modifies the
<strong>TextBox</strong> contents, and is set to <strong>false</strong> when the program modifies
the contents. Thus, we only want to record the <strong>TextBox</strong> contents when
this property is <strong>true</strong>. Assuming the <strong>TextBox</strong> is named
<code>uxEditBuffer</code>, we can then set up the event handler as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a TextChanged event on the edit buffer.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>EditBufferTextChanged</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Modified</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RecordEdit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now let&rsquo;s consider how to write the <code>RecordEdit</code> method. Suppose there
are two GUI controls (e.g., menu items or buttons) called <code>uxUndo</code> and
<code>uxRedo</code>, which invoke the Undo and Redo operations, respectively. These
controls should be enabled only when there are operations to undo or
redo. Thus, initially these controls will be disabled. Whenever the user
modifies the contents of the <strong>TextBox</strong>, we need to do the following:</p><ul><li>Push the resulting text onto <code>_editingHistory</code>.</li><li>Enable <code>uxUndo</code>, as there is now an edit that can be undone.</li><li>Clear the contents of <code>_undoHistory</code>, as the last change to the
<strong>TextBox</strong> contents was not an Undo. (A <strong>Stack&lt;T></strong> has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.stack-1.clear?view=net-6.0#system-collections-generic-stack-1-clear" rel=external target=_blank><strong>Clear</strong></a>
method for this purpose.)</li><li>Disable <code>uxRedo</code>.</li></ul><p>We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Records an edit made by the user.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>RecordEdit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now that we have a mechanism for recording the user&rsquo;s edits, we can
implement the Undo operation. The contents of the <strong>TextBox</strong> following
the last edit (i.e, the current contents of the <strong>TextBox</strong>) should
always be at the top of <code>_editingHistory</code>. An Undo should change the
current contents to the previous contents - i.e., to the <em>next</em>
<strong>string</strong> on <code>_editingHistory</code>. However, we don&rsquo;t want to lose the top
<strong>string</strong>, as this is the <strong>string</strong> that would need to be restored by
a subsequent Redo. Instead, we need to push this <strong>string</strong> onto
<code>_undoHistory</code>. We then need to enable <code>uxRedo</code>. In order to determine
whether <code>uxUndo</code> should be enabled, we need to know how many elements
remain in <code>_editingHistory</code>. We know there is at least one <strong>string</strong> on
this stack - the <strong>string</strong> that we placed in the <strong>TextBox</strong>. There is
an edit to undo if there is at least one more element on this stack -
i.e., if its <strong>Count</strong> is greater than 1. We therefore have the
following event handler for a Click event on <code>uxUndo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a Click event on Undo.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>UndoClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>_editingHistory</span><span class=p>.</span><span class=n>Pop</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Peek</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Count</span> <span class=p>&gt;</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The implementation of Redo is similar, but now we need to transfer a
<strong>string</strong> between the stacks in the opposite direction - we move the
top <strong>string</strong> from <code>_undoHistory</code> to <code>_editingHistory</code>. Then <code>uxRedo</code>
should be enabled if any more <strong>string</strong>s remain in <code>_undoHistory</code>. The
<strong>string</strong> we removed from <code>_undoHistory</code> should be placed in the
<strong>TextBox</strong>. Finally, <code>uxUndo</code> should be enabled. We therefore have the
following event handler for a Click event on <code>uxRedo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a Click event on Redo.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information about the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>RedoClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Push</span><span class=p>(</span><span class=n>_undoHistory</span><span class=p>.</span><span class=n>Pop</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>uxRedo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=n>_undoHistory</span><span class=p>.</span><span class=n>Count</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uxEditBuffer</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_editingHistory</span><span class=p>.</span><span class=n>Peek</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uxUndo</span><span class=p>.</span><span class=n>Enabled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This solution will work, except that an Undo or Redo always brings the
text caret to the beginning of the <strong>TextBox</strong> contents. Furthermore, if
the <strong>TextBox</strong> contains a long <strong>string</strong>, each edit causes a long
<strong>string</strong> to be placed onto <code>_editingHistory</code>. This can quickly eat up
a lot of memory, and may eventually fill up all available storage. In
what follows, we will outline two better approaches.</p><p>The idea for both of these approaches is that instead of recording the
entire contents of the <strong>TextBox</strong> for each edit, we only record a
description of each edit. A single edit will either be an insertion or a
deletion of some text. The number of characters inserted/deleted may
vary, as the edit may be a cut or a paste (if we select a block of text
and do a paste, the <strong>TextChanged</strong> event handler is actually called
twice - once for the deletion of the selected text, and once for the
insertion of the pasted text). We can therefore describe the edit with
the following three values:</p><ul><li>A <strong>bool</strong> indicating whether the edit was an insertion or a
deletion.</li><li>An <strong>int</strong> giving the index of the beginning of the edit.</li><li>The <strong>string</strong> inserted or deleted.</li></ul><p>We can maintain this information in stacks in one of two ways. One way
is to use non-generic stacks and to push three items onto a stack for
each edit. If we do this, we need to realize that when we pop elements
from the stack, they will come out in reverse order from the way they
were pushed onto it. Alternatively, we can define a class or a
<a href=/cis300/appendix/syntax/structs/>structure</a> to represent an
edit using the three values above as <strong>private</strong> fields. We can then use
generic stacks storing instances of this type.</p><p>Whichever way we choose to represent the edits, we need to be able to
compute each of the three pieces of information describing the edit. In
order to compute this information, we need to compare the current
contents of the <strong>TextBox</strong> with its prior contents in order to see how
it changed. This means that, in addition to the two <strong>private</strong> fields
we defined for the stacks, we will also need a <strong>private</strong> field to
store the last <strong>string</strong> we saw in the <strong>TextBox</strong>. Rather than
initializing <code>_editingHistory</code> within the constructor, we should now
initialize this <strong>string</strong> in its place (because there will have been no
edits initially, both stacks should initially be empty). If we keep this
<strong>string</strong> field up to date, we will always have a &ldquo;before&rdquo; picture (the
contents of this field) and an &ldquo;after&rdquo; picture (the current contents of
the <strong>TextBox</strong>) for the edit we need to record.</p><p>To determine whether the edit was an insertion or a deletion, we can
compare the lengths of the current <strong>TextBox</strong> contents and its previous
contents. If the current content is longer, then the edit was an
insertion; otherwise, the edit was a deletion. We therefore have the
following method for this purpose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Returns whether text was deleted from the given string in order to</span>
</span></span><span class=line><span class=cl><span class=cs>/// obtain the contents of the given TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;Whether the edit was a deletion.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>bool</span> <span class=n>IsDeletion</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>TextLength</span> <span class=p>&lt;</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that the above code uses the <strong>TextBox</strong>&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.textlength?view=windowsdesktop-6.0#system-windows-forms-textboxbase-textlength" rel=external target=_blank><strong>TextLength</strong></a>
property. This is more efficient than finding the length of its <strong>Text</strong>
property because evaluating the <strong>Text</strong> property requires all the
characters to be copied to a new <strong>string</strong>.</p><p>Before getting either the location of the edit or the edit string
itself, it is useful to compute the length of the edit string. This
length is simply the absolute value of the difference in the lengths of
the <strong>string</strong> currently in the <strong>TextBox</strong> and the last <strong>string</strong> we
saw there. The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.math?view=net-6.0" rel=external target=_blank><strong>Math</strong></a>
class (in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system?view=net-6.0" rel=external target=_blank><strong>System</strong></a>
namespace) contains a
<a href=/cis300/appendix/syntax/static-this/><strong>static</strong></a> method
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.math.abs?view=net-6.0#system-math-abs(system-int32)" rel=external target=_blank><strong>Abs</strong></a>,
which computes the absolute value of an <strong>int</strong>. We therefore have the
following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the length of the text inserted or deleted.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The length of the edit.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=n>GetEditLength</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Math</span><span class=p>.</span><span class=n>Abs</span><span class=p>(</span><span class=n>editor</span><span class=p>.</span><span class=n>TextLength</span> <span class=p>-</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Now that we can determine whether an edit is a deletion or an insertion,
and we can find the length of the edit string, it isn&rsquo;t hard to find the
beginning of the edit. First, suppose the edit is a deletion. The point
at which the deletion occurred is the point at which the text caret now
resides. We can find this point using the <strong>TextBox</strong>&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.textboxbase.selectionstart?view=windowsdesktop-6.0#system-windows-forms-textboxbase-selectionstart" rel=external target=_blank><strong>SelectionStart</strong></a>
property. When there is no current selection - and there never will be
immediately following an edit - this property gives the location of the
text caret in the <strong>TextBox</strong>. Now consider the case in which the edit
was an insertion. When text is inserted into a <strong>TextBox</strong>, the text
caret ends up at the <em>end</em> of the inserted text. We need to find its
beginning. We can do this by subtracting the length of the edit string
from the text caret position. We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the location of the beginning of the edit.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox containing the result of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit was a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;len&#34;&gt;The length of the edit string.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The location of the beginning of the edit.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>int</span> <span class=n>GetEditLocation</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>-</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The last piece of information we need is the <strong>string</strong> that was deleted
or inserted. If the edit was a deletion, this <strong>string</strong> can be found in
the previous <strong>TextBox</strong> contents. Its beginning is the point at which
the edit occurred. We can therefore extract the deleted <strong>string</strong> from
the previous contents using its
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.substring?view=net-6.0#system-string-substring(system-int32-system-int32)" rel=external target=_blank><strong>Substring</strong></a>
method. We pass this method the beginning index of the substring and its
length, and it returns the substring, which is the deleted <strong>string</strong>.
On the other hand, if the edit was an insertion, we can find the
inserted <strong>string</strong> in the current <strong>TextBox</strong> contents by using its
<strong>Substring</strong> in a similar way. We therefore have the following method:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the edit string.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;content&#34;&gt;The current content of the TextBox.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;lastContent&#34;&gt;The string representing the text prior</span>
</span></span><span class=line><span class=cl><span class=cs>/// to the edit.&lt;/param&gt; </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit was a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editLocation&#34;&gt;The location of the beginning of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;len&#34;&gt;The length of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;returns&gt;The edit string.&lt;/returns&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>string</span> <span class=n>GetEditString</span><span class=p>(</span><span class=kt>string</span> <span class=n>content</span><span class=p>,</span> <span class=kt>string</span> <span class=n>lastContent</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>editLocation</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>lastContent</span><span class=p>.</span><span class=n>Substring</span><span class=p>(</span><span class=n>editLocation</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>content</span><span class=p>.</span><span class=n>Substring</span><span class=p>(</span><span class=n>editLocation</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Using the methods above, we can modify the <strong>RecordEdit</strong> method to
obtain the three values listed above to describe an edit. Once we have
placed these three values onto the stack of editing history, we also
need to update the <strong>string</strong> giving the previous <strong>TextBox</strong> contents.
This should now be the current <strong>TextBox</strong> contents. We can then finish
the method as shown above.</p><p>In order to implement Undo and Redo, we need to be able to insert and
delete text in the <strong>TextBox</strong>. A <strong>string</strong> has two methods we can use
to accomplish this:</p><ul><li>The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.remove?view=net-6.0#system-string-remove(system-int32-system-int32)" rel=external target=_blank><strong>Remove</strong></a>
method takes as its parameters the beginning index and length of the
portion to remove, and returns the result.</li><li>The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.insert?view=net-6.0#system-string-insert(system-int32-system-string)" rel=external target=_blank><strong>Insert</strong></a>
method takes as its parameters the index at which the <strong>string</strong>
should be inserted, and the <strong>string</strong> to insert. It returns the
result.</li></ul><p>Given the location of the edit along with the edit string itself, we can
easily provide the parameters to the appropriate method above.
Furthermore, it is not hard to set the location of the text caret using
the <strong>TextBox</strong>&rsquo;s <strong>SelectionStart</strong> property - we just need to be sure
to add the length of the edit string if we are inserting text. The
following method therefore performs a given edit, updating the
<strong>string</strong> containing the last contents of the <strong>TextBox</strong> as well (we
assume this <strong>string</strong> is called <code>_lastText</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Performs the given edit on the contents of the given TextBox.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;editor&#34;&gt;The TextBox to edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;isDeletion&#34;&gt;Indicates whether the edit is a deletion.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;loc&#34;&gt;The location of the beginning of the edit.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;text&#34;&gt;The text to insert or delete.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>DoEdit</span><span class=p>(</span><span class=n>TextBox</span> <span class=n>editor</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isDeletion</span><span class=p>,</span> <span class=kt>int</span> <span class=n>loc</span><span class=p>,</span> <span class=kt>string</span> <span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isDeletion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_lastText</span> <span class=p>=</span> <span class=n>editor</span><span class=p>.</span><span class=n>Text</span><span class=p>.</span><span class=n>Remove</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_lastText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>=</span> <span class=n>loc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_lastText</span> <span class=p>=</span> <span class=n>editor</span><span class=p>.</span><span class=n>Text</span><span class=p>.</span><span class=n>Insert</span><span class=p>(</span><span class=n>loc</span><span class=p>,</span> <span class=n>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_lastText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>editor</span><span class=p>.</span><span class=n>SelectionStart</span> <span class=p>=</span> <span class=n>loc</span> <span class=p>+</span> <span class=n>text</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We can now implement event handlers for Undo and Redo. We can obtain the
description of the edit from the stack of editing history for an Undo,
or from the stack of undo history for a Redo. This description gives us
the type of edit (i.e., either insertion or deletion), the beginning
position of the edit, and the inserted or deleted <strong>string</strong>. To
implement a Redo, we simply do this edit, but to implement an Undo, we
must do the opposite.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=parenthesis-matching>Parenthesis Matching</h1></div><h2 id=parenthesis-matching>Parenthesis Matching</h2><p>The problem of finding matching parentheses must be solved in many
computing applications. For example, consider a C# compiler. Matching
parentheses (<code>(</code> and <code>)</code>), brackets (<code>[</code> and <code>]</code>), and braces (<code>{</code> and
<code>}</code>) delimit various parts of the source code. In order for these parts
to be interpreted correctly, the compiler must be able to determine how
these different kinds of parentheses match up with each other. Another
example is processing structured data stored in XML format. Different
parts of such a data set are delimited by nested begin tags like
<code>&lt;summary></code> and end tags like <code>&lt;/summary></code> (documentation comments
in C# code are in XML format). These tags are essentially different
kinds of parentheses that need to be matched.</p><p>We will restrict our attention to parentheses, brackets, and braces. We
will call all six of these characters &ldquo;parentheses&rdquo;, but will divide
them into three types. Each type then has an opening parenthesis and a
closing parenthesis. We will define a <strong>string</strong> restricted to these six
characters to be <em>matched</em> (or <em>balanced</em>) if we can repeatedly remove
an opening parenthesis and a closing parenthesis of the same type to its
immediate right until there are no more parentheses.</p><p>For example, suppose we have the <strong>string</strong>, &ldquo;<code>([]{()[]})[{}]</code>&rdquo;. We can
apply the matching-pair removal process described above as follows
(blank space is inserted to make it easier to see which parentheses are
removed):</p><pre>
    ([]{()[]})[{}]
    (  {()[]})[{}]
    (  {  []})[{}]
    (  {    })[{}]
    (        )[{}]
              [{}]
              [  ]
</pre><p>Hence, this <strong>string</strong> is matched. On the other hand, consider the
<strong>string</strong>, &ldquo;<code>([]{()[])}[{}]</code>&rdquo;. When we apply the above process to this
<strong>string</strong>, we obtain:</p><pre>
    ([]{()[])}[{}]
    (  {()[])}[{}]
    (  {  [])}[{}]
    (  {    )}[{}]
    (  {    )}[  ]
    (  {    )}
</pre><p>and we can go no further. Hence, this <strong>string</strong> is not matched.</p><p>We can extend the definition of a matched <strong>string</strong> to include other
characters if we first remove all other characters before we begin the
matching-pair removal process. In what follows, we will focus on the
problem of determining whether a given <strong>string</strong> is matched.</p><p>The matching-pair removal process shown above gives us an algorithm for
determining whether a <strong>string</strong> is matched. However, if implemented
directly, it isn&rsquo;t very efficient. Changes to a <strong>string</strong> are
inefficient because the entire <strong>string</strong> must be reconstructed. We
could use a <strong>StringBuilder</strong>, but even then, removing characters is
inefficient, as all characters to the right of the removed character
must be moved to take its place. Even if we simply change parentheses to
blanks, as we did in the above example, searching for matching pairs is
still rather expensive.</p><p>What we would like to do instead is to find a way to apply the
matching-pair removal process while scanning the <strong>string</strong> once. As we
are scanning the <strong>string</strong>, we don&rsquo;t want to spend time searching for a
matching pair. We can do this if, while scanning the <strong>string</strong>, we keep
all unmatched opening parentheses in a stack. Then the parenthesis at
the top of the stack will always be the rightmost unmatched opening
parenthesis. Thus, starting with an empty stack, we do the following for
each character in the <strong>string</strong>:</p><ul><li>If the character is a opening parenthesis, push it onto the stack.</li><li>If the character is a closing parenthesis:<ul><li>If the stack is nonempty, and the current character matches the
character on top of the stack, remove the character from the top
of the stack.</li><li>Otherwise, the <strong>string</strong> is not matched.</li></ul></li><li>Ignore all other characters.</li></ul><p>If the stack is empty when the entire <strong>string</strong> has been processed,
then the <strong>string</strong> is matched; otherwise, it is not.</p><p>For example, consider the <strong>string</strong>, &ldquo;<code>{a[b]([c]){de}}f[(g)]</code>&rdquo;. In what
follows, we will simulate the above algorithm, showing the result of
processing each character on a separate line. The portion of the line
with an orange background will be the stack contents, with the top element
shown at the right. We will insert blank space in the orange area for
clarity, but the stack will only contain opening parentheses. The first
character with a gray background is the character currently being
processed.</p><pre>
{a[b]([c]){de}}f[(g)]    --- an opening parenthesis - push it onto the stack
<span style=background-color:#ff7f00>{</span>a[b]([c]){de}}f[(g)]    --- ignore
<span style=background-color:#ff7f00>{ </span>[b]([c]){de}}f[(g)]    --- push onto stack
<span style=background-color:#ff7f00>{ [</span>b]([c]){de}}f[(g)]    --- ignore
<span style=background-color:#ff7f00>{ [ </span>]([c]){de}}f[(g)]    --- closing parenthesis that matches the top - remove top
<span style=background-color:#ff7f00>{    </span>([c]){de}}f[(g)]    --- push onto stack
<span style=background-color:#ff7f00>{    (</span>[c]){de}}f[(g)]    --- push onto stack
<span style=background-color:#ff7f00>{    ([</span>c]){de}}f[(g)]    --- ignore
<span style=background-color:#ff7f00>{    ([ </span>]){de}}f[(g)]    --- a match - remove top
<span style=background-color:#ff7f00>{    (   </span>){de}}f[(g)]    --- a match - remove top
<span style=background-color:#ff7f00>{         </span>{de}}f[(g)]    --- push onto stack
<span style=background-color:#ff7f00>{         {</span>de}}f[(g)]    --- ignore
<span style=background-color:#ff7f00>{         { </span>e}}f[(g)]    --- ignore
<span style=background-color:#ff7f00>{         {  </span>}}f[(g)]    --- a match - remove top
<span style=background-color:#ff7f00>{             </span>}f[(g)]    --- a match - remove top
<span style=background-color:#ff7f00>               </span>f[(g)]    --- ignore
<span style=background-color:#ff7f00>                </span>[(g)]    --- push onto stack
<span style=background-color:#ff7f00>                [</span>(g)]    --- push onto stack
<span style=background-color:#ff7f00>                [(</span>g)]    --- ignore
<span style=background-color:#ff7f00>                [( </span>)]    --- a match - remove top
<span style=background-color:#ff7f00>                [   </span>]    --- a match - remove top
<span style=background-color:#ff7f00>                     </span>    --- end of string and stack empty - matched string
</pre><p>If at any time during the above process we had encountered a closing
parenthesis while the stack was empty, this would have indicated that
this closing parenthesis has no matching opening parenthesis. In this
case, we would have stopped immediately, determining that the <strong>string</strong>
is not matched. Likewise, if we had encountered a closing parenthesis
that did not match the parenthesis at the top of the stack, this would
have indicated a mismatched pair. Again, we would have stopped
immediately. Finally, if we had reached the end of the <strong>string</strong> with a
nonempty stack, this would have indicated that we had at least one
opening parenthesis that was never matched. We would have again
determined that the <strong>string</strong> is not matched.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-stack>Implementing a Stack</h1></div><h2 id=implementing-a-stack>Implementing a Stack</h2><p>This section gives an overview of perhaps the most common way to
implement a stack. For example, the implementations of both
<strong>System.Collections.Stack</strong> and
<strong>System.Collections.Generic.Stack&lt;T></strong> use this technique. This
implementation uses an array to store the elements of the stack, and is
quite similar to the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a> we
described in the last chapter. We have discussed two kinds of stacks in
this chapter - stacks of <strong>object?</strong>s and generic stacks. We will focus
on implementing a generic stack in this section, as it is easy to modify
such an implementation to be non-generic.</p><p><span id=generic></span> We first need to consider how to define a
generic class. In the simplest case, we simply add a type parameter to
the <strong>class</strong> statement, as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Stack</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Within this <strong>class</strong> definition, <strong>T</strong> is treated like any other type,
except that the compiler knows nothing about it. We can declare fields,
parameters, and local variables to be of type <strong>T</strong>. Even though the
compiler knows nothing about <strong>T</strong>, it will still do type checking - you
cannot assign an expression of any other type to a variable of type
<strong>T</strong>, and you can only assign an expression of type <strong>T</strong> to variables
of either type <strong>T</strong> or type <strong>object?</strong> (because any type is a subtype
of <strong>object?</strong>). Assigning an expression of type <strong>T</strong> to an <strong>object</strong> variable may generate a compiler warning, but is permitted as well. In general, we can define generic data types with any
number of type parameters if more that one generic type is needed by the
data structure. To do this, we would list the type parameters, separated
by commas, between the <code>&lt;</code> and <code>></code> symbols of the generic <strong>class</strong>
definition. Each of the type parameters is then treated as a type within
the <strong>class</strong> definition. We will show how the types passed as type
parameters can be restricted in <a href=/cis300/dictionaries/linked-list-impl/#where>a later
section</a>.</p><p>For the class <strong>Stack&lt;T></strong>, only one type parameter is needed. The
type parameter <strong>T</strong> denotes the type of the values that are stored in
the stack. Therefore, the array in which we will store the elements will
be of type <strong>T?[Â ]</strong>. The <code>?</code> is needed because if a reference type is used for <strong>T</strong>, when the array is constructed, all locations will initially store <strong>null</strong>, and will continue to store <strong>null</strong> until stack elements are placed into them.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>In the section, <a href=/cis300/appendix/syntax/reference-value/#nullable-types>&ldquo;Reference Types and Value Types&rdquo;</a>, we explained how the <code>?</code> operator behaves differently depending on whether the underlying type is a reference type or a value type. Because a type parameter might represent either a reference type or a value type, we need to address how this operator behaves for a type parameter. Similar to its behavior for a reference type, when this operator is used with a type parameter, the code produced is unchanged. Instead, it is simply an annotation indicating that <strong>null</strong> values may be present. Note that this can happen only if the underlying type happens to be a reference type.</p></div></div><p>As in the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>,
we will need a <strong>private</strong> field for this array. This field can be
initialized in a manner similar to the <strong>StringBuilder</strong> implementation;
hence, we don&rsquo;t need to write a constructor.</p><p>A stack has a <strong>public</strong> read-only property, <strong>Count</strong>, which gets the
number of elements in the stack (as an <strong>int</strong>). We can define this
property to use the default implementation with a <strong>private</strong> set
accessor, as outlined in the section,
&ldquo;<a href=/cis300/appendix/syntax/properties/>Properties</a>&rdquo;.</p><p>Before we can delve any further into the implementation, we need to
decide how we are going to arrange the elements in the array. Because
all of our accesses will be to the top of the stack, it makes sense to
keep the bottom element of the stack at location 0, and as we go up the
stack, keep each successive element in the next location:</p><p><a href=#R-image-c87ee20500d29996f8a351859e706971 class=lightbox-link><img alt="The arrangement of stack elements in the array." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/stack-impl/stack-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c87ee20500d29996f8a351859e706971><img alt="The arrangement of stack elements in the array." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/stack-impl/stack-impl.jpg></a></p><p>This arrangement makes sense because unless all of the array locations
are being used, there is room to push a new element on top of the stack
without having to move any pre-existing elements out of its way.</p><p>Note the similarity of this arrangement to the <a href=/cis300/strings/stringbuilder-impl/>implementation of a
<strong>StringBuilder</strong></a>.
Given this similarity, we can implement the <strong>Push</strong> method in a similar
way to how we implemented the <strong>Append</strong> method for a <strong>StringBuilder</strong>.
Instead of taking a <strong>char</strong> parameter, the <strong>Push</strong> method takes a
<strong>T</strong> parameter, but this is the type that we can store in the array.
The biggest difference in these two methods is that while <strong>Append</strong>
returns a <strong>StringBuilder</strong>, <strong>Push</strong> returns nothing.</p><p>We now need to implement the <strong>public</strong> methods that retrieve elements
from the stack. We will start with the <strong>Peek</strong> method, which takes no
parameters and returns a <strong>T</strong>. This method needs to begin with some
error checking: if there are no elements in the stack, it needs to throw
an <strong>InvalidOperationException</strong>. We can do this by constructing such an
exception and throwing it with the <strong>throw</strong> keyword:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>();</span></span></span></code></pre></div><p>If there are elements in the stack, we need to return the one at the
top. Note from the figure above that the top element is at the location
preceding the location indexed by <strong>Count</strong>. However, note that this element is of type <strong>T?</strong>, whereas the return type of <strong>Peek</strong> is <strong>T</strong>. Thus, returning this element will generate a warning unless we use the <code>!</code> operator. This operator is safe to use here because the location we are returning stores an element that was passed to <strong>Push</strong> as type <strong>T</strong>.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>Note that because <strong>T</strong> can represent any type, it is possible that it represents a nullable type; for example, it is permissible to define a <strong>Stack&lt;string?></strong>. Therefore, it is possible that the element being returned is <strong>null</strong>. However, we don&rsquo;t need to concern ourselves with this case, as it will be handled by the calling code. The point is that we are returning something of type <strong>T</strong>, even if <strong>T</strong> represents a non-nullable reference type.</p></div></div><p>The other <strong>public</strong> method to retrieve an element is the <strong>Pop</strong>
method. This method also takes no parameters and returns a <strong>T</strong>. Part
of what it does we have already implemented in the <strong>Peek</strong> method. In
order to avoid duplicating code, we can retrieve the top element using
the <strong>Peek</strong> method, and save it in a local variable so that we can
return it when we are finished with this method (avoiding code
duplication improves maintainability, as there are fewer places that
might need to be modified later). Note that by using the <strong>Peek</strong>
method, we are taking advantage of the fact that it checks whether the
stack is empty; hence, there is no need to do that here. Before we can
return the value we retrieved, we need to update <strong>Count</strong> to reflect
the fact that we are removing one element.</p><p>While what we have described in the preceding paragraph is sufficient
for correct functioning, there is one issue we need to address. Note
that we have done nothing to the array location that stored the value we
popped - it still stores that value. This fact does not impact
correctness, however, because after we update the number of elements, we
are no longer considering that location to be storing a stack element -
its contents are irrelevant. Nevertheless, there is a performance issue here.
If <strong>T</strong> is a <a href=/cis300/appendix/syntax/reference-value/>reference
type</a>, then the
reference stored in this location may refer to a large data structure
that is no longer needed by the program. Because this array location
still stores a reference to it, the garbage collector cannot tell that
it is no longer in use, and consequently, it cannot reclaim the storage.</p><p><span id=default-value></span>It therefore makes sense to remove what is stored in this array
location. However, we run into a difficulty when we try to do this. We
can&rsquo;t simply assign <strong>null</strong> to this location because <strong>T</strong> might be a
value type; hence, the compiler will not allow such an assignment. In
order to address this problem, C# has the keyword, <strong>default</strong>, which
can be used to get the default value for a given type. Thus, if <strong>T</strong> is
a reference type, <strong>default(T)</strong> will give us <strong>null</strong>, but if <strong>T</strong> is
a value type, it will give us the value whose binary representation is
all 0s. In order to free up any memory we might no longer need, it
therefore makes sense to assign <strong>default(T)</strong> to an array location
after we are no longer using it.</p><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p>Often the parameter to <strong>default</strong> (including the parentheses) can be
omitted because the compiler
can detect what type is needed. This is the case in the current
context. If using <strong>default</strong> without the
parameter gives a syntax error, supply the parameter.</p></div></div><p>Finally, we can implement a <strong>public Clear</strong> method. This method takes
no parameters and returns nothing. One way to implement it would be to
pop all of the elements, one by one, from the stack. However, this could
be very inefficient if the stack contains a lot of elements. A better
way is simply to change <strong>Count</strong> to 0; however, this way prevents the
garbage collector from reclaiming storage we no longer need. In order to
allow this storage to be reclaimed, we should also replace our array
with a new array of the size we used when we initialized this field
(note that this is more efficient than replacing every element with the
default element of the appropriate type). Because we are no longer using
the old array, the garbage collector can reclaim it, along with any
otherwise unused data it might refer to.</p><p>Due to the similarities between this implementation and the
<a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>,
the two data structures have similar performance characteristics. In
fact, it is possible to show that any sequence of <em>n</em> operations on an
initially empty <strong>Stack&lt;T></strong> is done in <em>O</em>(<em>n</em>) time - i.e., in time
proportional to <em>n</em>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=introduction-to-queues>Introduction to Queues</h1></div><h2 id=introduction-to-queues>Introduction to Queues</h2><p>Stacks provide LIFO access to data, but sometimes we need
first-in-first-out, or <em>FIFO</em>, access.
Consider, for example, the computation of capital gains from stock
sales. Typically an investor will buy shares of a stock commodity at
various times and for different prices. When shares are sold, the amount
of money received doesn&rsquo;t depend on <em>which</em> shares of a given commodity
are sold, as each share is worth the same amount at that time. Likewise,
the unsold shares of that commodity each have the same value. However,
for accounting purposes, it does matter. Specifically, the <em>capital
gain</em> for that sale is defined to be the amount received from the sale
minus the amount originally paid for those shares, assuming the shares
sold are the oldest shares of that commodity owned by the investor.</p><p>Suppose now that we want to compute the capital gains from sales of
stock. As shares are purchased, we need to record the purchase price of
each share, along with the order in which the shares were purchased. As
shares are sold, we need to retrieve the original purchase price of the
oldest shares of each commodity sold. We therefore need
first-in-first-out access to the purchase prices of the shares of each
commodity owned. To keep this relatively simple, in what follows we will
assume that we only need to keep track of one stock commodity.</p><p>A <em>queue</em> provides FIFO access to data items. Like a stack, a queue is a
sequence of data items. However, a queue behaves more like a line of
people at a ticket counter. Each person who enters the queue enters at
the <em>back</em>, and the next person who is served is the person at the
<em>front</em>. Thus, the people in the queue are served in FIFO order.
Likewise, new data items are added to the back of a queue, and data
items are retrieved from the front.</p><p>.NET provides both a non-generic queue of <strong>object?</strong>s
(<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.queue?view=net-6.0" rel=external target=_blank><strong>System.Collections.Queue</strong></a>)
and a generic queue
(<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=net-6.0" rel=external target=_blank><strong>System.Collections.Generic.Queue&lt;T></strong></a>).
For simplicity, we will focus on the generic version. The non-generic
version is the same, except that wherever the type parameter <strong>T</strong> is
used in the generic version, <strong>object?</strong> is used in the non-generic
version.</p><p>Like <strong>Stack&lt;T></strong>, <strong>Queue&lt;T></strong> has a <strong>public</strong>
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1.-ctor?view=net-6.0#system-collections-generic-queue-1-ctor" rel=external target=_blank>constructor</a>
that takes no parameters and constructs an empty queue, along with a
<strong>public</strong>
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1.count?view=net-6.0#system-collections-generic-queue-1-count" rel=external target=_blank><strong>Count</strong></a>
property that gets the number of elements in the queue (as an <strong>int</strong>).
It also has the following <strong>public</strong> methods:</p><ul><li>An
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1.enqueue?view=net-6.0#system-collections-generic-queue-1-enqueue(-0)" rel=external target=_blank><strong>Enqueue</strong></a>
method that takes a single parameter of type <strong>T</strong> and places it at
the back of the queue.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1.peek?view=net-6.0#system-collections-generic-queue-1-peek" rel=external target=_blank><strong>Peek</strong></a>
method that takes no parameters and returns the element (of type
<strong>T</strong>) at the front of the queue without changing the queue&rsquo;s
contents. If the queue is empty, this method throws an
<strong>InvalidOperationException</strong>.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1.dequeue?view=net-6.0#system-collections-generic-queue-1-dequeue" rel=external target=_blank><strong>Dequeue</strong></a>
method, which takes no parameters and removes and returns the
element at the front of the queue. If the queue is empty, this
method throws an <strong>InvalidOperationException</strong>.</li></ul><p>To implement a capital gain calculator using a <strong>Queue&lt;T></strong>, we first
need to determine what type to make the elements. We will need to store
the purchase price of each share we buy in the queue. An appropriate
type for storing monetary amounts is the
<a href=/cis300/appendix/syntax/decimals/><strong>decimal</strong></a> type.
Therefore, we will use an initially empty <strong>Queue&lt;decimal></strong>. Each
time we buy shares, we enqueue the purchase price of each share onto the
queue. When we sell shares, we need to compute the sum of the capital
gains for all of the shares we sold. To get the capital gain for a
single share, we dequeue its original purchase price from the queue, and
subtract that purchase price from the selling price. Using the queue in
this way ensures that we sell the shares in FIFO order.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-queue>Implementing a Queue</h1></div><h2 id=implementing-a-queue>Implementing a Queue</h2><p>We will approach the implementation of a queue much like we did the
<a href=/cis300/stacks-queues/stack-impl/>implementation of a
stack</a> - we will use part
of an array to store the elements, and create a larger array as needed.
However, efficiently implementing a stack is easier because we only need
to access one end of a stack, but we need to access both ends of a
queue. Suppose, for example, that we were to use the initial part of the
array, as we did for a stack; i.e.:</p><p><a href=#R-image-4694e87cdc89b48a4005dc38c819c63a class=lightbox-link><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-4694e87cdc89b48a4005dc38c819c63a><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg></a></p><p>This implementation works well as long as we are only enqueuing elements
&mdash; each element is placed at the back, much like pushing an element onto
a stack. However, consider what happens when we dequeue an element. The
element is easy to locate, as it must be at index 0, but in order to
maintain the above picture, we would need to move all of the remaining
elements one location to the left. This becomes less efficient as the
number of elements in the queue increases.</p><p>One alternative is to modify the picture somewhat:</p><p><a href=#R-image-4639ee34eb315ec2e569f1cb9f5322ed class=lightbox-link><img alt="A more general queue implementation" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-4639ee34eb315ec2e569f1cb9f5322ed><img alt="A more general queue implementation" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg></a></p><p>We can maintain this picture more efficiently, as there is now no need
to move the elements when we dequeue an element. It does mean that we
need to keep track of a bit more information, namely, the location of
either the front or the back, in addition to the <strong>Count</strong> (note that we
can compute the other end from these two values). But a more serious
problem remains. Notice that as we enqueue and dequeue elements, the
portion of the array that we are using works its way to the right.
Eventually, the back element will be the last element in the array.
However, this doesn&rsquo;t mean that we are using the entire array, as the
front can be anywhere in the array.</p><p>To solve this problem, when we need to enqueue an element but the back
element is in the last array location, we place the next element at
index 0. It is as if we are imagining the array as being circular, as
the next location after the last is back at the beginning. The following
picture gives two views of such a &ldquo;circular array&rdquo; implementation:</p><p><a href=#R-image-59c8aa317abbeb3f7ac04d7df2eb4caa class=lightbox-link><img alt="A circular array implementation of a queue" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-59c8aa317abbeb3f7ac04d7df2eb4caa><img alt="A circular array implementation of a queue" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg></a></p><p>With this implementation, we only need to construct a larger array if we
completely fill the current array, and unless we need to do this, we
don&rsquo;t need to move elements around. We need the following class members
in order to keep track of everything:</p><ul><li>a <strong>private T?[Â ]</strong> field in which to store the elements;</li><li>a <strong>public int Count</strong> property; and</li><li>a <strong>private int</strong> field giving the index of the element at the front
of the queue (if the queue is empty, this can be any valid index).</li></ul><p>Let us now consider how we would implement <strong>Enqueue</strong>. We first need to
determine whether the array is full by comparing the <strong>Count</strong> with the
size of the array. If it is full, we need to construct a new array of
twice the size, as we did for both the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>
and the <a href=/cis300/stacks-queues/stack-impl/>stack
implementation</a>. However,
we can&rsquo;t simply copy the entire array to the beginning of the new array,
as we did for these other two implementations. To do so would leave a
gap in the middle of the queue, as shown in the following illustration:</p><p><a href=#R-image-ccc74f57a94bdf9dcda56af4672ae56d class=lightbox-link><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ccc74f57a94bdf9dcda56af4672ae56d><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg></a></p><p>While there are several ways of copying the elements correctly, it may
be helpful to copy in such a way that the index of the front of the
queue remains unchanged; i.e., we copy as follows:</p><p><a href=#R-image-21b01ab5fb8ab1fa3f8e7d894168695c class=lightbox-link><img alt="A correct copy for a circular array" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-21b01ab5fb8ab1fa3f8e7d894168695c><img alt="A correct copy for a circular array" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg></a></p><p>In order to copy the elements like this, we can use the <strong>static</strong>
method,
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-6.0#system-array-copy(system-array-system-int32-system-array-system-int32-system-int32)" rel=external target=_blank><strong>Array.Copy</strong></a>.
This method takes the following parameters:</p><ul><li>The array to copy from.</li><li>An <strong>int</strong> giving the index of the first element to copy.</li><li>The array to copy to.</li><li>An <strong>int</strong> giving the index in which to place the first element.</li><li>An <strong>int</strong> giving the number of elements to copy.</li></ul><p>Just figuring out how to fill in these parameters takes some work. Let&rsquo;s
first consider the part that begins with the front of the queue. The
index of the first element to copy is the index of the front of the
queue, which we have in a <strong>private</strong> field. We want to place this
element at the same index in the new array. In order to compute the
number of elements to copy, first observe that we know the number of
elements in the original array (we can use either the <strong>Count</strong> property
or the length of this array, as these values are equal whenever we need
a larger array). To get the number of elements we want to copy, we can
subtract from this value the number of elements we are <em>not</em> copying &mdash;
i.e., the number of elements preceding the index of the front of the
queue. The number of elements preceding any index <em>i</em> is always <em>i</em>;
hence, by subtracting the index of the front of the queue from the
<strong>Count</strong>, we get the number of elements we are copying by this call.</p><p>Now let&rsquo;s see if we can figure out the parameters for the other call.
The first element we want to copy is at index 0. We want to place it
immediately following the elements we have already copied. Because the
last of these elements occupies the last index of the original array,
whose size is currently the same as the <strong>Count</strong>, the next index is
just the <strong>Count</strong>. The number of elements we want to copy, as we have
already argued, is the index of the front of the queue.</p><p>Once we have the elements copied to the new array, the hardest part is
done. After we do this, we just need to copy the reference to the new
array into the array field.</p><p>Once we have ensured that there is room in the array to add a new
element, we can complete the <strong>Enqueue</strong> method. We need to place the
element at the back of the queue. We can obtain the proper location by
adding the <strong>Count</strong> to the index of the front of the queue, provided
this value is not beyond the end of the array. If it is, then we need to
wrap it around by subtracting the length of the array. We can then
increment the number of elements, and we are (finally) done.</p><p>The <strong>Peek</strong> method is straightforward &mdash; after verifying that the queue
is nonempty, we simply return the element at the front. The <strong>Dequeue</strong>
method isn&rsquo;t much more difficult. We can obtain the element we want to
return using the <strong>Peek</strong> method. We then need to place the default
element of type <strong>T</strong> at the front, and update both the index of the
front of the queue and the <strong>Count</strong> before returning the element we
obtained ealier from <strong>Peek</strong>. The only slightly tricky part is making
sure that when we update the index of the front of the queue, we don&rsquo;t
go outside of the array. If we do, we need to wrap it back around to 0.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5>May 22, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1756138921 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1756138921 defer></script><script src=/cis300/js/theme.js?1756138921 defer></script></body></html>