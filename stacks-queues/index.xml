




	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stacks and Queues on Data Structures in C#</title>
    <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/index.html</link>
    <description>Recent content in Stacks and Queues on Data Structures in C#</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://ksu-cs-textbooks.github.io/cis300/stacks-queues/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction to Stacks</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stacks/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stacks/index.html</guid>
      <description>Introduction to Stacks A stack provides last-in-first-out (LIFO) access to data items. We usually think of a stack as arranging data items vertically, like a stack of trays in a cafeteria. Access is normally provided only at the top of the stack; hence, if we want to add an item, we push it onto the top, and if we want to remove an item, we pop it from the top. Because we only access the top of the stack, the item that we pop is always the remaining item that we had pushed the most recently.</description>
    </item>
    <item>
      <title>Implementing Undo and Redo for a TextBox</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/undo/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/undo/index.html</guid>
      <description>Implementing Undo and Redo for a TextBox A TextBox has a rather crude Undo/Redo feature. By right-clicking on a TextBox, a popup menu containing an Undo entry is presented. This Undo will undo only one action, which may include several edits. An immediate subsequent Undo will undo the Undo - in essence, a Redo. The same behavior can be achieved using Ctrl+Z. A more powerful Undo/Redo feature would allow an arbitrary sequence of edits to be undone, with the option of redoing any of these Undo operations.</description>
    </item>
    <item>
      <title>Parenthesis Matching</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/paren/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/paren/index.html</guid>
      <description>Parenthesis Matching The problem of finding matching parentheses must be solved in many computing applications. For example, consider a C# compiler. Matching parentheses (( and )), brackets ([ and ]), and braces ({ and }) delimit various parts of the source code. In order for these parts to be interpreted correctly, the compiler must be able to determine how these different kinds of parentheses match up with each other. Another example is processing structured data stored in XML format.</description>
    </item>
    <item>
      <title>Implementing a Stack</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/stack-impl/index.html</guid>
      <description>Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack&amp;lt;T&amp;gt; use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of object?s and generic stacks.</description>
    </item>
    <item>
      <title>Introduction to Queues</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queues/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queues/index.html</guid>
      <description>Introduction to Queues Stacks provide LIFO access to data, but sometimes we need first-in-first-out, or FIFO, access. Consider, for example, the computation of capital gains from stock sales. Typically an investor will buy shares of a stock commodity at various times and for different prices. When shares are sold, the amount of money received doesn&amp;rsquo;t depend on which shares of a given commodity are sold, as each share is worth the same amount at that time.</description>
    </item>
    <item>
      <title>Implementing a Queue</title>
      <link>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queue-impl/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis300/stacks-queues/queue-impl/index.html</guid>
      <description>Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.</description>
    </item>
  </channel>
</rss>