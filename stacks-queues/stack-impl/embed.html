<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack<T> use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of object?s and generic stacks."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Stack :: Data Structures in C#"><meta name=twitter:description content="Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack<T> use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of object?s and generic stacks."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/stacks-queues/stack-impl/embed.html"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing a Stack :: Data Structures in C#"><meta property="og:description" content="Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack<T> use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of object?s and generic stacks."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Stacks and Queues"><meta property="article:modified_time" content="2023-06-01T15:44:17-05:00"><meta itemprop=name content="Implementing a Stack :: Data Structures in C#"><meta itemprop=description content="Implementing a Stack This section gives an overview of perhaps the most common way to implement a stack. For example, the implementations of both System.Collections.Stack and System.Collections.Generic.Stack<T> use this technique. This implementation uses an array to store the elements of the stack, and is quite similar to the StringBuilder implementation we described in the last chapter. We have discussed two kinds of stacks in this chapter - stacks of object?s and generic stacks."><meta itemprop=dateModified content="2023-06-01T15:44:17-05:00"><meta itemprop=wordCount content="1653"><title>Implementing a Stack :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737139521 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737139521 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737139521 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737139521 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737139521 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737139521 rel=stylesheet><link href=/cis300/css/fonts.css?1737139521 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737139521 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737139521 rel=stylesheet><link href=/cis300/css/theme-light-theme.css?1737139521 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-relearn-light.css?1737139521 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737139521 rel=stylesheet><link href=/cis300/css/print.css?1737139521 rel=stylesheet media=print><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["light-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737139521 rel=stylesheet></head><body class="mobile-support embed disableInlineCopyToClipboard" data-url=/cis300/stacks-queues/stack-impl/embed.html><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><h2 id=implementing-a-stack>Implementing a Stack</h2><p>This section gives an overview of perhaps the most common way to
implement a stack. For example, the implementations of both
<strong>System.Collections.Stack</strong> and
<strong>System.Collections.Generic.Stack&lt;T></strong> use this technique. This
implementation uses an array to store the elements of the stack, and is
quite similar to the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a> we
described in the last chapter. We have discussed two kinds of stacks in
this chapter - stacks of <strong>object?</strong>s and generic stacks. We will focus
on implementing a generic stack in this section, as it is easy to modify
such an implementation to be non-generic.</p><p><span id=generic></span> We first need to consider how to define a
generic class. In the simplest case, we simply add a type parameter to
the <strong>class</strong> statement, as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Stack</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Within this <strong>class</strong> definition, <strong>T</strong> is treated like any other type,
except that the compiler knows nothing about it. We can declare fields,
parameters, and local variables to be of type <strong>T</strong>. Even though the
compiler knows nothing about <strong>T</strong>, it will still do type checking - you
cannot assign an expression of any other type to a variable of type
<strong>T</strong>, and you can only assign an expression of type <strong>T</strong> to variables
of either type <strong>T</strong> or type <strong>object?</strong> (because any type is a subtype
of <strong>object?</strong>). Assigning an expression of type <strong>T</strong> to an <strong>object</strong> variable may generate a compiler warning, but is permitted as well. In general, we can define generic data types with any
number of type parameters if more that one generic type is needed by the
data structure. To do this, we would list the type parameters, separated
by commas, between the <code>&lt;</code> and <code>></code> symbols of the generic <strong>class</strong>
definition. Each of the type parameters is then treated as a type within
the <strong>class</strong> definition. We will show how the types passed as type
parameters can be restricted in <a href=/cis300/dictionaries/linked-list-impl/#where>a later
section</a>.</p><p>For the class <strong>Stack&lt;T></strong>, only one type parameter is needed. The
type parameter <strong>T</strong> denotes the type of the values that are stored in
the stack. Therefore, the array in which we will store the elements will
be of type <strong>T?[Â ]</strong>. The <code>?</code> is needed because if a reference type is used for <strong>T</strong>, when the array is constructed, all locations will initially store <strong>null</strong>, and will continue to store <strong>null</strong> until stack elements are placed into them.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>In the section, <a href=/cis300/appendix/syntax/reference-value/#nullable-types>&ldquo;Reference Types and Value Types&rdquo;</a>, we explained how the <code>?</code> operator behaves differently depending on whether the underlying type is a reference type or a value type. Because a type parameter might represent either a reference type or a value type, we need to address how this operator behaves for a type parameter. Similar to its behavior for a reference type, when this operator is used with a type parameter, the code produced is unchanged. Instead, it is simply an annotation indicating that <strong>null</strong> values may be present. Note that this can happen only if the underlying type happens to be a reference type.</p></div></div><p>As in the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>,
we will need a <strong>private</strong> field for this array. This field can be
initialized in a manner similar to the <strong>StringBuilder</strong> implementation;
hence, we don&rsquo;t need to write a constructor.</p><p>A stack has a <strong>public</strong> read-only property, <strong>Count</strong>, which gets the
number of elements in the stack (as an <strong>int</strong>). We can define this
property to use the default implementation with a <strong>private</strong> set
accessor, as outlined in the section,
&ldquo;<a href=/cis300/appendix/syntax/properties/>Properties</a>&rdquo;.</p><p>Before we can delve any further into the implementation, we need to
decide how we are going to arrange the elements in the array. Because
all of our accesses will be to the top of the stack, it makes sense to
keep the bottom element of the stack at location 0, and as we go up the
stack, keep each successive element in the next location:</p><p><a href=#R-image-ba2ede8f5e38143d1f7080fa5c0e5db5 class=lightbox-link><img alt="The arrangement of stack elements in the array." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/stack-impl/stack-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ba2ede8f5e38143d1f7080fa5c0e5db5><img alt="The arrangement of stack elements in the array." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/stack-impl/stack-impl.jpg></a></p><p>This arrangement makes sense because unless all of the array locations
are being used, there is room to push a new element on top of the stack
without having to move any pre-existing elements out of its way.</p><p>Note the similarity of this arrangement to the <a href=/cis300/strings/stringbuilder-impl/>implementation of a
<strong>StringBuilder</strong></a>.
Given this similarity, we can implement the <strong>Push</strong> method in a similar
way to how we implemented the <strong>Append</strong> method for a <strong>StringBuilder</strong>.
Instead of taking a <strong>char</strong> parameter, the <strong>Push</strong> method takes a
<strong>T</strong> parameter, but this is the type that we can store in the array.
The biggest difference in these two methods is that while <strong>Append</strong>
returns a <strong>StringBuilder</strong>, <strong>Push</strong> returns nothing.</p><p>We now need to implement the <strong>public</strong> methods that retrieve elements
from the stack. We will start with the <strong>Peek</strong> method, which takes no
parameters and returns a <strong>T</strong>. This method needs to begin with some
error checking: if there are no elements in the stack, it needs to throw
an <strong>InvalidOperationException</strong>. We can do this by constructing such an
exception and throwing it with the <strong>throw</strong> keyword:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>();</span></span></span></code></pre></div><p>If there are elements in the stack, we need to return the one at the
top. Note from the figure above that the top element is at the location
preceding the location indexed by <strong>Count</strong>. However, note that this element is of type <strong>T?</strong>, whereas the return type of <strong>Peek</strong> is <strong>T</strong>. Thus, returning this element will generate a warning unless we use the <code>!</code> operator. This operator is safe to use here because the location we are returning stores an element that was passed to <strong>Push</strong> as type <strong>T</strong>.</p><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>Note that because <strong>T</strong> can represent any type, it is possible that it represents a nullable type; for example, it is permissible to define a <strong>Stack&lt;string?></strong>. Therefore, it is possible that the element being returned is <strong>null</strong>. However, we don&rsquo;t need to concern ourselves with this case, as it will be handled by the calling code. The point is that we are returning something of type <strong>T</strong>, even if <strong>T</strong> represents a non-nullable reference type.</p></div></div><p>The other <strong>public</strong> method to retrieve an element is the <strong>Pop</strong>
method. This method also takes no parameters and returns a <strong>T</strong>. Part
of what it does we have already implemented in the <strong>Peek</strong> method. In
order to avoid duplicating code, we can retrieve the top element using
the <strong>Peek</strong> method, and save it in a local variable so that we can
return it when we are finished with this method (avoiding code
duplication improves maintainability, as there are fewer places that
might need to be modified later). Note that by using the <strong>Peek</strong>
method, we are taking advantage of the fact that it checks whether the
stack is empty; hence, there is no need to do that here. Before we can
return the value we retrieved, we need to update <strong>Count</strong> to reflect
the fact that we are removing one element.</p><p>While what we have described in the preceding paragraph is sufficient
for correct functioning, there is one issue we need to address. Note
that we have done nothing to the array location that stored the value we
popped - it still stores that value. This fact does not impact
correctness, however, because after we update the number of elements, we
are no longer considering that location to be storing a stack element -
its contents are irrelevant. Nevertheless, there is a performance issue here.
If <strong>T</strong> is a <a href=/cis300/appendix/syntax/reference-value/>reference
type</a>, then the
reference stored in this location may refer to a large data structure
that is no longer needed by the program. Because this array location
still stores a reference to it, the garbage collector cannot tell that
it is no longer in use, and consequently, it cannot reclaim the storage.</p><p><span id=default-value></span>It therefore makes sense to remove what is stored in this array
location. However, we run into a difficulty when we try to do this. We
can&rsquo;t simply assign <strong>null</strong> to this location because <strong>T</strong> might be a
value type; hence, the compiler will not allow such an assignment. In
order to address this problem, C# has the keyword, <strong>default</strong>, which
can be used to get the default value for a given type. Thus, if <strong>T</strong> is
a reference type, <strong>default(T)</strong> will give us <strong>null</strong>, but if <strong>T</strong> is
a value type, it will give us the value whose binary representation is
all 0s. In order to free up any memory we might no longer need, it
therefore makes sense to assign <strong>default(T)</strong> to an array location
after we are no longer using it.</p><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p>Often the parameter to <strong>default</strong> (including the parentheses) can be
omitted because the compiler
can detect what type is needed. This is the case in the current
context. If using <strong>default</strong> without the
parameter gives a syntax error, supply the parameter.</p></div></div><p>Finally, we can implement a <strong>public Clear</strong> method. This method takes
no parameters and returns nothing. One way to implement it would be to
pop all of the elements, one by one, from the stack. However, this could
be very inefficient if the stack contains a lot of elements. A better
way is simply to change <strong>Count</strong> to 0; however, this way prevents the
garbage collector from reclaiming storage we no longer need. In order to
allow this storage to be reclaimed, we should also replace our array
with a new array of the size we used when we initialized this field
(note that this is more efficient than replacing every element with the
default element of the appropriate type). Because we are no longer using
the old array, the garbage collector can reclaim it, along with any
otherwise unused data it might refer to.</p><p>Due to the similarities between this implementation and the
<a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>,
the two data structures have similar performance characteristics. In
fact, it is possible to show that any sequence of <em>n</em> operations on an
initially empty <strong>Stack&lt;T></strong> is done in <em>O</em>(<em>n</em>) time - i.e., in time
proportional to <em>n</em>.</p><footer class=footline></footer></article></div></main></div><script src=/cis300/js/clipboard.min.js?1737139521 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737139521 defer></script><script src=/cis300/js/theme.js?1737139521 defer></script><script src=/cis300/js/embed-iframe.js?1737139521 defer></script></body></html>