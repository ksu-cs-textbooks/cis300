<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.e.:"><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Queue :: Data Structures in C#"><meta name=twitter:description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.e.:"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/stacks-queues/queue-impl/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing a Queue :: Data Structures in C#"><meta property="og:description" content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.e.:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Stacks and Queues"><meta property="article:modified_time" content="2023-06-01T15:44:17-05:00"><meta itemprop=name content="Implementing a Queue :: Data Structures in C#"><meta itemprop=description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i.e.:"><meta itemprop=dateModified content="2023-06-01T15:44:17-05:00"><meta itemprop=wordCount content="1178"><title>Implementing a Queue :: Data Structures in C#</title><link href=https://textbooks.cs.ksu.edu/cis300/stacks-queues/queue-impl/ rel=canonical type=text/html title="Implementing a Queue :: Data Structures in C#"><link href=/cis300/stacks-queues/queue-impl/index.xml rel=alternate type=application/rss+xml title="Implementing a Queue :: Data Structures in C#"><link href=/cis300/stacks-queues/queue-impl/tele.html rel=alternate type=text/html title="Implementing a Queue :: Data Structures in C#"><link href=/cis300/stacks-queues/queue-impl/embed.html rel=alternate type=text/html title="Implementing a Queue :: Data Structures in C#"><link href=/cis300/css/auto-complete/auto-complete.min.css?1759520014 rel=stylesheet><script src=/cis300/js/auto-complete/auto-complete.min.js?1759520014 defer></script><script src=/cis300/js/search-lunr.min.js?1759520014 defer></script><script src=/cis300/js/search.min.js?1759520014 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis300/searchindex.en.js?1759520014"</script><script src=/cis300/js/lunr/lunr.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.stemmer.support.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.multi.min.js?1759520014 defer></script><script src=/cis300/js/lunr/lunr.en.min.js?1759520014 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1759520014 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/fonts/fontawesome/css/fontawesome-all.min.css?1759520014 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar/perfect-scrollbar.min.css?1759520014 rel=stylesheet><link href=/cis300/css/theme.min.css?1759520014 rel=stylesheet><link href=/cis300/css/format-print.min.css?1759520014 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/stacks-queues/queue-impl/",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis300/css/custom.css?1759520014 rel=stylesheet></head><body class="mobile-support embed print" data-url=/cis300/stacks-queues/queue-impl/><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable stacks-queues" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-queue>Implementing a Queue</h1></div><h2 id=implementing-a-queue>Implementing a Queue</h2><p>We will approach the implementation of a queue much like we did the
<a href=/cis300/stacks-queues/stack-impl/>implementation of a
stack</a> - we will use part
of an array to store the elements, and create a larger array as needed.
However, efficiently implementing a stack is easier because we only need
to access one end of a stack, but we need to access both ends of a
queue. Suppose, for example, that we were to use the initial part of the
array, as we did for a stack; i.e.:</p><p><a href=#R-image-2943218fd7a8ad05efa7f3d207ff947f class=lightbox-link><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-2943218fd7a8ad05efa7f3d207ff947f><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg></a></p><p>This implementation works well as long as we are only enqueuing elements
&mdash; each element is placed at the back, much like pushing an element onto
a stack. However, consider what happens when we dequeue an element. The
element is easy to locate, as it must be at index 0, but in order to
maintain the above picture, we would need to move all of the remaining
elements one location to the left. This becomes less efficient as the
number of elements in the queue increases.</p><p>One alternative is to modify the picture somewhat:</p><p><a href=#R-image-bbda75eeb05788435753ea24f3d26dab class=lightbox-link><img alt="A more general queue implementation" class="border lazy lightbox figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-bbda75eeb05788435753ea24f3d26dab><img alt="A more general queue implementation" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg></a></p><p>We can maintain this picture more efficiently, as there is now no need
to move the elements when we dequeue an element. It does mean that we
need to keep track of a bit more information, namely, the location of
either the front or the back, in addition to the <strong>Count</strong> (note that we
can compute the other end from these two values). But a more serious
problem remains. Notice that as we enqueue and dequeue elements, the
portion of the array that we are using works its way to the right.
Eventually, the back element will be the last element in the array.
However, this doesn&rsquo;t mean that we are using the entire array, as the
front can be anywhere in the array.</p><p>To solve this problem, when we need to enqueue an element but the back
element is in the last array location, we place the next element at
index 0. It is as if we are imagining the array as being circular, as
the next location after the last is back at the beginning. The following
picture gives two views of such a &ldquo;circular array&rdquo; implementation:</p><p><a href=#R-image-e28fd337a983bcb3e5274fea8f416bdb class=lightbox-link><img alt="A circular array implementation of a queue" class="border lazy lightbox figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e28fd337a983bcb3e5274fea8f416bdb><img alt="A circular array implementation of a queue" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg></a></p><p>With this implementation, we only need to construct a larger array if we
completely fill the current array, and unless we need to do this, we
don&rsquo;t need to move elements around. We need the following class members
in order to keep track of everything:</p><ul><li>a <strong>private T?[Â ]</strong> field in which to store the elements;</li><li>a <strong>public int Count</strong> property; and</li><li>a <strong>private int</strong> field giving the index of the element at the front
of the queue (if the queue is empty, this can be any valid index).</li></ul><p>Let us now consider how we would implement <strong>Enqueue</strong>. We first need to
determine whether the array is full by comparing the <strong>Count</strong> with the
size of the array. If it is full, we need to construct a new array of
twice the size, as we did for both the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>
and the <a href=/cis300/stacks-queues/stack-impl/>stack
implementation</a>. However,
we can&rsquo;t simply copy the entire array to the beginning of the new array,
as we did for these other two implementations. To do so would leave a
gap in the middle of the queue, as shown in the following illustration:</p><p><a href=#R-image-254e5e8bd02d1192eb923b19de2d1638 class=lightbox-link><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-254e5e8bd02d1192eb923b19de2d1638><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg></a></p><p>While there are several ways of copying the elements correctly, it may
be helpful to copy in such a way that the index of the front of the
queue remains unchanged; i.e., we copy as follows:</p><p><a href=#R-image-d9ad3817ea48e17db2eb93d35acf5e57 class=lightbox-link><img alt="A correct copy for a circular array" class="border lazy lightbox figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-d9ad3817ea48e17db2eb93d35acf5e57><img alt="A correct copy for a circular array" class="border lazy lightbox lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg></a></p><p>In order to copy the elements like this, we can use the <strong>static</strong>
method,
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-6.0#system-array-copy(system-array-system-int32-system-array-system-int32-system-int32)" rel=external target=_blank><strong>Array.Copy</strong></a>.
This method takes the following parameters:</p><ul><li>The array to copy from.</li><li>An <strong>int</strong> giving the index of the first element to copy.</li><li>The array to copy to.</li><li>An <strong>int</strong> giving the index in which to place the first element.</li><li>An <strong>int</strong> giving the number of elements to copy.</li></ul><p>Just figuring out how to fill in these parameters takes some work. Let&rsquo;s
first consider the part that begins with the front of the queue. The
index of the first element to copy is the index of the front of the
queue, which we have in a <strong>private</strong> field. We want to place this
element at the same index in the new array. In order to compute the
number of elements to copy, first observe that we know the number of
elements in the original array (we can use either the <strong>Count</strong> property
or the length of this array, as these values are equal whenever we need
a larger array). To get the number of elements we want to copy, we can
subtract from this value the number of elements we are <em>not</em> copying &mdash;
i.e., the number of elements preceding the index of the front of the
queue. The number of elements preceding any index <em>i</em> is always <em>i</em>;
hence, by subtracting the index of the front of the queue from the
<strong>Count</strong>, we get the number of elements we are copying by this call.</p><p>Now let&rsquo;s see if we can figure out the parameters for the other call.
The first element we want to copy is at index 0. We want to place it
immediately following the elements we have already copied. Because the
last of these elements occupies the last index of the original array,
whose size is currently the same as the <strong>Count</strong>, the next index is
just the <strong>Count</strong>. The number of elements we want to copy, as we have
already argued, is the index of the front of the queue.</p><p>Once we have the elements copied to the new array, the hardest part is
done. After we do this, we just need to copy the reference to the new
array into the array field.</p><p>Once we have ensured that there is room in the array to add a new
element, we can complete the <strong>Enqueue</strong> method. We need to place the
element at the back of the queue. We can obtain the proper location by
adding the <strong>Count</strong> to the index of the front of the queue, provided
this value is not beyond the end of the array. If it is, then we need to
wrap it around by subtracting the length of the array. We can then
increment the number of elements, and we are (finally) done.</p><p>The <strong>Peek</strong> method is straightforward &mdash; after verifying that the queue
is nonempty, we simply return the element at the front. The <strong>Dequeue</strong>
method isn&rsquo;t much more difficult. We can obtain the element we want to
return using the <strong>Peek</strong> method. We then need to place the default
element of type <strong>T</strong> at the front, and update both the index of the
front of the queue and the <strong>Count</strong> before returning the element we
obtained ealier from <strong>Peek</strong>. The only slightly tricky part is making
sure that when we update the index of the front of the queue, we don&rsquo;t
go outside of the array. If we do, we need to wrap it back around to 0.</p><footer class=footline></footer></article></div></main></div><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/cis300/js/mathjax/tex-mml-chtml.js?1759520014></script><script src=/cis300/js/clipboard/clipboard.min.js?1759520014 defer></script><script src=/cis300/js/perfect-scrollbar/perfect-scrollbar.min.js?1759520014 defer></script><script src=/cis300/js/theme.min.js?1759520014 defer></script><script src=/cis300/js/embed-iframe.min.js?1759520014 defer></script></body></html>