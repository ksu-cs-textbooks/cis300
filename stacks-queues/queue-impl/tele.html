<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Queue :: Data Structures in C#"><meta name=twitter:description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/stacks-queues/queue-impl/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Implementing a Queue :: Data Structures in C#"><meta property="og:description" content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="Stacks and Queues"><meta property="article:modified_time" content="2023-06-01T15:44:17-05:00"><meta itemprop=name content="Implementing a Queue :: Data Structures in C#"><meta itemprop=description content="Implementing a Queue We will approach the implementation of a queue much like we did the implementation of a stack - we will use part of an array to store the elements, and create a larger array as needed. However, efficiently implementing a stack is easier because we only need to access one end of a stack, but we need to access both ends of a queue. Suppose, for example, that we were to use the initial part of the array, as we did for a stack; i."><meta itemprop=dateModified content="2023-06-01T15:44:17-05:00"><meta itemprop=wordCount content="1178"><title>Implementing a Queue :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1737134825 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1737134825 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1737134825 rel=stylesheet><link href=/cis300/css/auto-complete.css?1737134825 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1737134825 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1737134825 rel=stylesheet><link href=/cis300/css/fonts.css?1737134825 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1737134825 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1737134825 rel=stylesheet><link href=/cis300/css/theme-auto.css?1737134825 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1737134825 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1737134825 rel=stylesheet><link href=/cis300/css/print.css?1737134825 rel=stylesheet media=print><script src=/cis300/js/variant.js?1737134825></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1737134825 rel=stylesheet></head><body class="mobile-support tele disableInlineCopyToClipboard" data-url=/cis300/stacks-queues/queue-impl/><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=implementing-a-queue>Implementing a Queue</h1></div><h2 id=implementing-a-queue>Implementing a Queue</h2><p>We will approach the implementation of a queue much like we did the
<a href=/cis300/stacks-queues/stack-impl/>implementation of a
stack</a> - we will use part
of an array to store the elements, and create a larger array as needed.
However, efficiently implementing a stack is easier because we only need
to access one end of a stack, but we need to access both ends of a
queue. Suppose, for example, that we were to use the initial part of the
array, as we did for a stack; i.e.:</p><p><a href=#R-image-8805f285db75179f09a5783f446b7bfb class=lightbox-link><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-8805f285db75179f09a5783f446b7bfb><img alt="A queue implementation using the initial part of an\narray" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-queue-impl.jpg></a></p><p>This implementation works well as long as we are only enqueuing elements
&mdash; each element is placed at the back, much like pushing an element onto
a stack. However, consider what happens when we dequeue an element. The
element is easy to locate, as it must be at index 0, but in order to
maintain the above picture, we would need to move all of the remaining
elements one location to the left. This becomes less efficient as the
number of elements in the queue increases.</p><p>One alternative is to modify the picture somewhat:</p><p><a href=#R-image-cf3c9a2520dd265732e9b8b99bfea29e class=lightbox-link><img alt="A more general queue implementation" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-cf3c9a2520dd265732e9b8b99bfea29e><img alt="A more general queue implementation" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/nowrap-queue.jpg></a></p><p>We can maintain this picture more efficiently, as there is now no need
to move the elements when we dequeue an element. It does mean that we
need to keep track of a bit more information, namely, the location of
either the front or the back, in addition to the <strong>Count</strong> (note that we
can compute the other end from these two values). But a more serious
problem remains. Notice that as we enqueue and dequeue elements, the
portion of the array that we are using works its way to the right.
Eventually, the back element will be the last element in the array.
However, this doesn&rsquo;t mean that we are using the entire array, as the
front can be anywhere in the array.</p><p>To solve this problem, when we need to enqueue an element but the back
element is in the last array location, we place the next element at
index 0. It is as if we are imagining the array as being circular, as
the next location after the last is back at the beginning. The following
picture gives two views of such a &ldquo;circular array&rdquo; implementation:</p><p><a href=#R-image-e4c565d6e43b4f4e734f3ae68f19749a class=lightbox-link><img alt="A circular array implementation of a queue" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-e4c565d6e43b4f4e734f3ae68f19749a><img alt="A circular array implementation of a queue" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/wrapped-queue.jpg></a></p><p>With this implementation, we only need to construct a larger array if we
completely fill the current array, and unless we need to do this, we
don&rsquo;t need to move elements around. We need the following class members
in order to keep track of everything:</p><ul><li>a <strong>private T?[Â ]</strong> field in which to store the elements;</li><li>a <strong>public int Count</strong> property; and</li><li>a <strong>private int</strong> field giving the index of the element at the front
of the queue (if the queue is empty, this can be any valid index).</li></ul><p>Let us now consider how we would implement <strong>Enqueue</strong>. We first need to
determine whether the array is full by comparing the <strong>Count</strong> with the
size of the array. If it is full, we need to construct a new array of
twice the size, as we did for both the <a href=/cis300/strings/stringbuilder-impl/><strong>StringBuilder</strong>
implementation</a>
and the <a href=/cis300/stacks-queues/stack-impl/>stack
implementation</a>. However,
we can&rsquo;t simply copy the entire array to the beginning of the new array,
as we did for these other two implementations. To do so would leave a
gap in the middle of the queue, as shown in the following illustration:</p><p><a href=#R-image-7cc8b7da39d2645ecc6a65a4fba131a5 class=lightbox-link><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-7cc8b7da39d2645ecc6a65a4fba131a5><img alt="Why a simple copy will not work for a circular\narray" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/bad-circular-array-copy.jpg></a></p><p>While there are several ways of copying the elements correctly, it may
be helpful to copy in such a way that the index of the front of the
queue remains unchanged; i.e., we copy as follows:</p><p><a href=#R-image-06a5bc6679f795b686e2322205ec3353 class=lightbox-link><img alt="A correct copy for a circular array" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-06a5bc6679f795b686e2322205ec3353><img alt="A correct copy for a circular array" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/stacks-queues/queue-impl/circular-array-copy.jpg></a></p><p>In order to copy the elements like this, we can use the <strong>static</strong>
method,
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.array.copy?view=net-6.0#system-array-copy(system-array-system-int32-system-array-system-int32-system-int32)" rel=external target=_blank><strong>Array.Copy</strong></a>.
This method takes the following parameters:</p><ul><li>The array to copy from.</li><li>An <strong>int</strong> giving the index of the first element to copy.</li><li>The array to copy to.</li><li>An <strong>int</strong> giving the index in which to place the first element.</li><li>An <strong>int</strong> giving the number of elements to copy.</li></ul><p>Just figuring out how to fill in these parameters takes some work. Let&rsquo;s
first consider the part that begins with the front of the queue. The
index of the first element to copy is the index of the front of the
queue, which we have in a <strong>private</strong> field. We want to place this
element at the same index in the new array. In order to compute the
number of elements to copy, first observe that we know the number of
elements in the original array (we can use either the <strong>Count</strong> property
or the length of this array, as these values are equal whenever we need
a larger array). To get the number of elements we want to copy, we can
subtract from this value the number of elements we are <em>not</em> copying &mdash;
i.e., the number of elements preceding the index of the front of the
queue. The number of elements preceding any index <em>i</em> is always <em>i</em>;
hence, by subtracting the index of the front of the queue from the
<strong>Count</strong>, we get the number of elements we are copying by this call.</p><p>Now let&rsquo;s see if we can figure out the parameters for the other call.
The first element we want to copy is at index 0. We want to place it
immediately following the elements we have already copied. Because the
last of these elements occupies the last index of the original array,
whose size is currently the same as the <strong>Count</strong>, the next index is
just the <strong>Count</strong>. The number of elements we want to copy, as we have
already argued, is the index of the front of the queue.</p><p>Once we have the elements copied to the new array, the hardest part is
done. After we do this, we just need to copy the reference to the new
array into the array field.</p><p>Once we have ensured that there is room in the array to add a new
element, we can complete the <strong>Enqueue</strong> method. We need to place the
element at the back of the queue. We can obtain the proper location by
adding the <strong>Count</strong> to the index of the front of the queue, provided
this value is not beyond the end of the array. If it is, then we need to
wrap it around by subtracting the length of the array. We can then
increment the number of elements, and we are (finally) done.</p><p>The <strong>Peek</strong> method is straightforward &mdash; after verifying that the queue
is nonempty, we simply return the element at the front. The <strong>Dequeue</strong>
method isn&rsquo;t much more difficult. We can obtain the element we want to
return using the <strong>Peek</strong> method. We then need to place the default
element of type <strong>T</strong> at the front, and update both the index of the
front of the queue and the <strong>Count</strong> before returning the element we
obtained ealier from <strong>Peek</strong>. The only slightly tricky part is making
sure that when we update the index of the front of the queue, we don&rsquo;t
go outside of the array. If we do, we need to wrap it back around to 0.</p><footer class=footline></footer></article></div></main></div></div><script src=/cis300/js/clipboard.min.js?1737134825 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1737134825 defer></script><script src=/cis300/js/theme.js?1737134825 defer></script><script src=/cis300/js/tele-scroll.js?1737134825 defer></script></body></html>