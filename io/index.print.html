<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=robots content="noindex, nofollow, noarchive, noimageindex"><meta name=description content="Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event."><meta name=author content="Rod Howell and Josh Weese"><meta name=twitter:card content="summary"><meta name=twitter:title content="Input/Output :: Data Structures in C#"><meta name=twitter:description content="Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis300/io/"><meta property="og:site_name" content="Data Structures in C#"><meta property="og:title" content="Input/Output :: Data Structures in C#"><meta property="og:description" content="Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Input/Output :: Data Structures in C#"><meta itemprop=description content="Input/Output Input and output are central concepts to computing - in order to be able to accomplish a computational task, a program must typically process some input and produce some output. Input and output may be presented in a variety of ways. For example, many programs communicate with users through a graphical user interface, or GUI. In the simplest case, the user performs some action, such as clicking the mouse on a button, thus signaling an event."><meta itemprop=dateModified content="2023-05-22T14:36:43-05:00"><meta itemprop=wordCount content="202"><title>Input/Output :: Data Structures in C#</title>
<link href=/cis300/css/fontawesome-all.min.css?1723839634 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fontawesome-all.min.css?1723839634 rel=stylesheet></noscript><link href=/cis300/css/nucleus.css?1723839634 rel=stylesheet><link href=/cis300/css/auto-complete.css?1723839634 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/auto-complete.css?1723839634 rel=stylesheet></noscript><link href=/cis300/css/perfect-scrollbar.min.css?1723839634 rel=stylesheet><link href=/cis300/css/fonts.css?1723839634 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis300/css/fonts.css?1723839634 rel=stylesheet></noscript><link href=/cis300/css/theme.css?1723839634 rel=stylesheet><link href=/cis300/css/theme-auto.css?1723839634 rel=stylesheet id=R-variant-style><link href=/cis300/css/chroma-auto.css?1723839634 rel=stylesheet id=R-variant-chroma-style><link href=/cis300/css/variant.css?1723839634 rel=stylesheet><link href=/cis300/css/print.css?1723839634 rel=stylesheet media=print><link href=/cis300/css/format-print.css?1723839634 rel=stylesheet><script src=/cis300/js/variant.js?1723839634></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis300",window.index_js_url="/cis300/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis300/css/custom.css?1723839634 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis300/io/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Input/Output</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/ title="Data Structures in C# (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis300/io/dialogs/ title="Dialogs (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable default" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><div hidden><h1 id=inputoutput>Input/Output</h1></div><h2 id=inputoutput>Input/Output</h2><p>Input and output are central concepts to computing - in order to be able
to accomplish a computational task, a program must typically process
some input and produce some output. Input and output may be presented in
a variety of ways. For example, many programs communicate with users
through a graphical user interface, or GUI. In the simplest case, the
user performs some action, such as clicking the mouse on a button, thus
signaling an <em>event</em>. A method in the program then responds to that
event by reading information that the user has typed into various
controls on the GUI, and processes that information. It may then provide
output to the user by writing results to various controls on the GUI.</p><p>Such a simple presentation of input/output (or I/O) is far too limiting,
however. For example, other mechanisms such as <em>dialogs</em> - secondary
windows designed for exchanging specific information - may be used to
avoid cluttering the main window. In other cases, the amount of data
that needs to be exchanged is too large to be transferred through a GUI.
In such cases, the program may need to read and/or write a file. This
chapter addresses these more advanced I/O mechanisms.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Input/Output</h1><article class=default><header class=headline></header><div hidden><h1 id=dialogs>Dialogs</h1></div><h2 id=dialogs>Dialogs</h2><p>Dialogs are windows displayed by a program for the purpose of exchanging specific information with the user. There are two kinds of dialogs:</p><ul><li><em>Modal</em> dialogs block all other interaction with the program until the dialog is closed.</li><li><em>Non-modal</em> dialogs allow the user to interact with the program in other ways while the dialog is open.</li></ul><p>We will examine three classes provided by Microsoft® .NET 6, each of which implements a modal dialog. .NET provides various other classes, such as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.folderbrowserdialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>FolderBrowserDialog</strong></a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.fontdialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>FontDialog</strong></a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.colordialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>ColorDialog</strong></a>, that also implement specific kinds of dialogs. We conclude by discussing how custom dialogs may be built using Visual Studio®.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Dialogs</h1><article class=default><header class=headline></header><div hidden><h1 id=messageboxes>MessageBoxes</h1></div><h2 id=message-boxes><strong>Message Box</strong>es</h2><p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox?view=windowsdesktop-6.0" rel=external target=_blank><strong>MessageBox</strong></a> class (found in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms?view=windowsdesktop-6.0" rel=external target=_blank><strong>System.Windows.Forms</strong></a> namespace) provides a simple mechanism for displaying a message and obtaining one of a few simple responses from the user. The most common usage of a <strong>MessageBox</strong> is to call one of its various <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0" rel=external target=_blank><strong>Show</strong></a> methods, each of which is <a href=/cis300/appendix/syntax/static-this/><strong>static</strong></a>. The simplest <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0#system-windows-forms-messagebox-show(system-string)" rel=external target=_blank><strong>Show</strong></a> method takes a <strong>string</strong> as its only parameter. The method then displays this <strong>string</strong> in a modal dialog containing an &ldquo;OK&rdquo; button. Thus, for example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;Hello world!&#34;</span><span class=p>);</span></span></span></code></pre></div><p>will display the following dialog:</p><img src=/cis300/io/dialogs/message-boxes/simple-message-box.png alt="A MessageBox." style=zoom:67%><p>Because the dialog is modal, it will block all other interaction with the program until the user closes it by clicking either the &ldquo;OK&rdquo; button or the &ldquo;X&rdquo; in the upper right. Furthermore, the <strong>Show</strong> method will not return until that time.</p><p>Other <strong>Show</strong> methods allow greater customization of a <strong>MessageBox</strong>. For example, one <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0#system-windows-forms-messagebox-show(system-string-system-string)" rel=external target=_blank><strong>Show</strong></a> method takes as an additional parameter a second <strong>string</strong> giving a caption for the <strong>MessageBox</strong>. Thus, the statement,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;Hello world!&#34;</span><span class=p>,</span> <span class=s>&#34;Hello&#34;</span><span class=p>);</span></span></span></code></pre></div><p>will display the following modal dialog:</p><img src=/cis300/io/dialogs/message-boxes/message-box-with-caption.png alt="A MessageBox with a caption." style=zoom:67%><p>Other <strong>Show</strong> methods allow the buttons to be customized. For example, one <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0#system-windows-forms-messagebox-show(system-string-system-string-system-windows-forms-messageboxbuttons)" rel=external target=_blank><strong>Show</strong></a> method takes, as its third parameter, an element from the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messageboxbuttons?view=windowsdesktop-6.0" rel=external target=_blank><strong>MessageBoxButtons</strong></a> <a href=/cis300/appendix/syntax/enumerations/>enumeration</a>. This <a href=/cis300/appendix/syntax/enumerations/>enumeration</a> contains the following values:</p><ul><li><strong>MessageBoxButtons.AbortRetryIgnore</strong>: Buttons labeled &ldquo;Abort&rdquo;, &ldquo;Retry&rdquo;, and &ldquo;Ignore&rdquo; are shown.</li><li><strong>MessageBoxButtons.CancelTryContinue</strong>: Buttons labeled &ldquo;Cancel&rdquo;, &ldquo;Try Again&rdquo;, and &ldquo;Continue&rdquo; are shown.</li><li><strong>MessageBoxButtons.OK</strong>: A single button labeled &ldquo;OK&rdquo; is shown.</li><li><strong>MessageBoxButtons.OKCancel</strong>: Buttons labeled &ldquo;OK&rdquo; and &ldquo;Cancel&rdquo; are shown.</li><li><strong>MessageBoxButtons.RetryCancel</strong>: Buttons labeled &ldquo;Retry&rdquo; and &ldquo;Cancel&rdquo; are shown.</li><li><strong>MessageBoxButtons.YesNo</strong>: Buttons labeled &ldquo;Yes&rdquo; and &ldquo;No&rdquo; are shown.</li><li><strong>MessageBoxButtons.YesNoCancel</strong>: Buttons labeled &ldquo;Yes&rdquo;, &ldquo;No&rdquo;, and &ldquo;Cancel&rdquo; are shown.</li></ul><p>The values above containing the word, &ldquo;Cancel&rdquo;, cause the &ldquo;X&rdquo; in the upper-right of the dialog to be enabled. Clicking this button in these cases is equivalent to clicking the &ldquo;Cancel&rdquo; button. The value, <strong>MessageBoxButtons.OK</strong>, also enables this &ldquo;X&rdquo; button, but in this case, clicking this button is equivalent to clicking the &ldquo;OK&rdquo; button. Using a <strong>Show</strong> without a <strong>MessageBoxButtons</strong> parameter also gives this behavior. For all other <strong>MessageBoxButtons</strong> values, this &ldquo;X&rdquo; button is disabled.</p><p>In order to provide appropriate functionality to each of the buttons, each <strong>Show</strong> method returns a value of type <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.dialogresult?view=windowsdesktop-6.0" rel=external target=_blank><strong>DialogResult</strong></a>. This type is another enumeration containing the following values to indicate which button the user clicked:</p><ul><li><strong>DialogResult.Abort</strong></li><li><strong>DialogResult.Cancel</strong></li><li><strong>DialogResult.Continue</strong></li><li><strong>DialogResult.Ignore</strong></li><li><strong>DialogResult.No</strong></li><li><strong>DialogResult.None</strong> (this value won&rsquo;t be returned by any of the <strong>Show</strong> methods)</li><li><strong>DialogResult.OK</strong></li><li><strong>DialogResult.Retry</strong></li><li><strong>DialogResult.TryAgain</strong></li><li><strong>DialogResult.Yes</strong></li></ul><p>Suppose, for example, that we are writing a document formatter or some other application in which the user builds a document. If the user attempts to exit the program when the document is unsaved, we would like to give an opportunity to save the document. We can accomplish this with the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>DialogResult</span> <span class=n>result</span> <span class=p>=</span> <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;The file is not saved. Really quit?&#34;</span><span class=p>,</span> <span class=s>&#34;Confirm Quit&#34;</span><span class=p>,</span> <span class=n>MessageBoxButtons</span><span class=p>.</span><span class=n>YesNo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=p>==</span> <span class=n>DialogResult</span><span class=p>.</span><span class=n>Yes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Application</span><span class=p>.</span><span class=n>Exit</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The first statement displays the following dialog:</p><img src=/cis300/io/dialogs/message-boxes/message-box-with-buttons.png alt="A MessageBox with Yes and No buttons" style=zoom:67%><p>Again, because the dialog is modal, the <strong>Show</strong> method does not return until the user closes the dialog by clicking one of the two buttons (the &ldquo;X&rdquo; in the upper right is disabled). When the user does this, the dialog closes, and the <strong>Show</strong> method returns either <strong>DialogResult.Yes</strong> or <strong>DialogResult.No</strong> to indicate which button the user clicked. If the user clicked the &ldquo;Yes&rdquo; button, then the <strong>if</strong>-statement will cause the program to terminate. Otherwise, the program will continue with whatever code follows (probably nothing more, as the program will need to await further user action).</p><p>We can also decorate a <strong>MessageBox</strong> with an icon that indicates what type of message it is. This requires another <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0#system-windows-forms-messagebox-show(system-string-system-string-system-windows-forms-messageboxbuttons-system-windows-forms-messageboxicon)" rel=external target=_blank><strong>Show</strong></a> method having a fourth parameter of type <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messageboxicon?view=windowsdesktop-6.0" rel=external target=_blank><strong>MessageBoxIcon</strong></a>. <strong>MessageBoxIcon</strong> is another enumeration. Some of its values are:</p><ul><li><strong>MessageBoxIcon.Error</strong>: <a href=#R-image-66e80ded9435a7e1d5dd836a34119eb8 class=lightbox-link><img alt="A picture of an error icon should appear here." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-error.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-66e80ded9435a7e1d5dd836a34119eb8><img alt="A picture of an error icon should appear here." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-error.png></a></li><li><strong>MessageBoxIcon.Information</strong>: <a href=#R-image-a719ebefcf8e9d2693373b336810007f class=lightbox-link><img alt="A picture of an information icon should appear here." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-information.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-a719ebefcf8e9d2693373b336810007f><img alt="A picture of an information icon should appear here." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-information.png></a></li><li><strong>MessageBoxIcon.None</strong> (no icon)</li><li><strong>MessageBoxIcon.Warning</strong>: <a href=#R-image-088b36a640a5adb9f30974b7cb80dbd5 class=lightbox-link><img alt="A picture of a warning icon should appear here." class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-exclamation.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-088b36a640a5adb9f30974b7cb80dbd5><img alt="A picture of a warning icon should appear here." class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis300/io/dialogs/message-boxes/messagebox-exclamation.png></a></li></ul><p>This enumeration contains a few other values as well, but they currently are simply duplicate values for the above icons or values that Microsoft recommends against using. To add a warning icon to the above example, we could replace the first statement with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>DialogResult</span> <span class=n>result</span> <span class=p>=</span> <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;The file is not saved. Really quit?&#34;</span><span class=p>,</span> <span class=s>&#34;Confirm Quit&#34;</span><span class=p>,</span> <span class=n>MessageBoxButtons</span><span class=p>.</span><span class=n>YesNo</span><span class=p>,</span> <span class=n>MessageBoxIcon</span><span class=p>.</span><span class=n>Warning</span><span class=p>);</span></span></span></code></pre></div><p>This will display the following dialog:</p><img src=/cis300/io/dialogs/message-boxes/message-box-with-icon.png alt="A MessageBox with an icon." style=zoom:67%><p>Notice that in the above example, the &ldquo;Yes&rdquo; button has the focus; i.e., pressing &ldquo;Enter&rdquo; has the same effect as clicking this button. It is usually desirable to have the safest response as the default - in this case, the &ldquo;No&rdquo; button. To achieve this, a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox.show?view=windowsdesktop-6.0#system-windows-forms-messagebox-show(system-string-system-string-system-windows-forms-messageboxbuttons-system-windows-forms-messageboxicon-system-windows-forms-messageboxdefaultbutton)" rel=external target=_blank><strong>Show</strong></a> method having a fifth parameter, of type <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messageboxdefaultbutton?view=windowsdesktop-6.0" rel=external target=_blank><strong>MessageBoxDefaultButton</strong></a>, is required. <strong>MessageBoxDefaultButton</strong> is another enumeration having the following values to select an appropriate button to be the default:</p><ul><li><strong>MessageBoxDefaultButton.Button1</strong></li><li><strong>MessageBoxDefaultButton.Button2</strong></li><li><strong>MessageBoxDefaultButton.Button3</strong></li><li><strong>MessageBoxDefaultButton.Button4</strong></li></ul><p>Thus, the following statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>DialogResult</span> <span class=n>result</span> <span class=p>=</span> <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;The file is not saved. Really quit?&#34;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=s>&#34;Confirm Quit&#34;</span><span class=p>,</span> <span class=n>MessageBoxButtons</span><span class=p>.</span><span class=n>YesNo</span><span class=p>,</span> <span class=n>MessageBoxIcon</span><span class=p>.</span><span class=n>Warning</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>MessageBoxDefaultButton</span><span class=p>.</span><span class=n>Button2</span><span class=p>);</span></span></span></code></pre></div><p>produces a dialog similar to the one above, but having the &ldquo;No&rdquo; button as its default.</p><p>There are other <strong>Show</strong> methods that allow additional fine-tuning; however, the ones described here cover most of the functionality. For details on other <strong>Show</strong> methods, see the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.messagebox?view=windowsdesktop-6.0" rel=external target=_blank>documentation for the <strong>MessageBox</strong> class</a>.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=file-dialogs>File Dialogs</h1></div><h2 id=file-dialogs>File Dialogs</h2><p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms?view=windowsdesktop-6.0" rel=external target=_blank><strong>System.Windows.Forms</strong></a> namespace contains two other classes that implement modal dialogs for obtaining file names from the user. These classes are <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>OpenFileDialog</strong></a>, which is designed to obtain the name of a file to read, and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.savefiledialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>SaveFileDialog</strong></a>, which is designed to obtain the name of a file to write. Because we often need to obtain the name of a file prior to doing file I/O, it is appropriate to consider these classes now.</p><p>Although these dialogs are visually separate from the window from which they are opened, it is possible (and usually desirable) to add instances of these classes to a form from <a href=/cis300/appendix/vs/design-window/>the Design window</a>. Both can be found in the &ldquo;Dialogs&rdquo; section of the Toolbox. They can be added to the form simply by double-clicking on their names. They will not appear on the form itself, but in a separate area of the Design window. Their properties can then be modified in the same way as any other control. We will discuss some of these properties a bit later in what follows.</p><p>Each of these classes has a method called <strong>ShowDialog</strong> that takes no parameters. For example, if we call the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.commondialog.showdialog?view=windowsdesktop-6.0#system-windows-forms-commondialog-showdialog" rel=external target=_blank><strong>ShowDialog</strong></a> method of an <strong>OpenFileDialog</strong>, a dialog resembling the following will be opened:</p><img src=/cis300/io/dialogs/file-dialogs/open-file-dialog.png alt="An OpenFileDialog." style=zoom:67%><p>Similarly, calling the <strong>ShowDialog</strong> method of a <strong>SaveFileDialog</strong> opens a dialog resembling the following:</p><img src=/cis300/io/dialogs/file-dialogs/save-file-dialog.png alt="A SaveFileDialog." style=zoom:67%><p>Because these dialogs are modal, the method call will not return until the user closes the dialog. It will then return a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.dialogresult?view=windowsdesktop-6.0" rel=external target=_blank><strong>DialogResult</strong></a> indicating how the user closed the form - either <strong>DialogResult.OK</strong> or <strong>DialogResult.Cancel</strong> (see <a href=/cis300/io/dialogs/message-boxes/>the previous section</a> for more information on the <strong>DialogResult</strong> type). Therefore, if <code>uxFileDialog</code> is a variable referring to a file dialog, we typically use the following code template to display it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>uxFileDialog</span><span class=p>.</span><span class=n>ShowDialog</span><span class=p>()</span> <span class=p>==</span> <span class=n>DialogResult</span><span class=p>.</span><span class=n>OK</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Process the file</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Thus, if the user selects a file, we process it; otherwise, we do nothing. In some cases, we might include an <strong>else</strong> containing code that needs to be executed if the user closes the dialog without selecting a file.</p><p>Processing a file will be discussed in the three sections that follow. However, one thing we will certainly want to do prior to processing the file is to obtain the file name that the user selected (after all, this is the reason we display a file dialog). We can obtain this file name via the dialog&rsquo;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.filename?view=windowsdesktop-6.0#system-windows-forms-filedialog-filename" rel=external target=_blank><strong>FileName</strong></a> <a href=/cis300/appendix/syntax/properties/>property</a>; for example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>fileName</span> <span class=p>=</span> <span class=n>uxFileDialog</span><span class=p>.</span><span class=n>FileName</span><span class=p>;</span></span></span></code></pre></div><p>Note that this and other properties are accessible for initialization purposes through a file dialog&rsquo;s Properties window in the Designer. This is useful for an <strong>OpenFileDialog</strong>&rsquo;s <strong>FileName</strong> property, as the default supplied by Visual Studio® is rather odd. Other properties that we might want to initialize here (in addition to <strong>(Name)</strong>, the name of the variable referring to the dialog) include:</p><ul><li><p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.title?view=windowsdesktop-6.0" rel=external target=_blank><strong>Title</strong></a>, the title of the dialog (by default, &ldquo;Open&rdquo; for an <strong>OpenFileDialog</strong> or &ldquo;Save As&rdquo; for a <strong>SaveFileDialog</strong>).</p></li><li><p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.filter?view=windowsdesktop-6.0" rel=external target=_blank><strong>Filter</strong></a>, a <em>filter string</em>, which controls what file types will be displayed. An example of a filter string is: <code>C# files|*.cs|All files|*.*</code>. A filter string consists of an even number of components separated by vertical bars ("|"). Thus, the above filter string consists of four components. These components are grouped into pairs. The first component of each pair gives the string that will be displayed in the dialog to describe what files are displayed. The second component of each pair describes a pattern of file names to be displayed when the first component of that pair is shown. Use an asterisk ("*") in a pattern to denote any sequence of characters. The &ldquo;.&rdquo; in a pattern ending in &ldquo;.*&rdquo; does not need to be matched - a file without an extension will be listed if it matches the pattern to the left of the &ldquo;.&rdquo;. Multiple patterns, separated by semicolons (";"), may be listed in one component. Thus, the above filter string describes two filters that the user may choose from. The first filter is labeled, &ldquo;C# files&rdquo;, and lists all files ending in &ldquo;.cs&rdquo;. The second filter is labeled &ldquo;All files&rdquo;, and lists all files.</p></li><li><p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.filterindex?view=windowsdesktop-6.0" rel=external target=_blank><strong>FilterIndex</strong></a> indicates which pair in the filter string is currently being used. Note that the first pair has an index of 1, not 0.</p></li><li><p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.addextension?view=windowsdesktop-6.0" rel=external target=_blank><strong>AddExtension</strong></a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog.defaultext?view=windowsdesktop-6.0" rel=external target=_blank><strong>DefaultExt</strong></a> control the dialog&rsquo;s behavior when the user types in a file name without an extension. When this happens, if a filter with a unique extension is chosen, that extension will be appended, regardless of the values of these two properties. Otherwise, if <strong>AddExtension</strong> is <strong>True</strong>, the value of <strong>DefaultExt</strong> will be appended, following a &ldquo;.&rdquo;.</p></li></ul><p>Other properties allow further customization of file dialogs. For more
details, see the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>OpenFileDialog</strong></a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.savefiledialog?view=windowsdesktop-6.0" rel=external target=_blank><strong>SaveFileDialog</strong></a> documentation.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=custom-dialogs>Custom Dialogs</h1></div><h2 id=custom-dialogs>Custom Dialogs</h2><p>While the dialogs provided by the .NET Framework are useful in a variety of applications, there are times when we need to be able to design our own special-purpose dialog to obtain specific information from the user. This section outlines how Visual Studio® can be used to build such a dialog.</p><p>Let&rsquo;s begin by considering a simple example. Suppose we are building an application that needs a dialog to obtain from the user the following pieces of information:</p><ul><li>a name;</li><li>a phone number; and</li><li>a number of siblings.</li></ul><p>In order to keep the example simple, the program will simply display this information in its main window. Thus, the main window looks like this:</p><img src=/cis300/io/dialogs/custom/custom-dialog-main.jpg alt="A GUI displaying a person's information." style=zoom:67%><p>Clicking the &ldquo;Get New Information&rdquo; button will open our custom dialog, which will look like this:</p><img src=/cis300/io/dialogs/custom/custom-dialog.jpg alt="A custom dialog." style=zoom:67%><p>After the user enters the information, clicking &ldquo;OK&rdquo; will cause the information entered to be displayed in the main window. If the user clicks &ldquo;Cancel&rdquo;, the main window will be unchanged.</p><p>After building the main form in Visual Studio&rsquo;s Design Window, we can build the dialog by creating another form. To do this, in the Solution Explorer, right-click on the project name and select &ldquo;Add->Form (Windows Forms)&mldr;&rdquo;. This will open a dialog for adding a new item, where the type of item is pre-selected to be a Windows Form. You will need to supply a name for the form. This name will serve as both a file name for a source file and the name of a class defined within this file. For example, we could choose the name, &ldquo;InformationDialog.cs&rdquo;, and the class will be named <strong>InformationDialog</strong>. Clicking the &ldquo;Add&rdquo; button will then open a new Design Window containing a form.</p><p>We can then use the Design Window to build this form as we would build any other form. In addition, the <strong>Button</strong> class has a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.button.dialogresult?view=windowsdesktop-6.0#system-windows-forms-button-dialogresult" rel=external target=_blank><strong>DialogResult</strong></a> property that governs certain behavior when buttons are used within a dialog. This property is of type <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.dialogresult?view=windowsdesktop-6.0" rel=external target=_blank><strong>DialogResult</strong></a>. Setting it to a value other than <strong>None</strong> will cause the button to do the following when clicked, provided the form is displayed as a <a href=/cis300/io/dialogs/>modal dialog</a>:</p><ul><li>Close the form.</li><li>Return the value of the <strong>DialogResult</strong> property.</li></ul><p>Thus, we should set the &ldquo;OK&rdquo; button&rsquo;s <strong>DialogResult</strong> property to <strong>OK</strong> and the &ldquo;Cancel&rdquo; button&rsquo;s <strong>DialogResult</strong> property to <strong>Cancel</strong>. Once we have done this, there is no need to define any event handlers for these buttons.</p><p>Furthermore, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.form?view=windowsdesktop-6.0" rel=external target=_blank><strong>Form</strong></a> itself has two properties that can be set to provide shortcuts for these buttons. The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.form.acceptbutton?view=windowsdesktop-6.0#system-windows-forms-form-acceptbutton" rel=external target=_blank><strong>AcceptButton</strong></a> property, of type <strong>IButtonControl</strong> (a super-type of <strong>Button</strong>), can be used to cause the &ldquo;Enter&rdquo; key to activate a button on the form, as if that button had been clicked. Thus, we could set this property to the &ldquo;OK&rdquo; button. Similarly, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.form.cancelbutton?view=windowsdesktop-6.0#system-windows-forms-form-cancelbutton" rel=external target=_blank><strong>CancelButton</strong></a> property (also of type <strong>IButtonControl</strong>) can be used to cause the &ldquo;Esc&rdquo; key to activate a button on the form. We could therefore set this property to the &ldquo;Cancel&rdquo; button.</p><p>While we don&rsquo;t need any event handlers for this dialog, we still need to provide code to allow the class for the main window to access the values provided by the user. This can be accomplished with three <strong>public</strong> <a href=/cis300/appendix/syntax/properties/>properties</a>, one for each of the three pieces of information the user can provide:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the name.  (There is already a Name property inherited from</span>
</span></span><span class=line><span class=cl><span class=cs>/// the Form class, so we will use FullName.)</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>string</span> <span class=n>FullName</span> <span class=p>=&gt;</span> <span class=n>uxName</span><span class=p>.</span><span class=n>Text</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the phone number.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>string</span> <span class=n>PhoneNumber</span> <span class=p>=&gt;</span> <span class=n>uxPhoneNumber</span><span class=p>.</span><span class=n>Text</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Gets the number of siblings.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=n>Siblings</span> <span class=p>=&gt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>uxSiblings</span><span class=p>.</span><span class=n>Value</span><span class=p>;</span></span></span></code></pre></div><p>In order for the main window to be able to display this dialog, it needs to construct an instance of it. We can add to its class definition a <strong>private</strong> field initialized to such an instance:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The dialog for obtaining information from the user.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>InformationDialog</span> <span class=n>_information</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span></span></span></code></pre></div><p>Finally, we need an event handler for the &ldquo;Get New Information&rdquo; button. This event handler needs to display the <strong>InformationDialog</strong> as a modal dialog, and if the user closes it with the &ldquo;OK&rdquo; button, to copy the information provided by the user to the main window. A <strong>Form</strong> provides two methods for displaying it as a dialog:</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.control.show?view=windowsdesktop-6.0#system-windows-forms-control-show" rel=external target=_blank><strong>Show</strong></a> displays the <strong>Form</strong> as a <a href=/cis300/io/dialogs/>non-modal dialog</a>. It takes no parameters and returns nothing.</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.form.showdialog?view=windowsdesktop-6.0#system-windows-forms-form-showdialog" rel=external target=_blank><strong>ShowDialog</strong></a> displays the <strong>Form</strong> as a <a href=/cis300/io/dialogs/>modal dialog</a>. It takes no parameters and returns a <strong>DialogResult</strong> indicating how the user closed the dialog.</li></ul><p>Thus, the event handler can display the dialog and retrieve its information much like it would do with a <a href=/cis300/io/dialogs/file-dialogs/>file dialog</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Handles a Click event on the &#34;Get New Information&#34; button.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;sender&#34;&gt;The object signaling the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;e&#34;&gt;Information on the event.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>NewClick</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>EventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_information</span><span class=p>.</span><span class=n>ShowDialog</span><span class=p>()</span> <span class=p>==</span> <span class=n>DialogResult</span><span class=p>.</span><span class=n>OK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>uxName</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_information</span><span class=p>.</span><span class=n>FullName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>uxPhoneNumber</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_information</span><span class=p>.</span><span class=n>PhoneNumber</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>uxSiblings</span><span class=p>.</span><span class=n>Text</span> <span class=p>=</span> <span class=n>_information</span><span class=p>.</span><span class=n>Siblings</span><span class=p>.</span><span class=n>ToString</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><a href=https://classroom.github.com/a/1a_tmRBS rel=external target=_blank>This git repository</a> contains the complete program described above.</p><footer class=footline></footer></article></section><article class=default><header class=headline></header><div hidden><h1 id=simple-text-file-io>Simple Text File I/O</h1></div><h2 id=simple-text-file-io>Simple Text File I/O</h2><p>Many of the I/O tools provided by .NET are found in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io?view=windowsdesktop-6.0" rel=external target=_blank><strong>System.IO</strong></a>
namespace. One
class that provides several general-purpose
<a href=/cis300/appendix/syntax/static-this/><strong>static</strong></a> methods
related to file I/O is the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file?view=net-6.0" rel=external target=_blank><strong>File</strong></a>
class. Two of the <strong>static</strong> methods provided by this class are:</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file.readalltext?view=net-6.0#system-io-file-readalltext(system-string)" rel=external target=_blank><strong>File.ReadAllText</strong></a>
and</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file.writealltext?view=net-6.0#system-io-file-writealltext(system-string-system-string)" rel=external target=_blank><strong>File.WriteAllText</strong></a></li></ul><p>The <strong>File.ReadAllText</strong> method takes a <strong>string</strong> as its only
parameter. This <strong>string</strong> should give the path to a text file. It will
then attempt to read that entire file and return its contents as a
<strong>string</strong>. For example, if <code>fileName</code> refers to a <strong>string</strong> containing
the path to a text file, then</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>contents</span> <span class=p>=</span> <span class=n>File</span><span class=p>.</span><span class=n>ReadAllText</span><span class=p>(</span><span class=n>fileName</span><span class=p>);</span></span></span></code></pre></div><p>will read that entire file and place its contents into the <strong>string</strong> to
which <code>contents</code> refers. We can then process the <strong>string</strong> <code>contents</code>
however we need to.</p><p>The <strong>File.WriteAllText</strong> method takes two parameters:</p><ul><li>a <strong>string</strong> giving the path to a file; and</li><li>a <strong>string?</strong> (i.e., a <a href=/cis300/appendix/syntax/reference-value/#nullable-types>nullable</a> <strong>string</strong> - a <strong>string</strong> that may be <strong>null</strong>) giving the text to be written.</li></ul><p>It will then attempt to write the given text as the entire contents of
the given file. If this text is <strong>null</strong>, an empty file will be written. Thus, if <code>fileName</code> refers to a <strong>string</strong> containing
the path to a file and <code>contents</code> refers to some <strong>string</strong>, then</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>File</span><span class=p>.</span><span class=n>WriteAllText</span><span class=p>(</span><span class=n>fileName</span><span class=p>,</span> <span class=n>contents</span><span class=p>);</span></span></span></code></pre></div><p>will write to that file the <strong>string</strong> to which <code>contents</code> refers.</p><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>When calling either of these methods, there are a number things that can
go wrong. For example, the file might be accessed through a network, and
access to the network might be lost before the method can complete. When
such an issue prevents the successful completion of one of these
methods, an <em>exception</em> is thrown. In <a href=/cis300/io/exceptions/>the next
section</a>, we will discuss
how to handle such exceptions.</p></div></div><p>While these methods are quite easy to use, they are not always the best
ways of doing text file I/O. One drawback is that files can be quite
large - perhaps too large to fit in memory or within a single
<strong>string</strong>. Even when it is possible to read the entire file into a
single <strong>string</strong>, it may use enough memory that performance suffers. In
the section, <a href=/cis300/io/advanced-text-file/>&ldquo;Advanced Text File
I/O&rdquo;</a>, we will
present other techniques for reading and writing text files.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=exception-handling>Exception Handling</h1></div><h2 id=exception-handling>Exception Handling</h2><p>As was mentioned in <a href=/cis300/io/simple-text-file/>the previous
section</a>, various
problems can occur when doing file I/O. Some of these problems include:</p><ul><li>Trying to write to a read-only file.</li><li>Trying to access a file that is locked by another process.</li><li>Accessing an external drive that becomes disconnected.</li></ul><p>Note that some of these issues are beyond the programmer&rsquo;s control,
while others may be tedious for the programmer to check. When one of these problems
prevents an I/O operation from completing successfully, an exception is
thrown. This section discusses how to handle such exceptions gracefully,
without terminating the program.</p><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p><a href=/cis300/io/dialogs/file-dialogs/>File dialogs</a>
can be quite helpful in avoiding some of these exceptions, as they
can reject improper selections by the user.</p></div></div><p>The mechanism used to handle exceptions is the <strong>try</strong>-<strong>catch</strong>
construct. In its simplest form, it looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>try</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Block of code that might throw an exception</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>catch</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// Code to handle the exception</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If we are concerned about exceptions thrown while doing I/O, we would
include the I/O and anything dependent on it within the <strong>try</strong>-block.
If at any point within this block an exception is thrown, control
immediately jumps to the <strong>catch</strong>-block. Here, we would place code to
handle the exception - for example, displaying a message to the user.</p><p>Suppose, for example, that we want to count the number of upper-case
letters in a file whose name is in the <strong>string</strong> referenced by
<code>fileName</code>. We could use the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>try</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>contents</span> <span class=p>=</span> <span class=n>File</span><span class=p>.</span><span class=n>ReadAllText</span><span class=p>(</span><span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>char</span> <span class=n>c</span> <span class=k>in</span> <span class=n>contents</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>IsUpper</span><span class=p>(</span><span class=n>c</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;The file contains &#34;</span> <span class=p>+</span> <span class=n>count</span> <span class=p>+</span> <span class=s>&#34; upper-case letters.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>catch</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;An exception occurred.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle note"><div class=box-label><i class="fa-fw fas fa-exclamation-circle"></i> Note</div><div class=box-content><p>See the section, &ldquo;<a href=/cis300/appendix/syntax/foreach/>The <strong>foreach</strong>
Statement</a>&rdquo; for an
explanation of <strong>foreach</strong> loops. The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.char.isupper?view=net-6.0#system-char-isupper(system-char)" rel=external target=_blank><strong>char.IsUpper</strong></a>
method returns a <strong>bool</strong> indicating whether the given <strong>char</strong> is an
upper-case letter in some alphabet.</p></div></div><p>We should always include within the <strong>try</strong>-block all of the code that
depends on what we want to read. Consider what would happen, for
example, if we tried to move the statement,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;The file contains &#34;</span> <span class=p>+</span> <span class=n>count</span> <span class=p>+</span> <span class=s>&#34; upper-case letters.&#34;</span><span class=p>);</span></span></span></code></pre></div><p>outside the <strong>try</strong>-<strong>catch</strong>. First, we would have a syntax error
because the variable <code>count</code> is declared within the <strong>try</strong>-block, and
hence cannot be used outside of it. We could fix this error by declaring
and initializing <code>count</code> prior to the <strong>try</strong> statement. The resulting
code would compile and run, but consider what happens if an exception is
thrown during the reading of the file. Control immediately jumps to the
<strong>catch</strong>-block, where the message, &ldquo;An exception occurred.&rdquo;, is
displayed. After that, assuming we have made these changes to the above
code, control continues on past the <strong>catch</strong>-block to the code to
display the results. Because the file was not successfully read, it
really doesn&rsquo;t make any sense to do this. The code given above, however,
displays a result only if the result is successfully computed;
otherwise, the exception message is displayed.</p><p>In the above example, the message, &ldquo;An exception occurred.&rdquo;, isn&rsquo;t very
helpful to the user. It gives no indication of what the problem is. In
order to be able to provide more information to the user, we need more
information regarding the nature of the exception. The way we do this is
to use some additional code on the <strong>catch</strong> statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>ex</span><span class=p>)</span></span></span></code></pre></div><p>The word <strong>Exception</strong> above is a type. Every exception in C# is a
subtype of the <strong>Exception</strong> class. In this form of the <strong>catch</strong>
statement, we can include any subtype of <strong>Exception</strong>, including
<strong>Exception</strong> itself, as the first word within the parentheses. The
second word is a new variable name. One effect of this parenthesized
part is to declare this variable to be of the given type; i.e., <code>ex</code> is
of type <strong>Exception</strong>, and may be used within the <strong>catch</strong> block.</p><p>This form of the <strong>catch</strong> statement will catch any exception that can
be treated as the given type. If we use the type, <strong>Exception</strong>, as
above, the <strong>catch</strong>-block will still catch any exception. In addition,
the variable defined within the parentheses will refer to that
exception. Thus, the parenthesized part of this statement behaves much
like a parameter list, giving us access to the exception that was
thrown. Having the exception available to examine, we can now give more
meaningful feedback to the user. One rather crude way of doing this is
to use the exception&rsquo;s
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.object.tostring?view=net-6.0#system-object-tostring" rel=external target=_blank><strong>ToString</strong></a>
method to convert it to a <strong>string</strong>
representation, which can then be displayed to the user; for example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>ex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=n>ex</span><span class=p>.</span><span class=n>ToString</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Replacing the <strong>catch</strong>-block in the earler example with this
<strong>catch</strong>-block might result in the following message:</p><img src=/cis300/io/exceptions/exception-in-messagebox.png alt="A MessageBox displaying an exception." style=zoom:67%><p>While this message is not something we would want to show to an end
user, it does provide helpful debugging information, such as the
exception thrown and the line that threw the exception.</p><div class="box notices cstyle tip"><div class=box-label><i class="fa-fw fas fa-lightbulb"></i> Tip</div><div class=box-content><p>Every object in C# has a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.object.tostring?view=net-6.0#system-object-tostring" rel=external target=_blank><strong>ToString</strong></a>
method. Hence, we can convert an instance of any type to <strong>string</strong> by
using its <strong>ToString</strong> method. This method will always return a
<strong>string</strong>, but depending on the original type, this <strong>string</strong> may or
may not be useful. For example, because there is no particularly meaningful way to
convert a <strong>Form</strong> to a <strong>string</strong>, its <strong>ToString</strong> method is not
especially useful.</p></div></div><p>A single <strong>try</strong>-block can have more than one <strong>catch</strong>-block. In such a
case, whenever an exception occurs within the <strong>try</strong>-block, control is
transferred to the first <strong>catch</strong>-block that can catch that particular
exception. For example, we can set up the following construct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>try</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Code that may throw an exception</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>DirectoryNotFoundException</span> <span class=n>ex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Code to handle a DirectoryNotFoundException</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>FileNotFoundException</span> <span class=n>ex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Code to handle a FileNotFoundException</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>Exception</span> <span class=n>ex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Code to handle any other exception</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>If we don&rsquo;t need access to the exception itself in order to handle it,
but only need to know what kind of exception it is, we can leave off the
variable name in the <strong>catch</strong> statement. For example, if we are trying
to read from a file whose name is referenced by the <strong>string</strong>
<code>fileName</code>, we might handle a <strong>FileNotFoundException</strong> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>catch</span> <span class=p>(</span><span class=n>FileNotFoundException</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MessageBox</span><span class=p>.</span><span class=n>Show</span><span class=p>(</span><span class=s>&#34;Could not find the file &#34;</span> <span class=p>+</span> <span class=n>fileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><div class="box notices cstyle warning"><div class=box-label><i class="fa-fw fas fa-exclamation-triangle"></i> Warning</div><div class=box-content><p>Don&rsquo;t use exception handling (i.e., <code>try</code>-<code>catch</code>) to handle cases that are expected to occur under normal conditions. In such cases, use an <code>if</code>-statement instead. Not only is this better style, but it is also more efficient.</p></div></div><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=advanced-text-file-io>Advanced Text File I/O</h1></div><h2 id=advanced-text-file-io>Advanced Text File I/O</h2><p>Though the <strong>File.ReadAllText</strong> and <strong>File.WriteAllText</strong> methods
provide simple mechanisms for reading and writing text files, they are
not always the best choices. For one reason, files can be very large &mdash;
too large to fit into memory, or possibly even larger than the maximum
length of a <strong>string</strong> in C# (2,147,483,647 characters). Even when it
is possible to store the entire contents of a file as a <strong>string</strong>, it
may not be desirable, as the high memory usage may degrade the overall
performance of the system.</p><p>For the purpose of handling a sequence of input or output data in more
flexible ways, .NET provides <em>streams</em>. These streams are
classes that provide uniform access to a wide variety of sequences of
input or output data, such as files, network connections, other
processes, or even blocks of memory. The
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader?view=net-6.0" rel=external target=_blank><strong>StreamReader</strong></a>
and
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter?view=net-6.0" rel=external target=_blank><strong>StreamWriter</strong></a>
classes (in the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io?view=net-6.0" rel=external target=_blank><strong>System.IO</strong></a>
namespace) provide read and write, respectively, access to text streams,
including text files.</p><p>Some of the more useful <strong>public</strong> members of the <strong>StreamReader</strong> class
are:</p><ul><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.-ctor?view=net-6.0#system-io-streamreader-ctor(system-string)" rel=external target=_blank>constructor</a>
that takes a <strong>string</strong> giving a file name as its only parameter and
constructs a <strong>StreamReader</strong> to read from that file.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.read?view=net-6.0#system-io-streamreader-read" rel=external target=_blank><strong>Read</strong></a>
method that takes no parameters. It reads the next character from
the stream and returns it as an <strong>int</strong>. If it cannot read a
character because it is already at the end of the stream, it returns
-1 (it returns an <strong>int</strong> because -1 is outside the range of
<strong>char</strong> values).</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.readline?view=net-6.0#system-io-streamreader-readline" rel=external target=_blank><strong>ReadLine</strong></a>
method that takes no parameters. It reads the next line from the
stream and returns it as a <strong>string?</strong>. If it cannot read a line
because it is already at the end of the stream, it returns <strong>null</strong>.</li><li>An
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader.endofstream?view=net-6.0#system-io-streamreader-endofstream" rel=external target=_blank><strong>EndOfStream</strong></a>
property that gets a <strong>bool</strong> indicating whether the end of the
stream has been reached.</li></ul><p>With these members, we can read a text file either a character at a time
or a line at a time until we reach the end of the file. The
<strong>StreamWriter</strong> class has similar <strong>public</strong> members:</p><ul><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter.-ctor?view=net-6.0#system-io-streamwriter-ctor(system-string)" rel=external target=_blank>constructor</a>
that takes a <strong>string</strong> giving a file name as its only parameter and
constructs a <strong>StreamWriter</strong> to write to this file. If the file
already exists, it is replaced by what is written by the
<strong>StreamWriter</strong>; otherwise, a new file is created.</li><li>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter.write?view=net-6.0#system-io-streamwriter-write(system-char)" rel=external target=_blank><strong>Write</strong></a>
method that takes a <strong>char</strong> as its only parameter. It writes this
<strong>char</strong> to the end of the stream.</li><li>Another
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter.write?view=net-6.0#system-io-streamwriter-write(system-string)" rel=external target=_blank><strong>Write</strong></a>
method that takes a <strong>string?</strong> as its only parameter. It writes this
<strong>string?</strong> to the end of the stream. If the given <strong>string?</strong> is <strong>null</strong>, nothing is written.</li><li>A
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeline?view=net-6.0#system-io-textwriter-writeline" rel=external target=_blank><strong>WriteLine</strong></a>
method that takes no parameters. It writes a line terminator to the
end of the stream (i.e., it ends the current line of text).</li><li>Another
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeline?view=net-6.0#system-io-textwriter-writeline(system-char)" rel=external target=_blank><strong>WriteLine</strong></a>
method that takes a <strong>char</strong> as its only parameter. It writes this
<strong>char</strong> to the end of the stream, then terminates the current line
of text.</li><li>Yet another
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter.writeline?view=net-6.0#system-io-streamwriter-writeline(system-string)" rel=external target=_blank><strong>WriteLine</strong></a>
method that takes a <strong>string?</strong> as its only parameter. It writes this
<strong>string?</strong> to the end of the stream, then terminates the current
line of text. If the <strong>string?</strong> is <strong>null</strong>, only the line terminator is written.</li></ul><p>Thus, with a <strong>StreamWriter</strong>, we can build a text file a character at a
time, a line at a time, or an arbitrary <strong>string</strong> at a time. In fact, a
number of other <strong>Write</strong> and <strong>WriteLine</strong> methods exist, providing the
ability to write various other types, such as <strong>int</strong> or <strong>double</strong>. In
each case, the given value is first converted to a <strong>string</strong>, then
written to the stream.</p><p>Streams are different from other classes, such as <strong>string</strong>s or arrays,
in that they are <em>unmanaged</em> resources. When a managed resource, such as
a <strong>string</strong> or an array, is no longer being used by the program, the
garbage collector will reclaim the space that it occupies so that it can
be allocated to new objects that may need to be constructed. However,
after a stream is constructed, it remains under the control of the
program until the program explicitly releases it. This has several
practical ramifications. For example, the underlying file remains
<em>locked</em>, restricting how other programs may use it. In fact, if an
output stream is not properly <em>closed</em> by the program, some of the data
written to it may not actually reach the underlying file. This is
because output streams are typically <em>buffered</em> for efficiency &mdash; when
bytes are written to the stream, they are first accumulated in an
internal array, then written as a single block when the array is full.
When the program is finished writing, it needs to make sure that this
array is <em>flushed</em> to the underlying file.</p><p>Both the <strong>StreamReader</strong> and <strong>StreamWriter</strong> classes have
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.idisposable.dispose?view=net-6.0#system-idisposable-dispose" rel=external target=_blank><strong>Dispose</strong></a>
methods to release them properly; however, because I/O typically
requires exception handling, it can be tricky to ensure that this method
is always called when the I/O is finished. Specifically, the
<strong>try-catch</strong> may be located in a method that does not have access to
the stream. In such a case, the <strong>catch</strong>-block cannot call the stream&rsquo;s
<strong>Dispose</strong> method.</p><p><span id=using></span> To handle this difficulty, C# provides a
<strong>using</strong> statement. A <strong>using</strong> statement is different from a <strong>using</strong>
directive, such as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.IO</span><span class=p>;</span></span></span></code></pre></div><p>A <strong>using</strong> statement occurs within a method definition, not at the top
of a code file. Its recommended form is as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>using</span> <span class=p>(</span> <span class=cm>/* declaration and initialization of disposable variable(s) */</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Code that uses the disposable variables(s) */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Thus, if we want to read and process a text file whose name is given by
the <strong>string</strong> variable <code>fileName</code>, we could use the following code
structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>using</span> <span class=p>(</span><span class=n>StreamReader</span> <span class=n>input</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamReader</span><span class=p>(</span><span class=n>fileName</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Code that reads and process the file accessed by the
</span></span></span><span class=line><span class=cl><span class=cm>     * StreamReader input */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This declares the variable <code>input</code> to be of type <strong>StreamReader</strong> and
initializes it to a new <strong>StreamReader</strong> to read the given file. This
variable is only visible with the braces; furthermore, it is read-only &mdash;
its value cannot be changed to refer to a different <strong>StreamReader</strong>.
The <strong>using</strong> statement then ensures that whenever control exits the
code within the braces, <code>input</code>&rsquo;s <strong>Dispose</strong> method is called.</p><p>More than one variable of the same type may be declared and initialized
within the parentheses of a <strong>using</strong> statement; for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>using</span> <span class=p>(</span><span class=n>StreamReader</span> <span class=n>input1</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamReader</span><span class=p>(</span><span class=n>fileName1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>input2</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamReader</span><span class=p>(</span><span class=n>fileName2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Code that reads from input1 and input2 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The type of variable(s) declared must be a subtype of
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0" rel=external target=_blank><strong>IDisposable</strong></a>.
This ensures that the variables each have a <strong>Dispose</strong> method.</p><p>As a complete example of the use of a <strong>StreamReader</strong> and a
<strong>StreamWriter</strong>, together with a <strong>using</strong> statement for each, suppose
we want to write a method that takes as its parameters two <strong>string</strong>s
giving the name of an input file and the name of an output file. The
method is to reproduce the input file as the output file, but with each
line prefixed by a line number and a tab. We will start numbering lines
with 1. The following method accomplishes this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Copies the file at inFileName to outFileName with each line</span>
</span></span><span class=line><span class=cl><span class=cs>/// prefixed by its line number followed by a tab.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;inFileName&#34;&gt;The path name of the input file.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;param name=&#34;outFileName&#34;&gt;The path name of the output file.&lt;/param&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>AddLineNumbers</span><span class=p>(</span><span class=kt>string</span> <span class=n>inFileName</span><span class=p>,</span> <span class=kt>string</span> <span class=n>outFileName</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=p>(</span><span class=n>StreamReader</span> <span class=n>input</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamReader</span><span class=p>(</span><span class=n>inFileName</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=p>(</span><span class=n>StreamWriter</span> <span class=n>output</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamWriter</span><span class=p>(</span><span class=n>outFileName</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>count</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(!</span><span class=n>input</span><span class=p>.</span><span class=n>EndOfStream</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Because input is not at the end of the stream, its ReadLine</span>
</span></span><span class=line><span class=cl>                <span class=c1>// method won&#39;t return null.</span>
</span></span><span class=line><span class=cl>                <span class=kt>string</span> <span class=n>line</span> <span class=p>=</span> <span class=n>input</span><span class=p>.</span><span class=n>ReadLine</span><span class=p>()!;</span>
</span></span><span class=line><span class=cl>                <span class=n>count</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>                <span class=n>output</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>output</span><span class=p>.</span><span class=n>Write</span><span class=p>(</span><span class=sc>&#39;\t&#39;</span><span class=p>);</span>   <span class=c1>// The tab character</span>
</span></span><span class=line><span class=cl>                <span class=n>output</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>line</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>As noted above, a <strong>StreamReader</strong>&rsquo;s <strong>ReadLine</strong> method has a return type of <strong>string?</strong> because it will return <strong>null</strong> if the end of the stream has already been reached. Furthermore, the compiler is unable to determine that the loop condition will prevent the call to <strong>ReadLine</strong> from returning <strong>null</strong>. Thus, in order to suppress the compiler warning when the returned <strong>string?</strong> is assigned to a <strong>string</strong>, we include a <code>!</code> following the call to <strong>ReadLine</strong>, and document the reason with a comment above this line.</p><p>We can call the above method within a <strong>try</strong>-block to handle any
exceptions that may be thrown during the I/O. The <strong>catch</strong>-block will
not have access to either <code>input</code> or <code>output</code>, but it doesn&rsquo;t need it.
If an exception is thrown during the I/O, the two <strong>using</strong> statements
will ensure that the <strong>Dispose</strong> methods of both the <strong>StreamReader</strong>
and the <strong>StreamWriter</strong> are called.</p><footer class=footline></footer></article><article class=default><header class=headline></header><div hidden><h1 id=other-file-io>Other File I/O</h1></div><h2 id=other-file-io>Other File I/O</h2><p>Not all files are plain text files &mdash; often we need to read and/or write
binary data. .NET provides the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.filestream?view=net-6.0" rel=external target=_blank><strong>FileStream</strong></a>
class for this purpose.</p><p>The <strong>FileStream</strong> class provides constructors for creating a
<strong>FileStream</strong> for reading, writing, or both. These constructors can be
used to specify how the file is to be opened or created, the type of
access to be allowed (i.e., reading/writing), and how the file is to be
locked. In most cases, however, a simpler way to construct an
appropriate <strong>FileStream</strong> is to use one of the following <strong>static</strong>
methods provided by the the
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file?view=net-6.0" rel=external target=_blank><strong>File</strong></a>
class:</p><ul><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file.openread?view=net-6.0#system-io-file-openread(system-string)" rel=external target=_blank><strong>File.OpenRead(string
fn)</strong></a>:
returns a <strong>FileStream</strong> for reading the file with the given path
name. A <strong>FileNotFoundException</strong> is thrown if the file does not
exist.</li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.file.openwrite?view=net-6.0#system-io-file-openwrite(system-string)" rel=external target=_blank><strong>File.OpenWrite(string
fn)</strong></a>:
returns a <strong>FileStream</strong> for writing to the file with the given path
name. If the file exists, it will be replaced; otherwise, it will be
created.</li></ul><p>Two of the most commonly-used methods of a <strong>FileStream</strong> are
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.filestream.writebyte?view=net-6.0#system-io-filestream-writebyte(system-byte)" rel=external target=_blank><strong>ReadByte</strong></a>
and
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.filestream.writebyte?view=net-6.0#system-io-filestream-writebyte(system-byte)" rel=external target=_blank><strong>WriteByte</strong></a>.
The <strong>ReadByte</strong> method takes no parameters and returns an <strong>int</strong>. If
there is at least one byte available to read, the next one is read and
its value (a nonnegative integer less than 256) is returned; otherwise,
the value returned is -1 (this is the only way to detect when the end of
the stream has been reached). The <strong>WriteByte</strong> method takes a <strong>byte</strong>
as its only parameter and writes it to the file. It returns nothing.</p><p>Because a <strong>FileStream</strong> has no <strong>EndOfStream</strong> property, we must code a
loop to read to the end of the stream somewhat differently from what we
have seen before. We can take advantage of the fact that in C#, an
assignment statement can be used within an expression. When this is
done, the value of the assignment statement is the value that it
assigns. Thus, if <code>input</code> is a <strong>FileStream</strong> opened for input, we can
set up a loop to read a byte at a time to the end of the stream as
follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=kt>int</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>((</span><span class=n>k</span> <span class=p>=</span> <span class=n>input</span><span class=p>.</span><span class=n>ReadByte</span><span class=p>())</span> <span class=p>!=</span> <span class=p>-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>byte</span> <span class=n>b</span> <span class=p>=</span> <span class=p>(</span><span class=kt>byte</span><span class=p>)</span><span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span> <span class=p>.</span> <span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>In the above code, the <strong>ReadByte</strong> method reads a byte from the file as
long as there is one to read, and assigns it to the <strong>int</strong> variable
<code>k</code>. If there is no byte to read, it assigns -1 to <code>k</code>. In either case,
the value of the assignment statement is the value assigned to <code>k</code>.
Thus, if the <strong>ReadByte</strong> method is at the end of the stream, it returns
-1, which is assigned to <code>k</code>, and the loop terminates. Otherwise, the
loop iterates, assigning <code>k</code> to <code>b</code> as a <strong>byte</strong>. The remainder of the
iteration can then use the <strong>byte</strong> read, which is in <code>b</code>.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis300/commit/922f538e5bb242ebedcf7260f2a5ef759abe56f5>May 22, 2023</a></p></div></div><script src=/cis300/js/clipboard.min.js?1723839634 defer></script><script src=/cis300/js/perfect-scrollbar.min.js?1723839634 defer></script><script src=/cis300/js/theme.js?1723839634 defer></script></body></html>