<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>hw5</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

html {
    font-size: 16px;
}

body {
    font-family: "Open Sans","Clear Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    padding-bottom: .3em;
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
   padding-bottom: .3em;
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}
h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border-top: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table tr th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table tr td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table tr th:first-child,
table tr td:first-child {
    margin-top: 0;
}
table tr th:last-child,
table tr td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

.html-for-mac .context-menu {
    --item-hover-bg-color: #E6F0FE;
}

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p><img src="clip_image002.jpg" referrerpolicy="no-referrer" alt="Related image"></p><h1><a name="user-requirements" class="md-header-anchor"></a><span>User Requirements</span></h1><p><span>For this assignment, you will be creating a video game classic: Snake.  Snake was originally a cellphone game launched on the Nokia in the late ‘90s.  In its simplest form, you control a snake that can go up, left, right, or down.  The goal is to eat as much snake food as you can. When the snake eats a piece of food, the snake body grows.  This awards you points.  If the snake runs into the edge of the screen or a section of itself, the game is over.</span></p><p><span>This project takes a simple approach to creating a game in C# that can perform background tasks (the game logic) and update the UI (visuals and controls of the game) at the same time. To do this in C#, we will use async/await and Tasks to prevent the GUI from being frozen.  To learn more about these topics, please watch/read the following (some of these are  for reference, some are for learning):</span></p><ol start='' ><li><a href='https://channel9.msdn.com/Series/Three-Essential-Tips-for-Async/Three-Essential-Tips-For-Async-Introduction'><span>Microsoft video on understanding basics of async </span></a></li><li><a href='https://www.youtube.com/watch?v=C5VhaxQWcpE'><span>Example tutorial on async and await </span></a><span>                   </span></li><li><a href='https://msdn.microsoft.com/en-us/magazine/jj991977.aspx'><span>Best practices using async/await </span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming'><span>Microsoft documentation examples on using Tasks</span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/'><span>Microsoft documentation examples on async </span></a></li><li><a href='http://nikolar.com/2013/09/02/asynchronously-deadlocked-or-do-not-wrap-async-methods-into-sync-wrappers-httpclient-getasync-not-returning/'><span>Gotchyas on using async/await with UIs</span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitany?view=netframework-4.7.2'><span>WaitAny documentation </span></a></li><li><a href='https://www.dotnetperls.com/async'><span>Aditional tutorial on async</span></a></li></ol><h2><a name="the-perfect-snake-ai" class="md-header-anchor"></a><span>The Perfect Snake AI</span></h2><p><span>This project requires and option to let an AI play the game.  AI for Snake is a solved problem.  There are many different approaches, some seem seemingly more random than others, but their exists solutions that allow an AI player that never loses a game.  One solution to this problem is generating a </span><a href='https://en.wikipedia.org/wiki/Hamiltonian_path'><span>Hamiltonian path</span></a><span>.  A Hamiltonian path is a path that visits all vertices in a graph exactly once.  This does not require all edges to be traversed though.  We can generate a Hamiltonian path for Snake if we split our game space out into an </span><strong><span>n x n</span></strong><span> grid, where each square in the grid represents a graph node that can traverse to each adjacent node (excludes diagonals).  </span></p><p><span>Verifying that a Hamiltonian path exists in a graph is </span><a href='https://en.wikipedia.org/wiki/NP-completeness'><span>NP-complete</span></a><span>, so any algorithm to solve such a problem would run in </span><span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.618ex" height="2.577ex" viewBox="0 -806.1 2419 1109.7" role="img" focusable="false" style="vertical-align: -0.705ex;"><defs><path stroke-width="0" id="E26-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path stroke-width="0" id="E26-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path stroke-width="0" id="E26-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path stroke-width="0" id="E26-MJMAIN-21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path><path stroke-width="0" id="E26-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E26-MJMATHI-4F" x="0" y="0"></use><use xlink:href="#E26-MJMAIN-28" x="763" y="0"></use><use xlink:href="#E26-MJMATHI-6E" x="1152" y="0"></use><use xlink:href="#E26-MJMAIN-21" x="1752" y="0"></use><use xlink:href="#E26-MJMAIN-29" x="2030" y="0"></use></g></svg></span><script type="math/tex">O(n!)</script><span>.  In terms of running time, that does not bode well for an AI player which should be able to execute moves in a game in real time.  Likewise, not all Hamiltonian paths will result to a guaranteed win in Snake (some end up causing the snake to trap itself).  However, if we find a Hamiltonian path from the head of the snake to it&#39;s tail, we can be sure the snake will never trap itself.  And if the AI just follows this path until it wins (the snake fills the entire screen), we only need to calculate this path at the beginning of the game.  This works on the assumption that the game&#39;s grid is of even width and height, otherwise we cannot always assume there is a Hamiltonian path.</span></p><h3><a name="generating-a-hamiltonian-path" class="md-header-anchor"></a><span>Generating a Hamiltonian Path</span></h3><p><span>The path for the AI to follow can be found by using a technique called </span><a href='https://en.wikipedia.org/wiki/Simulated_annealing'><span>simulated annealing</span></a><span>.  This is a technique for finding the global maximum of a function.  To apply this to our path finding problem, we can start by utilizing the shortest path from the head of the snake to its tail (cannot traverse through itself to get to the tail). This path will act as our function. To find the maximum path from our shortest path, we can slowly extend each portion of the path (starting at the head) in opposing directions (if the path is going up or down, try to extend the path left or right and vice versa).  If the path is able to be extended in a direction, the opposite of that direction is also inserted into the path (two positions ahead) in order to bring it it back in.  If the path cannot be extended any farther, move on to the next position in the path. This continues until no part of the path can be extended. Then, if we just connect the path to the rest of the snake, we have a complete Hamiltonian path that starts at the head and ends at the tail.  Following this path will allow the Snake AI to constantly chase its tail, preventing it from ever being trapped.  Below is an example of this process on a 4x4 game. </span></p><p><img src="hamiltonian.png" referrerpolicy="no-referrer" alt="hamiltonian"></p><ol><li><span>The shortest path is found from (h)ead to (t)ail. </span></li><li><span>Since the path from H was going left, we try (and do) extend the path up (see that the opposite direction is inserted in the path two positions ahead).  Notice that the original path (blue) is essentially a list of directions, starting at H and ending at T.  When the path is extended (red), the directions are </span><strong><em><span>inserted</span></em></strong><span>, so the original path remain but just in a different order.</span></li><li><span>The current direction from H is up, so we can extend the path to the right.</span></li><li><span>In this step, we progressed all the way to node (1,0) </span><span>*</span><em><span>note that the top row of numbers is x and the left is y</span></em><span>*</span><span> because the path at H cannot be extended, so we follow the path until we come to a node where the path can be extended (1,0). The path at this location is extended left.</span></li><li><span>The algorithm progresses to node (1,2) where the path can be extended down.</span></li><li><span>The path gets extended again at (1,2), but this time, left.</span></li><li><span>The algorithm progresses to (2,3) where the path gets extended right.</span></li><li><span>In this step, the main algorithm finishes before the last direction is added to the path.  The main algorithm ends here since we have reached the end of the path (in blue), but in order for it to be a true Hamiltonian path, we need to include the rest of the snake in the path so we traverse the snake from the tail to add the remaining direction to the path. </span></li></ol><p><span>The resulting path is traversed in order of number continuously by the AI in order to solve the game.  The ordering can be seen lain on top of the grid below:</span></p><p><img src="image-20201119230205448.png" referrerpolicy="no-referrer" alt="image-20201119230205448"></p><p><span>An example of the AI working can be found below (url: </span><a href='https://www.youtube.com/watch?v=yXLp50i8Olk' target='_blank' class='url'>https://www.youtube.com/watch?v=yXLp50i8Olk</a><span>):</span></p><iframe width="375" height="375" src="https://www.youtube.com/embed/yXLp50i8Olk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h1><a name="starting-the-assignment" class="md-header-anchor"></a><span>Starting the Assignment</span></h1><p><span>Create a GitHub repository using </span><a href='https://classroom.github.com/a/Ejrbwlrr'><strong><span>this URL</span></strong></a><span>. This repository will contain a skeleton Windows Forms application.</span></p><h1><a name="user-interface" class="md-header-anchor"></a><span>User Interface</span></h1><p><img src="clip_image004.jpg" referrerpolicy="no-referrer" alt="img"></p><p><span>The user interface is fairly simple.  At the top, there is a </span><strong><span>MenuStrip</span></strong><span> that has one menu strip item, File, that has </span><strong><span>New Game</span></strong><span> as a sub-menu item that has a sub-menu with easy, normal, and hard as options.  Clicking one of these sub-options will start a new game of that difficulty.  When the program is ran initially, or when a new game option is clicked, the game is reset then started automatically (the snake starts moving on its own).  If the CheckBox for the AI player is checked when a new game is created, then the AI player will take control of the snake.  During this mode, the human should not be able to control the snake.</span></p><p><span>In the top right hand corner, there are two labels that will be used to keep track of the player’s score.  The </span><strong><span>Label</span></strong><span> in the top right-hand corner is used for the score itself.  The </span><strong><span>AutoSize</span></strong><span> property should be set to false (this will let you size it yourself).  The text </span><strong><span>size</span></strong><span> should be adjusted for both of the Labels and the font should be </span><strong><span>bolded</span></strong><span>.   Both of these labels should be </span><strong><span>anchored</span></strong><span> to the top and the right.</span></p><p><span>The main part of the form (the black area) is a </span><strong><span>PictureBox</span></strong><span>.  You do not need to worry about sizing this control as it will be done programmatically.  Lastly, for the </span><strong><span>Form</span></strong><span> control AND the </span><strong><span>CheckBox</span></strong><span> control, be sure to set the </span><strong><span>KeyPreview</span></strong><span> property to </span><strong><span>True</span></strong><span>.  This is very important.  Without this, the arrow keys will not register the correct event handlers.  This lets the user control the snake with the arrow keys regardless of which control has focus (clicked on, etc.).  If this is not set, when the Score is updated, the controls for the snake will not register properly.</span></p><h1><a name="software-architecture" class="md-header-anchor"></a><span>Software Architecture</span></h1><p><img src="snake-uml.png" referrerpolicy="no-referrer" alt="snake-uml"></p><p><span>You do not need to use the same names as shown in the class diagram, as long as you follow the </span><a href='https://cis300.cs.ksu.edu/appendix/style/naming/'><span>naming conventions</span></a><span> for CIS 300. You may add any helper methods that you feel improve the code.  </span></p><h1><a name="coding-requirements" class="md-header-anchor"></a><span>Coding Requirements</span></h1><p><span>The below are the classes, methods, and functionality for the Snake game.  There are three enumerations that you can see above.  These do not have to go in any particular file, but they should </span><strong><span>not</span></strong><span> be apart of any class.  They just need to belong to the namespace.</span></p><h2><a name="the-gamenode-class" class="md-header-anchor"></a><span>The GameNode Class</span></h2><p><span>This class is a simple object that serves as a node in the graph that represents the game board.  It does not contain any functionality beyond the noted properties and constructor.</span></p><h3><a name="properties" class="md-header-anchor"></a><span>Properties</span></h3><p><em><span>Note that each of the following properties have a default getter and setter.</span></em></p><ul><li><p><code>public int Y</code></p><ul><li><span>The y-coordinate for this node</span></li></ul></li><li><p><code>public int X</code></p><ul><li><span>The x-coordinate for this node</span></li></ul></li><li><p><code>public GridData Data</code></p><ul><li><span>The information stored at this node.  This is an enumeration which makes it cheap and efficient for storing game “objects” at locations.  Each node is only allowed to have a single piece of the game at any time.  For example, a node cannot have the snake and snake food together.  </span></li></ul></li><li><p><code>public GameNode SnakeEdge</code></p><ul><li><span>This edge represents a connection in the graph to another GameNode.  In the  game, it is used only to connect the snake pieces on the GameBoard leading in the direction from the tail to the head.</span></li></ul></li></ul><h3><a name="methods" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public GameNode(int x, int y)</code></p><ul><li><span>This is the default constructor that sets the x-y coordinate properties above.</span></li></ul></li><li><p><span>You may also override the ToString method to allow for easier debugging (show the x,y coordinate with the data stored).</span></p></li></ul><h2><a name="the-gameboard-class" class="md-header-anchor"></a><span>The GameBoard Class</span></h2><p><span>This class contains the majority of the game’s logic.  It keeps information about the game board and is responsible for making the snake grow or move into a new place on the board.  The game board is setup as a fully connected graph using an adjacency matrix of </span><strong><span>GameNode</span></strong><span>s.  This is what will be used to know the location of game objects like the snake and the food.  In addition to this, nodes that contain the snake will also have additional graph information to track the direction of the snake.  This is an added efficiency to make constructing the snake faster than scanning the entire grid every time for each snake section.  Note that the UI does not really interact with the </span><strong><span>GameBoard</span></strong><span> class directly.  The Game class, discussed next, will be the middle ground communication.</span></p><h3><a name="properties-n69" class="md-header-anchor"></a><span>Properties</span></h3><ul><li><p><code>public GameNode Food</code></p><ul><li><span>This is a property that has a public getter and a public setter.  This will return the game node that contains the food.  This is intended to make the drawing of the food easier on the UI.</span></li></ul></li><li><p><code>public GameNode[,] Grid</code></p><ul><li><span>This is a property that has a public getter and a private setter. This is the adjacency matrix for storing the graph of the game board.</span></li></ul></li><li><p><code>public GameNode Head</code></p><ul><li><span>This is a property that has a public getter and a public setter.  A reference to where the head of the snake is currently at.</span></li></ul></li><li><p><code>public GameNode Tail</code></p><ul><li><span>This is a property that has a public getter and a public setter.  A reference to where the tail of the snake is currently at.</span></li></ul></li><li><p><code>public int SnakeSize</code></p><ul><li><span>This is a property that has a public getter and private setter.  It keeps track of how big the snake is at any given time.</span></li></ul></li></ul><h3><a name="fields" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _size</code></p><ul><li><span>This field keeps track of the dimension (n) of the board.</span></li></ul></li><li><p><code>private Direction[] _aiDirection</code></p><ul><li><span>This array contains all four possible directions to make it easier to find adjacent nodes to search when finding the shortest path in the board.  My order is up, left, right, down...but this should not impact functionality, just the path order your snake AI takes.</span></li></ul></li><li><p><code>private Direction[] _lr</code><span> and </span><code>private Direction[] _ud</code></p><ul><li><span>These arrays contain the directions left, right and up down respectively.  These are used for determining which directions the AI can use to extend the path when calculating the Hamiltonian path.</span></li></ul></li></ul><h3><a name="methods-n91" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public GameBoard(int size)</code></p><ul><li><span>This is a constructor that initializes the game board to a new board of the given size.  Each node should be initialized with its x-y location, but nothing else.  Once the board is made, then the head and tail should be placed in its center.  This will be slightly off-center if the board is of even size.  Be sure to set the data of this node to be the snake head and store a reference to the node in the head and tail fields.  Then, add the food to the board by using the method below.</span></li></ul></li><li><p><code>public void AddFood()</code></p><ul><li><span>This function randomly places the snake food on the board. This is done by setting data of a random node to be SnakeFood.  The food cannot be placed in a node unless it is empty.  Be sure to store the reference to the node you place the food in the </span><strong><span>Food</span></strong><span> property above.</span></li></ul></li><li><p><code>public GameNode GetNextNode(Direction dir)</code></p><ul><li><span>This is a helper method that will return the node that the snake would be going to if it was headed in the given direction.  The function should return null if the snake would move out of the board.</span></li></ul></li><li><p><code>public SnakeStatus MoveSnake(Direction dir)</code></p><ul><li><p><span>This is the main logic on how the snake moves through the game board.  First, get the next node using the method above.  If the node is null, return that a collision happened (</span><code>SnakeStatus.Collision</code><span>).  If the next node is the node immediately before the snake head, then the user pressed an invalid direction.  Return the InvalidDirection snake status.  If the next node has part of the snake body, return that there was a collision.  </span></p><p><span>If none of the above are true, then the snake can move forward into the next node.  To do this, make the next node to be the snake head, the current head to be part of the snake body, and link the edge of the current head to the next node.  If the data in the node where the snake is moving to contains the food, add a new piece of food to the board and return that the snake is eating. Note that if the game is won (the snake fills the entire grid), then no food should be added and a Win status should be returned.</span></p><p><span>If the snake is not eating and it did not collide with something, then we need to determine if we need to cut the snake’s tail.  If we do not do this, the snake will continuously grow even if it is not eating.  If the head of the snake is not the tail of the snake, set the tail node data to be empty.  Then, the edge of the tail should be set to null and the value of the edge should become the new tail.  This process can be done with a temporary variable.  In the method above, no new game nodes should be created.  </span></p></li></ul></li><li><p><code>public List&lt;GameNode&gt; GetSnakePath()</code></p><ul><li><span>This method returns a list of game nodes that contain the snake starting from the tail.</span></li></ul></li><li><p><code>private List&lt;Direction&gt; BuildPath(Dictionary&lt;GameNode, (GameNode, Direction)&gt; path, GameNode dest)</code></p><ul><li><span>This method reverses the given path from the destination to the head of the snake.  The resulting list is a series of directions that leads the head of the snake to </span><code>dest</code><span>.  This method works similarly to the </span><strong><span>AddPath</span></strong><span> method in </span><a href='https://classroom.github.com/a/dT-eocng'><span>Lab 33</span></a><span>.  The given path dictionary&#39;s keys represent the destination and the corresponding value is a tuple which has the source node and the direction required to go to get to the destination.</span></li></ul></li><li><p><code>public List&lt;Direction&gt; FindShortestAiPath(GameNode dest)</code></p><ul><li><span>This method calculates the shortest path from the head of the snake to the destination.  This method works similarly to the shortest path algorithm in </span><a href='https://classroom.github.com/a/tRS1oXkz'><span>Lab34</span></a><span>.  The path should be kept in a dictionary as described in the previous method.  The queue should contain a 3-value tuple which contains the source node, destination node, and the direction required to get from the source to the destination.  This tuple represents an edge between two adjacent nodes. A helper method is recommended here to find the adjacent edges from a given source node.  Note that only valid adjacent nodes should be included as a valid edge (i.e. parts of the snake should not be included, unless the destination of the shortest path is the tail, then the tail can be included).  The snake is not allowed to path back over itself to reach its destination. Once the destination is found, rebuild and return the path using the </span><code>BuildPath</code><span> method.</span></li></ul></li><li><p><code>public List&lt;Direction&gt; FindLongestAiPath()</code></p><ul><li><span>This method is used to find the Hamiltonian path as described in the &quot;The Perfect Snake AI&quot; sections.  Utilize the </span><code>FindShortestAiPath</code><span> to find a path to the tail of the snake.  Then use the process previously described to extend this path.  You will need to keep track of which nodes you have visited (be sure to mark all in the shortest path to be visited before you start extending it). You will need to keep track of which node you are currently at and which direction in the path you are currently at (and which node that leads to).  If the current direction you are at in the path is up or down, try to extend the path left or right (up or down if the direction in the path is left or right).  If you can extend the current node and the next node (the node the current direction leads to) in either of the extension directions, then insert the direction and its opposite into the path (at the current location in the path and current location + 2 respectively).  Note that you cannot extend to a location that has already been visited.   If the path cannot be extended at its current location, advance to the next node, otherwise, keep trying to extend the current node. Once you have reached the end of the path (this should  be the tail), link the path to the rest of the snake and return the path</span></li></ul></li></ul><h2><a name="the-game-class" class="md-header-anchor"></a><span>The Game Class</span></h2><p><span>The game class is the communication between the UI and the game logic.  It will maintain the status of the game and manage moving the snake based off the key presses given by the UI.  This class implements the </span><strong><span>INotifyPropertyChanged</span></strong><span> interface.  </span></p><h3><a name="fields-n120" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _score</code></p><ul><li><span>Keeps track of how many points the player has.</span></li></ul></li><li><p><code>private int _delay</code></p><ul><li><span>Indicates how many milliseconds the game should wait before ticks (controls how fast the snake moves)</span></li></ul></li><li><p><code>private bool _isAI</code></p><ul><li><span>Indicates if the game should be controlled by the AI</span></li></ul></li><li><p><code>private int _pathIdx</code></p><ul><li><span>This keeps track of the position (index) in the AI is current at in the AI&#39;s path.</span></li></ul></li><li><p><code>private List&lt;Direction&gt; _aiPath</code></p><ul><li><span>This will store the AI path, if the AI is enabled.</span></li></ul></li></ul><h3><a name="properties-n127" class="md-header-anchor"></a><span>Properties</span></h3><ul><li><p><code>public bool Play</code></p><ul><li><span>Stores whether or not the game is currently being played (i.e. the game is not over)</span></li></ul></li><li><p><code>public int Score</code></p><ul><li><p><span>This is a public property that has a getter that returns the private score field.  The setter is a bit unique.  This is the first step in implementing data binding.</span></p><p><img src="clip_image008.png" referrerpolicy="no-referrer" alt="Basic data binding diagram"></p><p><span>Data binding works by linking a data source (the Binding Source) of some kind to another object (the Binding Target).  This is done in C# between a data source and a UI control.  In data binding, when the source property changes (could also be set in reverse), the target is notified of this change.  This is extremely useful in the sense that we do not have to update a UI control manually.  This will take care of it for us.  In the setter, check if the private score field is different the than value sent to the property.  If it is, set the private score field to the value and then call </span><strong><span>OnPropertyChanged</span></strong><span>, passing in the name of the property that changed as a string (“Score”).  This is an event (see below for definition) that will trigger the data binding process. </span></p></li></ul></li><li><p><code>public GameBoard Board</code></p><ul><li><span>The reference to the game board object that contains the logic for moving the snake on the graph. The property has a default getter and a default private setter.</span></li></ul></li><li><p><code>public int Size</code></p><ul><li><span>The size of the game to create. The property has a default getter and a default private setter.</span></li></ul></li><li><p><code>public Direction LastDirection</code></p><ul><li><span>The last direction that the snake successfully moved. The property has a default getter and a default setter.</span></li></ul></li><li><p><code>public Direction KeyPress</code></p><ul><li><span>The most recent direction reported by the UI. The property has a default getter and a default private setter.</span></li></ul></li><li><p><code>public SnakeStatus Status</code></p><ul><li><span>The current status of the snake. The property has a default getter and a default private setter.</span></li></ul></li><li><p><code>public event PropertyChangedEventHandler PropertyChanged</code></p><ul><li><span>This is needed as part of implementing the above-mentioned interface.  Nothing needs to be added or changed here.</span></li></ul></li></ul><h3><a name="methods-n171" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public Game(int size)</code></p><ul><li><span>The constructor for the Game class.  Sets the size, initializes the game board, score to 2, and Play to true. Once the board is initialized, the snake should be moved up one (use </span><code>MoveSnake</code><span>).  The constructor should also set the </span><code>_delay</code><span> based off the given speed.  If the AI is enabled, set </span><code>_aiPath</code><span> to the result of the </span><code>FindAiPath</code><span> method from the GameBoard class and set the </span><code>_delay</code><span> to be a 10th of its size (this will speed up the AI, but give the human player reasonable reaction time).</span></li></ul></li><li><p><code>public async Task StartMoving(IProgress&lt;SnakeStatus&gt; progress, CancellationToken cancelToken)</code></p><ul><li><span>This is an asynchronous method that acts as a game clock.  The snake in the game is always moving, the user (or AI) only controls the direction.  Therefore, every game “tick” we need to move the snake.  Since this is asynchronous, it will not block the UI completely.  This function contains a loop that continues until Play is false or a cancelation request has been made from the UI (</span><code>cancelToken.IsCancellationRequested</code><span>).  Inside the loop, you will tell the game board (</span><strong><span>Grid</span></strong><span>) to move the snake in the direction of </span><strong><span>KeyPress</span></strong><span>.  Then you will report the new status back to the UI using the progress interface passed to this method.  This cane be done using </span><code>progress.Report(Status)</code><span>  If the snake collided with something, play should be set to false.  If the snake is still moving, the last direction should be set to the key press.  If the snake is eating, increase the score (be sure to use the property here so it triggers the data binding events).  If the snake reported an invalid direction, try to move the snake in the last direction (be sure to check for collisions and eating here as well.  If a win status is reported, still increase the score by 1, but set Play to false.  Lastly, at the end of the loop, use the following code to control how often a tick occurs:  </span><code>await Task.Delay(_delay)</code><span>.</span></li><li><span>To add the AI control, add a check at the beginning of the loop to see if the AI is enabled, if so, override the </span><code>KeyPress</code><span> value with the direction stored at the current position in the path.  If you hit the end of the path, reset the position to 0. </span></li></ul></li><li><p><code>private void OnPropertyChanged(string propertyName)</code></p><ul><li><p><span>This is what will call the property changed event with the appropriate property.  This method should contain only the following code:</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 36px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PropertyChanged</span><span class="cm-operator">?</span>.<span class="cm-variable">Invoke</span>(<span class="cm-keyword">this</span>, <span class="cm-keyword">new</span> <span class="cm-variable">PropertyChangedEventArgs</span>(<span class="cm-variable">propertyName</span>));</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;"></div><div class="CodeMirror-gutters" style="height: 46px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre><p><span>This is checking if the </span><code>PropertyChanged</code><span> is null.  If not, it will call the property changed event for the given property in context of “this”.</span></p></li></ul></li><li><p><code>public List&lt;GameNode&gt; GetSnakePath()</code></p><ul><li><span>This method returns the result of the GetSnakePath method contained in the GameBoard class.</span></li></ul></li><li><p><code>public GameNode GetFood()</code></p><ul><li><span>Returns the Food property of the game board.  If the Food property doesn&#39;t actually contain food, return null (this happens when the game is won and the snake fills the entire board).</span></li></ul></li><li><p><code>public void MoveUp()</code></p><ul><li><span>Sets the key press field to be the up direction.</span></li></ul></li><li><p><code>public void MoveDown()</code></p><ul><li><span>Sets the key press field to be the down direction.</span></li></ul></li><li><p><code>public void MoveLeft()</code></p><ul><li><span>Sets the key press field to be the left direction.</span></li></ul></li><li><p><code>public void MoveRight()</code></p><ul><li><span>Sets the key press field to be the right direction.</span></li></ul></li></ul><h2><a name="the-userinterface-class" class="md-header-anchor"></a><span>The UserInterface Class</span></h2><p><span>The user interface class is responsible for handling the event where a key is down as well as drawing the snake and other game data on the screen.</span></p><h3><a name="fields-n222" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _squareWidth</code></p><ul><li><span>This is the calculated size of a game square (a node on the graph).</span></li></ul></li><li><p><code>private int _size</code></p><ul><li><span>The width and height of the game in number of nodes/game squares.</span></li></ul></li><li><p><code>private Game _game</code></p><ul><li><span>The game object.  This gives the UI access to informing the game when the user has changed directions, as well as letting the game inform the UI of the score and where the snake is.</span></li></ul></li><li><p><code>private SolidBrush _bodyBrush</code></p><ul><li><span>This field is initialized to a new SolidBrush, passing a Color of your choice as a parameter.  This will be used to give the snake color. (Note that it is NOT recommended to color the head of the snake differently than the body...it works fine for when it is being controlled by the human player, but the AI causes color flashes since it moves much faster)</span></li></ul></li><li><p><code>private SolidBrush _foodBrush</code></p><ul><li><span>Same as above, but used to color the food.</span></li></ul></li><li><p><code>private Pen _pen</code></p><ul><li><span>This is what gives each snake square an outline.  Initialize it to a new pen with a color of your choice and a width of 2.</span></li></ul></li><li><p><code>private CancellationTokenSource _cancelSource</code></p><ul><li><span>This field will allow the UserInterface to cancel or stop the async StartMoving method in the Game class.  Without this, if a new game is started before the previous one ends, the thread that was running the previous game will continue to run in the background. This field should be initialized to a new </span><code>CancellationTokenSource</code></li></ul></li></ul><h3><a name="methods-n254" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public UserInterface()</code></p><ul><li><span>This is the default constructor that simply calls the NewGame method below.</span></li></ul></li><li><p><code>private void NewGame()</code></p><ul><li><p><span>This creates a new game of a default size (I use 25 as the size).  This also sets the width and height of the picture box in the UI to 600.  You can change this size, but this seems to be a good balance on a standard resolution monitor.  You will also need to change the Size property of this (the form) to be a new size taking into account the picture box and the menu strip.  The square width should be calculated to be the picture box width divided by the size.  Note that the size should be something that can evenly divide into the picture box size, otherwise, there will be dead space in the graphics.  You also need to setup the databinding to the score label.  This can be done by clearing the </span><code>DataBindings</code><span> property of the score label control, then calling Add on the same property to add a new Binding.  The parameters you pass when creating the new Binding object should be “Text” (this is the property of the label you are binding to), the </span><strong><span>_game</span></strong><span> field (the object that has your data), and “Score”, the name of the property in the data which will be your source.  Then you need to create a new progress object (you may use the code below).  Before tell the game to start moving, set the </span><code>_cancelSource</code><span> to a new instance, then call the </span><code>StartMoving</code><span> method, passing the progress object and </span><code>_cancelSource.Token</code><span>.  This token allows the UI to communicate to the </span><code>StartMoving</code><span> method when a new game is created.  Be sure to add </span><code>_cancelSource.Cancel();</code><span> at the beginning of the this method (NewGame) so that any previous games are completely stopped before a new one is started.</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 44px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 36px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>17</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -36px; width: 36px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//this line of code goes inside the </span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">progress</span>.<span class="cm-variable">ProgressChanged</span> <span class="cm-operator">+=</span> <span class="cm-keyword">new</span> <span class="cm-variable">EventHandler</span><span class="cm-operator">&lt;</span><span class="cm-variable">SnakeStatus</span><span class="cm-operator">&gt;</span>(<span class="cm-variable">CheckProgress</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//this method goes outside of the NewGame method</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">private</span> <span class="cm-keyword">void</span> <span class="cm-variable">CheckProgress</span>(<span class="cm-variable-3">object</span> <span class="cm-variable">sender</span>, <span class="cm-variable">SnakeStatus</span> <span class="cm-variable">status</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">//Note that the Refresh call invalidates the state of the controls, forcing them to be redrawn.</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">Refresh</span>();</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">status</span> <span class="cm-operator">==</span> <span class="cm-variable">SnakeStatus</span>.<span class="cm-variable">Collision</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">MessageBox</span>.<span class="cm-variable">Show</span>(<span class="cm-string">"Game over!"</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable">status</span> <span class="cm-operator">==</span> <span class="cm-variable">SnakeStatus</span>.<span class="cm-variable">Win</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">MessageBox</span>.<span class="cm-variable">Show</span>(<span class="cm-string">"Game Completed!"</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 27px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -36px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 27px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 437px;"></div><div class="CodeMirror-gutters" style="height: 437px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 35px;"></div></div></div></div></pre></li></ul></li><li><p><code>private void uxPictureBox_Paint(object sender, PaintEventArgs e)</code></p><ul><li><span>This is an event handler that will draw all of the game graphics.  Be sure to assign this as the Paint event handler in the UI designer window for your picture box.  It is pretty straight forward to draw graphics is C#.  In this method, get the graphics object into a local Graphics variable.  The graphics object that belongs this control is contained the arguments (e.Graphics).  Then get the snake path through the game class.  For each of the game nodes in the snake path, we will create a new rectangle.  This rectangle is located at the coordinates of the node times the square width.  The width and height of the rectangle is the square width field.  Then to draw the rectangle, call the FillRectangle function of the graphics object, passing in the body brush and the rectangle as parameters.  Then we draw the outline, using the DrawRectangle method of the graphics object, passing in the pen and rectangle as parameters.  Finally, after the snake is drawn, we need to draw the food.  Get the food node through the game class and draw it just like the snake, but use FillEllipse instead.  This will draw it as a circle. </span><em><span>(Note that if the food is null, it should not be drawn)</span></em></li></ul></li><li><p><code>private void UserInterface_KeyDown(object sender, KeyEventArgs e)</code></p><ul><li><span>This is a KeyDown event handler which should be hooked to your Form control AND your AI CheckBox in your UI designer window (</span><em><span>Note that this is because the CheckBox can receive focus and can block the Form from triggering the event otherwise</span></em><span>).  If the game is still active, it will call the correct move function through the game class.  You can get what key was pressed by using </span><em><span>e.KeyCode</span></em><span> and compare that to </span><em><span>Keys.Up</span></em><span> etc..  After the key press was sent on, the picture box needs to be redrawn.  This can be triggered by using uxPictureBox.Refresh();</span></li></ul></li><li><p><span>Add three click event handlers corresponding to the New Game -&gt; Easy, Normal, and Hard menu items.  Each should create a </span><code>NewGame</code><span> with the following parameters:</span></p><ul><li><span>Easy: size 10 and speed 250</span></li><li><span>Normal: size 20 and speed 150</span></li><li><span>Hard: size 30 and speed 100</span></li></ul></li><li><p><span>Finally, add the following event handler, hooking it to both the Form control AND the CheckBox.  This enables the use of the arrow keys, otherwise they will not trigger the KeyDown event.</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 36px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 28px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>4</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -28px; width: 28px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">private</span> <span class="cm-keyword">void</span> <span class="cm-variable">UserInterface_PreviewKeyDown</span>(<span class="cm-variable-3">object</span> <span class="cm-variable">sender</span>, <span class="cm-variable">PreviewKeyDownEventArgs</span> <span class="cm-variable">e</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre></div><div style="position: relative;" class=""><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 19px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">e</span>.<span class="cm-variable">IsInputKey</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -28px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 19px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;"></div><div class="CodeMirror-gutters" style="height: 115px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 27px;"></div></div></div></div></pre></li></ul><h1><a name="testing-and-performance" class="md-header-anchor"></a><span>Testing and Performance</span></h1><p><span>Unit tests are provided to test </span><em><span>basic</span></em><span> functionality but they do not test UI elements, async elements, or keyboard interactions directly.  These will need to be tested manually.  The graphics should be redrawn smoothly with nearly no interruption to the user control (which should never be locked up). The game should work without bugs or crashes and follow game rules.  The AI should not cause any delays and should win the game every time. </span></p><h1><a name="submitting-your-assignment" class="md-header-anchor"></a><span>Submitting Your Assignment</span></h1><p><span>Be sure to </span><strong><span>refresh</span></strong><span> your Team Explorer, </span><strong><span>commit</span></strong><span> all your changes, then </span><strong><span>push</span></strong><span> your commits to your GitHub repository. Then submit the </span><em><span>entire URL</span></em><span> of the commit that you want graded. There is no need to submit a comment, as you will not have a completion code.</span></p><p><strong><span>Important:</span></strong><span> If the URL you submit does not contain the 40-hex-digit fingerprint of the commit you want graded, </span><strong><span>you will receive a 0</span></strong><span>, as this fingerprint is the only way we can verify that you completed your code prior to submitting your assignment. We will only grade the source code that is included in the commit that you submit. </span></p></div>
</body>
</html>