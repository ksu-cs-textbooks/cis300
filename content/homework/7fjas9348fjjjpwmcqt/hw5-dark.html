<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>hw5</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none 0s ease 0s; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
svg[id^="mermaidChart"] { line-height: 1em; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


/* Flowchart variables */
/* Sequence Diagram variables */
/* Gantt chart variables */
/* state colors */
.label {
  
  color: #333; }

.label text {
  fill: #333; }

.node rect,
.node circle,
.node ellipse,
.node polygon {
  fill: #BDD5EA;
  stroke: #9370DB;
  stroke-width: 1px; }

.node .label {
  text-align: center; }

.node.clickable {
  cursor: pointer; }

.arrowheadPath {
  fill: lightgrey; }

.edgePath .path {
  stroke: lightgrey;
  stroke-width: 1.5px; }

.edgeLabel {
  background-color: #e8e8e8;
  text-align: center; }

.cluster rect {
  fill: #6D6D65;
  stroke: rgba(255, 255, 255, 0.25);
  stroke-width: 1px; }

.cluster text {
  fill: #F9FFFE; }

div.mermaidTooltip {
  position: absolute;
  text-align: center;
  max-width: 200px;
  padding: 2px;
  
  font-size: 12px;
  background: #6D6D65;
  border: 1px solid rgba(255, 255, 255, 0.25);
  border-radius: 2px;
  pointer-events: none;
  z-index: 100; }

.actor {
  stroke: #81B1DB;
  fill: #BDD5EA; }

text.actor {
  fill: black;
  stroke: none; }

.actor-line {
  stroke: lightgrey; }

.messageLine0 {
  stroke-width: 1.5;
  stroke-dasharray: '2 2';
  stroke: lightgrey; }

.messageLine1 {
  stroke-width: 1.5;
  stroke-dasharray: '2 2';
  stroke: lightgrey; }

#arrowhead {
  fill: lightgrey; }

.sequenceNumber {
  fill: white; }

#sequencenumber {
  fill: lightgrey; }

#crosshead path {
  fill: lightgrey !important;
  stroke: lightgrey !important; }

.messageText {
  fill: lightgrey;
  stroke: none; }

.labelBox {
  stroke: #81B1DB;
  fill: #BDD5EA; }

.labelText {
  fill: #323D47;
  stroke: none; }

.loopText {
  fill: lightgrey;
  stroke: none; }

.loopLine {
  stroke-width: 2;
  stroke-dasharray: '2 2';
  stroke: #81B1DB; }

.note {
  stroke: rgba(255, 255, 255, 0.25);
  fill: #fff5ad; }

.noteText {
  fill: black;
  stroke: none;
  
  font-size: 14px; }

.activation0 {
  fill: #f4f4f4;
  stroke: #666; }

.activation1 {
  fill: #f4f4f4;
  stroke: #666; }

.activation2 {
  fill: #f4f4f4;
  stroke: #666; }

/** Section styling */
.section {
  stroke: none;
  opacity: 0.2; }

.section0 {
  fill: rgba(255, 255, 255, 0.3); }

.section2 {
  fill: #EAE8B9; }

.section1,
.section3 {
  fill: white;
  opacity: 0.2; }

.sectionTitle0 {
  fill: #F9FFFE; }

.sectionTitle1 {
  fill: #F9FFFE; }

.sectionTitle2 {
  fill: #F9FFFE; }

.sectionTitle3 {
  fill: #F9FFFE; }

.sectionTitle {
  text-anchor: start;
  font-size: 11px;
  text-height: 14px;
   }

/* Grid and axis */
.grid .tick {
  stroke: lightgrey;
  opacity: 0.3;
  shape-rendering: crispEdges; }

.grid path {
  stroke-width: 0; }

/* Today line */
.today {
  fill: none;
  stroke: #DB5757;
  stroke-width: 2px; }

/* Task styling */
/* Default task */
.task {
  stroke-width: 2; }

.taskText {
  text-anchor: middle;
   }

.taskText:not([font-size]) {
  font-size: 11px; }

.taskTextOutsideRight {
  fill: #323D47;
  text-anchor: start;
  font-size: 11px;
   }

.taskTextOutsideLeft {
  fill: #323D47;
  text-anchor: end;
  font-size: 11px; }

/* Special case clickable */
.task.clickable {
  cursor: pointer; }

.taskText.clickable {
  cursor: pointer;
  fill: #003163 !important;
  font-weight: bold; }

.taskTextOutsideLeft.clickable {
  cursor: pointer;
  fill: #003163 !important;
  font-weight: bold; }

.taskTextOutsideRight.clickable {
  cursor: pointer;
  fill: #003163 !important;
  font-weight: bold; }

/* Specific task settings for the sections*/
.taskText0,
.taskText1,
.taskText2,
.taskText3 {
  fill: #323D47; }

.task0,
.task1,
.task2,
.task3 {
  fill: #BDD5EA;
  stroke: rgba(255, 255, 255, 0.5); }

.taskTextOutside0,
.taskTextOutside2 {
  fill: lightgrey; }

.taskTextOutside1,
.taskTextOutside3 {
  fill: lightgrey; }

/* Active task */
.active0,
.active1,
.active2,
.active3 {
  fill: #81B1DB;
  stroke: rgba(255, 255, 255, 0.5); }

.activeText0,
.activeText1,
.activeText2,
.activeText3 {
  fill: #323D47 !important; }

/* Completed task */
.done0,
.done1,
.done2,
.done3 {
  stroke: grey;
  fill: lightgrey;
  stroke-width: 2; }

.doneText0,
.doneText1,
.doneText2,
.doneText3 {
  fill: #323D47 !important; }

/* Tasks on the critical line */
.crit0,
.crit1,
.crit2,
.crit3 {
  stroke: #E83737;
  fill: #E83737;
  stroke-width: 2; }

.activeCrit0,
.activeCrit1,
.activeCrit2,
.activeCrit3 {
  stroke: #E83737;
  fill: #81B1DB;
  stroke-width: 2; }

.doneCrit0,
.doneCrit1,
.doneCrit2,
.doneCrit3 {
  stroke: #E83737;
  fill: lightgrey;
  stroke-width: 2;
  cursor: pointer;
  shape-rendering: crispEdges; }

.milestone {
  transform: rotate(45deg) scale(0.8, 0.8); }

.milestoneText {
  font-style: italic; }

.doneCritText0,
.doneCritText1,
.doneCritText2,
.doneCritText3 {
  fill: #323D47 !important; }

.activeCritText0,
.activeCritText1,
.activeCritText2,
.activeCritText3 {
  fill: #323D47 !important; }

.titleText {
  text-anchor: middle;
  font-size: 18px;
  fill: #323D47;
   }

g.classGroup text {
  fill: #9370DB;
  stroke: none;
  
  font-size: 10px; }
  g.classGroup text .title {
    font-weight: bolder; }

g.classGroup rect {
  fill: #BDD5EA;
  stroke: #9370DB; }

g.classGroup line {
  stroke: #9370DB;
  stroke-width: 1; }

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: #BDD5EA;
  opacity: 0.5; }

.classLabel .label {
  fill: #9370DB;
  font-size: 10px; }

.relation {
  stroke: #9370DB;
  stroke-width: 1;
  fill: none; }

#compositionStart {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

#compositionEnd {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

#aggregationStart {
  fill: #BDD5EA;
  stroke: #9370DB;
  stroke-width: 1; }

#aggregationEnd {
  fill: #BDD5EA;
  stroke: #9370DB;
  stroke-width: 1; }

#dependencyStart {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

#dependencyEnd {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

#extensionStart {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

#extensionEnd {
  fill: #9370DB;
  stroke: #9370DB;
  stroke-width: 1; }

.commit-id,
.commit-msg,
.branch-label {
  fill: lightgrey;
  color: lightgrey;
   }

.pieTitleText {
  text-anchor: middle;
  font-size: 25px;
  fill: #eee;
}

.slice {
   }

g.stateGroup text {
  fill: #eee;
  stroke: none;
  font-size: 10px;
   }

g.stateGroup circle {
  fill: white !important;
  stroke: white !important;
}

g.stateGroup .state-title {
  font-weight: bolder;
  fill: black; }

g.stateGroup rect {
  fill: #ececff;
  stroke: #9370DB; }

g.stateGroup line {
  stroke: #9370DB;
  stroke-width: 1; }

.transition {
  stroke: #9370DB;
  stroke-width: 1;
  fill: none; }

.stateGroup .composit {
  fill: #555;
  border-bottom: 1px; }

.state-note {
  stroke: rgba(255, 255, 255, 0.25);
  fill: #fff5ad; }
  .state-note text {
    fill: black;
    stroke: none;
    font-size: 10px; }

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: #BDD5EA;
  opacity: 0.5; }

.stateLabel text {
  fill: black;
  font-size: 10px;
  font-weight: bold;
}


/* CSS Document */

/** code highlight */

.cm-s-inner .cm-variable,
.cm-s-inner .cm-operator,
.cm-s-inner .cm-property {
    color: #b8bfc6;
}

.cm-s-inner .cm-keyword {
    color: #C88FD0;
}

.cm-s-inner .cm-tag {
    color: #7DF46A;
}

.cm-s-inner .cm-attribute {
    color: #7575E4;
}

.CodeMirror div.CodeMirror-cursor {
    border-left: 1px solid #b8bfc6;
    z-index: 3;
}

.cm-s-inner .cm-string {
    color: #D26B6B;
}

.cm-s-inner .cm-comment,
.cm-s-inner.cm-comment {
    color: #DA924A;
}

.cm-s-inner .cm-header,
.cm-s-inner .cm-def,
.cm-s-inner.cm-header,
.cm-s-inner.cm-def {
    color: #8d8df0;
}

.cm-s-inner .cm-quote,
.cm-s-inner.cm-quote {
    color: #57ac57;
}

.cm-s-inner .cm-hr {
    color: #d8d5d5;
}

.cm-s-inner .cm-link {
    color: #d3d3ef;
}

.cm-s-inner .cm-negative {
    color: #d95050;
}

.cm-s-inner .cm-positive {
    color: #50e650;
}

.cm-s-inner .cm-string-2 {
    color: #f50;
}

.cm-s-inner .cm-meta,
.cm-s-inner .cm-qualifier {
    color: #b7b3b3;
}

.cm-s-inner .cm-builtin {
    color: #f3b3f8;
}

.cm-s-inner .cm-bracket {
    color: #997;
}

.cm-s-inner .cm-atom,
.cm-s-inner.cm-atom {
    color: #84B6CB;
}

.cm-s-inner .cm-number {
    color: #64AB8F;
}

.cm-s-inner .cm-variable {
    color: #b8bfc6;
}

.cm-s-inner .cm-variable-2 {
    color: #9FBAD5;
}

.cm-s-inner .cm-variable-3 {
    color: #1cc685;
}

.CodeMirror-selectedtext,
.CodeMirror-selected {
    background: #4a89dc;
    color: #fff !important;
    text-shadow: none;
}

.CodeMirror-gutters {
    border-right: none;
}

/* CSS Document */

/** markdown source **/
.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property
{
    color: #cebcca;
}

.CodeMirror.cm-s-typora-default div.CodeMirror-cursor{
    border-left: 3px solid #b8bfc6;
}

.cm-s-typora-default .cm-comment {
    color: #9FB1FF;
}

.cm-s-typora-default .cm-string {
    color: #A7A7D9
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
    color: #848695;
    font-style: italic;
}

.cm-s-typora-default .cm-link {
    color: #95B94B;
}

.cm-s-typora-default .CodeMirror-activeline-background {
    background: rgba(51, 51, 51, 0.72);
}

.cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code {
	color: #8aa1e1;
}@import "";
@import "";
@import "";

:root {
    --bg-color:  #363B40;
    --side-bar-bg-color: #2E3033;
    --text-color: #b8bfc6;

    --select-text-bg-color:#4a89dc;

    --item-hover-bg-color: #0a0d16;
    --control-text-color: #b7b7b7;
    --control-text-hover-color: #eee;
    --window-border: 1px solid #555;

    --active-file-bg-color: rgb(34, 34, 34);
    --active-file-border-color: #8d8df0;

    --primary-color: #a3d5fe;

    --active-file-text-color: white;
    --item-hover-bg-color: #70717d;
    --item-hover-text-color: white;
    --primary-color: #6dc1e7;

    --rawblock-edit-panel-bd: #333;

    --search-select-bg-color: #428bca;
}

html {
    font-size: 16px;
}

html,
body {
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    background: #363B40;
    background: var(--bg-color);
    fill: currentColor;
    line-height: 1.625rem;
}

#write {
    max-width: 914px;
}


@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

html,
body,
button,
input,
select,
textarea,
div.code-tooltip-content {
    color: #b8bfc6;
    border-color: transparent;
}

div.code-tooltip,
.md-hover-tip .md-arrow:after {
    background: #333;
}

.popover.bottom > .arrow:after {
    border-bottom-color: #333;
}

html,
body,
button,
input,
select,
textarea {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

hr {
    height: 2px;
    border: 0;
    margin: 24px 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: "Lucida Grande", "Corbel", sans-serif;
    font-weight: normal;
    clear: both;
    -ms-word-wrap: break-word;
    word-wrap: break-word;
    margin: 0;
    padding: 0;
    color: #DEDEDE
}

h1 {
    font-size: 2.5rem;
    /* 36px */
    line-height: 2.75rem;
    /* 40px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1.5px;
}

h2 {
    font-size: 1.63rem;
    /* 24px */
    line-height: 1.875rem;
    /* 30px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h3 {
    font-size: 1.17rem;
    /* 18px */
    line-height: 1.5rem;
    /* 24px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h4 {
    font-size: 1.12rem;
    /* 16px */
    line-height: 1.375rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    color: white;
}

h5 {
    font-size: 0.97rem;
    /* 16px */
    line-height: 1.25rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    font-weight: bold;
}

h6 {
    font-size: 0.93rem;
    /* 16px */
    line-height: 1rem;
    /* 16px */
    margin-bottom: 0.75rem;
    color: white;
}

@media (min-width: 980px) {
    h3.md-focus:before,
    h4.md-focus:before,
    h5.md-focus:before,
    h6.md-focus:before {
        color: #ddd;
        border: 1px solid #ddd;
        border-radius: 3px;
        position: absolute;
        left: -1.642857143rem;
        top: .357142857rem;
        float: left;
        font-size: 9px;
        padding-left: 2px;
        padding-right: 2px;
        vertical-align: bottom;
        font-weight: normal;
        line-height: normal;
    }

    h3.md-focus:before {
        content: 'h3';
    }

    h4.md-focus:before {
        content: 'h4';
    }

    h5.md-focus:before {
        content: 'h5';
        top: 0px;
    }

    h6.md-focus:before {
        content: 'h6';
        top: 0px;
    }
}

a {
    text-decoration: none;
    outline: 0;
}

a:hover {
    outline: 0;
}

a:focus {
    outline: thin dotted;
}

sup.md-footnote {
    background-color: #555;
    color: #ddd;
}

p {
    -ms-word-wrap: break-word;
    word-wrap: break-word;
}

p,
ul,
dd,
ol,
hr,
address,
pre,
table,
iframe,
.wp-caption,
.wp-audio-shortcode,
.wp-video-shortcode {
    margin-top: 0;
    margin-bottom: 1.5rem;
    /* 24px */
}

li > blockquote {
	margin-bottom: 0;
}

audio:not([controls]) {
    display: none;
}

[hidden] {
    display: none;
}

::-moz-selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

*.in-text-selection,
::selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

ul,
ol {
    padding: 0 0 0 1.875rem;
    /* 30px */
}

ul {
    list-style: square;
}

ol {
    list-style: decimal;
}

ul ul,
ol ol,
ul ol,
ol ul {
    margin: 0;
}

b,
th,
dt,
strong {
    font-weight: bold;
}

i,
em,
dfn,
cite {
    font-style: italic;
}

blockquote {
    padding-left: 1.875rem;
    margin: 0 0 1.875rem 1.875rem;
    border-left: solid 2px #474d54;
    padding-left: 30px;
    margin-top: 35px;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875rem;
    font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace;
}

code,
tt,
var {
    background: rgba(0, 0, 0, 0.05);
}

kbd {
    padding: 2px 4px;
    font-size: 90%;
    color: #fff;
    background-color: #333;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 rgba(0,0,0,.25);
}

pre.md-fences {
    padding: 10px 10px 10px 30px;
    margin-bottom: 20px;
    background: #333;
}

.CodeMirror-gutters {
    background: #333;
    border-right: 1px solid transparent;
}

.enable-diagrams pre.md-fences[lang="sequence"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="flow"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="mermaid"] .code-tooltip {
    bottom: -2.2em;
    right: 4px;
}

code,
kbd,
tt,
var {
    padding: 2px 5px;
}

table {
    max-width: 100%;
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
}

th,
td {
    padding: 5px 10px;
    vertical-align: top;
}

a {
    -webkit-transition: all .2s ease-in-out;
    transition: all .2s ease-in-out;
}

hr {
    background: #474d54;
    /* variable */
}

h1 {
    margin-top: 2em;
}

a {
    color: #e0e0e0;
    text-decoration: underline;
}

a:hover {
    color: #fff;
}

.md-inline-math script {
    color: #81b1db;
}

b,
th,
dt,
strong {
    color: #DEDEDE;
    /* variable */
}

mark {
    background: #D3D40E;
}

blockquote {
    color: #9DA2A6;
}

table a {
    color: #DEDEDE;
    /* variable */
}

th,
td {
    border: solid 1px #474d54;
    /* variable */
}

.task-list {
    padding-left: 0;
}

.md-task-list-item {
    padding-left: 1.25rem;
}

.md-task-list-item > input {
    top: auto;
}

.md-task-list-item > input:before {
    content: "";
    display: inline-block;
    width: 0.875rem;
    height: 0.875rem;
    vertical-align: middle;
    text-align: center;
    border: 1px solid #b8bfc6;
    background-color: #363B40;
    margin-top: -0.4rem;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before {
    content: '\221A';
    /*◘*/
    font-size: 0.625rem;
    line-height: 0.625rem;
    color: #DEDEDE;
}

/** quick open **/
.auto-suggest-container {
    border: 0px;
    background-color: #525C65;
}

#typora-quick-open {
    background-color: #525C65;
}

#typora-quick-open input{
    background-color: #525C65;
    border: 0;
    border-bottom: 1px solid grey;
}

.typora-quick-open-item {
    background-color: inherit;
    color: inherit;
}

.typora-quick-open-item.active,
.typora-quick-open-item:hover {
    background-color: #4D8BDB;
    color: white;
}

.typora-quick-open-item:hover {
    background-color: rgba(77, 139, 219, 0.8);
}

.typora-search-spinner > div {
  background-color: #fff;
}

#write pre.md-meta-block {
    border-bottom: 1px dashed #ccc;
    background: transparent;
    padding-bottom: 0.6em;
    line-height: 1.6em;
}

.btn,
.btn .btn-default {
    background: transparent;
    color: #b8bfc6;
}

.ty-table-edit {
    border-top: 1px solid gray;
    background-color: #363B40;
}

.popover-title {
    background: transparent;
}

.md-image>.md-meta {
    color: #BBBBBB;
    background: transparent;
}

.md-expand.md-image>.md-meta {
    color: #DDD;
}

#write>h3:before,
#write>h4:before,
#write>h5:before,
#write>h6:before {
    border: none;
    border-radius: 0px;
    color: #888;
    text-decoration: underline;
    left: -1.4rem;
    top: 0.2rem;
}

#write>h3.md-focus:before {
    top: 2px;
}

#write>h4.md-focus:before {
    top: 2px;
}

.md-toc-item {
    color: #A8C2DC;
}

#write div.md-toc-tooltip {
    background-color: #363B40;
}

.dropdown-menu .btn:hover,
.dropdown-menu .btn:focus,
.md-toc .btn:hover,
.md-toc .btn:focus {
    color: white;
    background: black;
}

#toc-dropmenu {
    background: rgba(50, 54, 59, 0.93);
    border: 1px solid rgba(253, 253, 253, 0.15);
}

#toc-dropmenu .divider {
    background-color: #9b9b9b;
}

.outline-expander:before {
    top: 2px;
}

#typora-sidebar {
    box-shadow: none;
    border-right: 1px dashed;
    border-right: none;
}

.sidebar-tabs {
    border-bottom:0;
}

#typora-sidebar:hover .outline-title-wrapper {
    border-left: 1px dashed;
}

.outline-title-wrapper .btn {
    color: inherit;
}

.outline-item:hover {
    border-color: #363B40;
    background-color: #363B40;
    color: white;
}

h1.md-focus .md-attr,
h2.md-focus .md-attr,
h3.md-focus .md-attr,
h4.md-focus .md-attr,
h5.md-focus .md-attr,
h6.md-focus .md-attr,
.md-header-span .md-attr {
    color: #8C8E92;
    display: inline;
}

.md-comment {
    color: #5a95e3;
    opacity: 1;
}

.md-inline-math svg {
    color: #b8bfc6;
}

#math-inline-preview .md-arrow:after {
    background: black;
}

.modal-content {
    background: var(--bg-color);
    border: 0;
}

.modal-title {
    font-size: 1.5em;
}

.modal-content input {
    background-color: rgba(26, 21, 21, 0.51);
    color: white;
}

.modal-content .input-group-addon {
    color: white;
}

.modal-backdrop {
    background-color: rgba(174, 174, 174, 0.7);
}

.modal-content .btn-primary {
    border-color: var(--primary-color);
}

.md-table-resize-popover {
    background-color: #333;
}

.form-inline .input-group .input-group-addon {
    color: white;
}

#md-searchpanel {
    border-bottom: 1px dashed grey;
}

/** UI for electron */

.context-menu,
#spell-check-panel,
#footer-word-count-info {
    background-color: #42464A;
}

.context-menu.dropdown-menu .divider,
.dropdown-menu .divider {
    background-color: #777777;
}

footer {
    color: inherit;
}

@media (max-width: 1000px) {
    footer {
        border-top: none;
    }
    footer:hover {
        color: inherit;
    }
}

#file-info-file-path .file-info-field-value:hover {
    background-color: #555;
    color: #dedede;
}

.megamenu-content,
.megamenu-opened header {
    background: var(--bg-color);
}

.megamenu-menu-panel h2,
.megamenu-menu-panel h1,
.long-btn {
    color: inherit;
}

.megamenu-menu-panel input[type='text'] {
    background: inherit;
    border: 0;
    border-bottom: 1px solid;
}

#recent-file-panel-action-btn {
    background: inherit;
    border: 1px grey solid;
}

.megamenu-menu-panel .dropdown-menu > li > a {
    color: inherit;
    background-color: #2F353A;
    text-decoration: none;
}

.megamenu-menu-panel table td:nth-child(1) {
    color: inherit;
    font-weight: bold;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(1) {
    color: white;
}

.modal-footer .btn-default, 
.modal-footer .btn-primary,
.modal-footer .btn-default:not(:hover) {
    border: 1px solid;
    border-color: transparent;
}

.btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default {
    color: white;
    border: 1px solid #ddd;
    background-color: inherit;
}

.modal-header {
    border-bottom: 0;
}

.modal-footer {
    border-top: 0;
}

#recent-file-panel tbody tr:nth-child(2n-1) {
    background-color: transparent !important;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(2) {
    color: inherit;
}

.megamenu-menu-panel .btn {
    border: 1px solid #eee;
    background: transparent;
}

.mouse-hover .toolbar-icon.btn:hover,
#w-full.mouse-hover,
#w-pin.mouse-hover {
    background-color: inherit;
}

.typora-node::-webkit-scrollbar {
    width: 5px;
}

.typora-node::-webkit-scrollbar-thumb:vertical {
    background: rgba(250, 250, 250, 0.3);
}

.typora-node::-webkit-scrollbar-thumb:vertical:active {
    background: rgba(250, 250, 250, 0.5);
}

#w-unpin {
    background-color: #4182c4;
}

#top-titlebar, #top-titlebar * {
    color: var(--item-hover-text-color);
}

.typora-sourceview-on #toggle-sourceview-btn,
#footer-word-count:hover,
.ty-show-word-count #footer-word-count {
    background: #333333;
}

#toggle-sourceview-btn:hover {
    color: #eee;
    background: #333333;
}

/** focus mode */
.on-focus-mode .md-end-block:not(.md-focus):not(.md-focus-container) * {
    color: #686868 !important;
}

.on-focus-mode .md-end-block:not(.md-focus) img,
.on-focus-mode .md-task-list-item:not(.md-focus-container)>input {
    opacity: #686868 !important;
}

.on-focus-mode li[cid]:not(.md-focus-container){
    color: #686868;
}

.on-focus-mode .md-fences.md-focus .CodeMirror-code>*:not(.CodeMirror-activeline) *,
.on-focus-mode .CodeMirror.cm-s-inner:not(.CodeMirror-focused) * {
    color: #686868 !important;
}

.on-focus-mode .md-focus,
.on-focus-mode .md-focus-container {
    color: #fff;
}

.on-focus-mode #typora-source .CodeMirror-code>*:not(.CodeMirror-activeline) * {
    color: #686868 !important;
}


/*diagrams*/
#write .md-focus .md-diagram-panel {
    border: 1px solid #ddd;
    margin-left: -1px;
    width: calc(100% + 2px);
}

/*diagrams*/
#write .md-focus.md-fences-with-lineno .md-diagram-panel {
    margin-left: auto;
}

.md-diagram-panel-error {
    color: #f1908e;
}

.active-tab-files #info-panel-tab-file,
.active-tab-files #info-panel-tab-file:hover,
.active-tab-outline #info-panel-tab-outline,
.active-tab-outline #info-panel-tab-outline:hover {
    color: #eee;
}

.sidebar-footer-item:hover,
.footer-item:hover {
    background: inherit;
    color: white;
}

.ty-side-sort-btn.active,
.ty-side-sort-btn:hover,
.selected-folder-menu-item a:after {
    color: white;
}

#sidebar-files-menu {
    border:solid 1px;
    box-shadow: 4px 4px 20px rgba(0, 0, 0, 0.79);
    background-color: var(--bg-color);
}

.file-list-item {
    border-bottom:none;
}

.file-list-item-summary {
    opacity: 1;
}

.file-list-item.active:first-child {
    border-top: none;
}

.file-node-background {
    height: 32px;
}

.file-library-node.active>.file-node-content,
.file-list-item.active {
    color: white;
    color: var(--active-file-text-color);
}

.file-library-node.active>.file-node-background{
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}
.file-list-item.active {
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}

#ty-tooltip {
    background-color: black;
    color: #eee;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: 0.3rem;
    -webkit-appearance: none;
}

.md-mathjax-midline {
    background-color: #57616b;
    border-bottom: none;
}

footer.ty-footer {
    border-color: #656565;
}

.ty-preferences .btn-default {
    background: transparent;
}
.ty-preferences .btn-default:hover {
    background: #57616b;
}

.ty-preferences select {
    border: 1px solid #989698;
    height: 21px;
}

.ty-preferences .nav-group-item.active {
    background: var(--item-hover-bg-color);
}

.ty-preferences input[type="search"] {
    border-color: #333;
    background: #333;
    line-height: 22px;
    border-radius: 6px;
    color: white;
}

.ty-preferences input[type="search"]:focus {
    box-shadow: none;
}

[data-is-directory="true"] .file-node-content {
    margin-bottom: 0;
}

.file-node-title {
    line-height: 22px;
}

.html-for-mac .file-node-open-state, .html-for-mac .file-node-icon {
    line-height: 26px;
}

::-webkit-scrollbar-thumb {
    background: rgba(230, 230, 230, 0.30);
}

::-webkit-scrollbar-thumb:active {
    background: rgba(230, 230, 230, 0.50);
}

#typora-sidebar:hover div.sidebar-content-content::-webkit-scrollbar-thumb:horizontal {
    background: rgba(230, 230, 230, 0.30);
}

.nav-group-item:active {
    background-color: #474d54;
}

.md-search-hit {
    background: rgba(199, 140, 60, 0.81);
    color: #eee;
}

.md-search-hit * {
    color: #eee;
}

#md-searchpanel input {
    color: white;
}


</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p><img src="clip_image002.jpg" referrerpolicy="no-referrer" alt="Related image"></p><h1><a name="user-requirements" class="md-header-anchor"></a><span>User Requirements</span></h1><p><span>For this assignment, you will be creating a video game classic: Snake.  Snake was originally a cellphone game launched on the Nokia in the late ‘90s.  In its simplest form, you control a snake that can go up, left, right, or down.  The game board also contains one piece of snake food at a random location. When the snake eats this food, points are awarded, a new piece of food is generated an a random unoccupied location, and the snake body grows. The goal is to eat as much snake food as you can. If the snake runs into the edge of the screen or a section of itself, the game is over.</span></p><p><span>The game you will construct has two modes. The first mode is the normal video game mode in which a user plays until the game ends. The second mode is an AI that plays without user input and always maximizes its score.</span></p><iframe width="560" height="560" src="https://www.youtube.com/embed/DFDG3TmLC0Y" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h2><a name="the-perfect-snake-ai" class="md-header-anchor"></a><span>The Perfect Snake AI</span></h2><p><span>AI for Snake is a solved problem.  There are many different approaches, some seem seemingly more random than others, but there exist solutions that produce an AI player that always plays until the snake fills the entire board.  One solution to this problem is generating a </span><a href='https://en.wikipedia.org/wiki/Hamiltonian_path'><span>Hamiltonian cycle</span></a><span>.  A Hamiltonian cycle is a path that visits all nodes in a graph exactly once before returning to the beginning of path.  This path does not necessarily include all edges in the graph.  We can generate a Hamiltonian cycle for Snake if we split our game space out into an </span><strong><span>n x n</span></strong><span> grid, where each grid square represents a graph node that has edges to each adjacent node (vertically or horizontally, but not diagonally).  </span></p><p><span>Verifying that a Hamiltonian cycle exists in a graph is </span><a href='https://en.wikipedia.org/wiki/NP-completeness'><span>NP-complete</span></a><span>. NP-completeness is a deep theoretical concept, but as of this writing there are no known algorithms for solving any NP-complete problem in </span><span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.061ex" height="2.811ex" viewBox="0 -906.7 2609.4 1210.2" role="img" focusable="false" style="vertical-align: -0.705ex;"><defs><path stroke-width="0" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path stroke-width="0" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path stroke-width="0" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path stroke-width="0" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path stroke-width="0" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMATHI-4F" x="0" y="0"></use><use xlink:href="#E1-MJMAIN-28" x="763" y="0"></use><g transform="translate(1152,0)"><use xlink:href="#E1-MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6B" x="848" y="513"></use></g><use xlink:href="#E1-MJMAIN-29" x="2220" y="0"></use></g></svg></span><script type="math/tex">O(n^k)</script><span> time for any fixed </span><span class="MathJax_SVG" tabindex="-1" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.21ex" height="1.994ex" viewBox="0 -755.9 521 858.4" role="img" focusable="false" style="vertical-align: -0.238ex;"><defs><path stroke-width="0" id="E2-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E2-MJMATHI-6B" x="0" y="0"></use></g></svg></span><script type="math/tex">k</script><span>, and most experts believe it is impossible to find such an algorithm.  In terms of running time, that does not bode well for an AI player which should be able to execute moves in a game in real time.  Likewise, not all Hamiltonian cycles will result to a guaranteed win in Snake (some end up causing the snake to trap itself).  However, if we find a Hamiltonian cycle from the head of the snake through its tail, then through the snake itself to its head, we can be sure the snake will never trap itself.  And if the AI just follows this path until it wins (the snake fills the entire screen), we only need to calculate this path at the beginning of the game.  This works on the assumption that the game&#39;s grid is of even width and height; otherwise, there may not always be a Hamiltonian path.</span></p><h3><a name="generating-a-hamiltonian-path" class="md-header-anchor"></a><span>Generating a Hamiltonian Path</span></h3><p><span>The path for the AI to follow can be found by building a path incrementally. We  start by finding a shortest path from the head of the snake to its tail (it cannot traverse through itself to get to the tail). To find the Hamiltonian path from our shortest path, we can slowly extend each portion of the path (starting at the head) in perpendicular directions (if the path is going up or down, try to extend the path left or right and vice versa).  If the path is able to be extended in a direction, we continue one step parallel to the original path, then return to the original path by going in the direction opposite of the extension we inserted. Note that if we represent a path as a list of directions, this amounts to inserting directions before and after the direction that follows our current location. These inserted directions are opposite each other. </span></p><p><span>If the path cannot be extended any farther, move on to the next position in the path. This continues until no part of the path can be extended. Then, if we just connect the path to the rest of the snake, we have a complete Hamiltonian path that starts at the head and ends at the tail.  Following this path will allow the Snake AI to constantly chase its tail, preventing it from ever being trapped.  Below is an example of this process on a 4x4 game. </span></p><p><img src="hamiltonian.png" referrerpolicy="no-referrer" alt="hamiltonian"></p><ol start='' ><li><span>The shortest path is found from (H)ead to (T)ail. </span></li><li><span>Since the path from H was going left, we try (and do) extend the path up (see that &quot;up&quot; is inserted before &quot;left&quot;, and the opposite --- &quot;down&quot; --- is inserted after &quot;left&quot;).  </span></li><li><span>The current direction from H is up, so we can extend the path to the right.</span></li><li><span>In this step, we progressed all the way to node (1,0) (</span><em><span>note that the top row of numbers in the figures is the x-coordinate and the left is the y-coordinate</span></em><span>) because the path at H cannot be extended, so we follow the path until we come to a node where the path can be extended (1,0). The path at this location is extended left.</span></li><li><span>The algorithm progresses to node (1,2) where the path can be extended down.</span></li><li><span>The path gets extended again at (1,2), but this time, left.</span></li><li><span>The algorithm progresses to (2,3) where the path gets extended right.</span></li><li><span>In this step, the main algorithm finishes before the last direction is added to the path.  The main algorithm ends here since we have reached the end of the path (in blue), but in order for it to be a true Hamiltonian cycle, we need to include the rest of the snake in the path so we traverse the snake from the tail to add the remaining direction to the path. </span></li></ol><p><span>The resulting path is traversed in order from head to tail continuously by the AI in order to solve the game.  An example of the AI working can be found below (url: </span><a href='https://www.youtube.com/watch?v=yXLp50i8Olk' target='_blank' class='url'>https://www.youtube.com/watch?v=yXLp50i8Olk</a><span>):</span></p><iframe width="375" height="375" src="https://www.youtube.com/embed/yXLp50i8Olk" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><h1><a name="starting-the-assignment" class="md-header-anchor"></a><span>Starting the Assignment</span></h1><p><span>Create a GitHub repository using </span><a href='https://classroom.github.com/a/Ejrbwlrr'><strong><span>this URL</span></strong></a><span>. This repository will contain a skeleton Windows Forms application.</span></p><h1><a name="user-interface" class="md-header-anchor"></a><span>User Interface</span></h1><p><img src="ui.png" alt="img" style="zoom:80%;" /></p><p><span>The user interface is fairly simple.  At the top, there is a </span><strong><span>MenuStrip</span></strong><span> that has one menu, File. This menu contains a single item, </span><strong><span>New Game</span></strong><span>, which in turn has a sub-menu with </span><strong><span>Easy</span></strong><span>, </span><strong><span>Normal</span></strong><span>, and </span><strong><span>Hard</span></strong><span> as options.  Clicking one of these sub-menu items will start a new game of that difficulty.  When a new game option is clicked, the game is reset with a snake of size 2 in the center and started automatically (the snake starts moving upward on its own).  Since the snake is grown by the game by one before control is given to the user or AI, the score is set to 2 to start.  The score correlates to the size of the snake. If the </span><strong><span>CheckBox</span></strong><span> for the AI player is checked when a new game is created, then the AI player will take control of the snake.  During this mode, the human should not be able to control the snake. If this box in not checked, the user will be able to control the direction the snake is moving using the arrow keys.  Next to the checkbox, there is a </span><strong><span>NumericUpDown</span></strong><span> control with a minimum value of 1.  This control will indicate the delay (speed) of the AI if the AI is enabled.</span></p><p><span>In the top right hand corner, there are two labels that will be used to keep track of the player’s score.  The </span><strong><span>Label</span></strong><span> in the top right-hand corner is used for the score itself.  The </span><strong><span>AutoSize</span></strong><span> property should be set to </span><strong><span>false</span></strong><span> (this will let you size it yourself).  The text </span><strong><span>size</span></strong><span> should be adjusted for both of the Labels and the font should be </span><strong><span>bolded</span></strong><span>.   Both of these labels should be </span><strong><span>anchored</span></strong><span> to the top and the right.</span></p><p><span>The main part of the form (the black area) is a </span><strong><span>PictureBox</span></strong><span>.  You do not need to worry about sizing this control as it will be done programmatically.  Lastly, for the </span><strong><span>Form</span></strong><span> control, be sure to set the </span><strong><span>KeyPreview</span></strong><span> property to </span><strong><span>True</span></strong><span>.  This is very important.  Without this, the arrow keys will not register the correct event handlers.  This lets the user control the snake with the arrow keys regardless of which control has focus (clicked on, etc.).  If this is not set, when the Score is updated, the controls for the snake will not register properly.</span></p><h1><a name="tasks" class="md-header-anchor"></a><span>Tasks</span></h1><p><span>This project takes a simple approach to creating a game in C# that can perform background tasks (the game logic) and update the UI (visuals and controls of the game) at the same time. To do this in C#, we will use async/await and Tasks to prevent the GUI from being frozen.  To learn more about these topics, please watch/read the following (some of these are  for reference, some are for learning):</span></p><ol start='' ><li><a href='https://channel9.msdn.com/Series/Three-Essential-Tips-for-Async/Three-Essential-Tips-For-Async-Introduction'><span>Microsoft video on understanding basics of async </span></a></li><li><a href='https://www.youtube.com/watch?v=C5VhaxQWcpE'><span>Example tutorial on async and await </span></a><span>                   </span></li><li><a href='https://msdn.microsoft.com/en-us/magazine/jj991977.aspx'><span>Best practices using async/await </span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming'><span>Microsoft documentation examples on using Tasks</span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/'><span>Microsoft documentation examples on async </span></a></li><li><a href='http://nikolar.com/2013/09/02/asynchronously-deadlocked-or-do-not-wrap-async-methods-into-sync-wrappers-httpclient-getasync-not-returning/'><span>Gotchyas on using async/await with UIs</span></a></li><li><a href='https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitany?view=netframework-4.7.2'><span>WaitAny documentation </span></a></li><li><a href='https://www.dotnetperls.com/async'><span>Aditional tutorial on async</span></a></li></ol><h1><a name="software-architecture" class="md-header-anchor"></a><span>Software Architecture</span></h1><p><img src="snake-uml.png" alt="snake-uml" style="zoom:80%;" /></p><p><span>You do not need to use the same names as shown in the class diagram, as long as you follow the </span><a href='https://cis300.cs.ksu.edu/appendix/style/naming/'><span>naming conventions</span></a><span> for CIS 300. You may add any </span><strong><span>private</span></strong><span> methods that you feel improve the code.  </span></p><h1><a name="coding-requirements" class="md-header-anchor"></a><span>Coding Requirements</span></h1><p><span>The below are the classes, methods, and functionality for the Snake game.  There are three enumerations that you can see above.  These do not have to go in any particular file, but they should </span><strong><span>not</span></strong><span> be a part of any class definition.  They just need to belong to the namespace.</span></p><h2><a name="the-gamenode-class" class="md-header-anchor"></a><span>The GameNode Class</span></h2><p><span>This class is a simple object that serves as a node in the graph that represents the game board.  It does not contain any functionality beyond the noted properties and constructor.</span></p><h3><a name="properties" class="md-header-anchor"></a><span>Properties</span></h3><p><em><span>Note that each of the following properties have default get and set accessors.</span></em></p><ul><li><p><code>public int Y</code></p><ul><li><span>The y-coordinate for this node</span></li></ul></li><li><p><code>public int X</code></p><ul><li><span>The x-coordinate for this node</span></li></ul></li><li><p><code>public GridData Data</code></p><ul><li><span>The information stored at this node.  This is an enumeration which makes it cheap and efficient for storing game “objects” at locations.  Each node is only allowed to have a single piece of the game at any time.  For example, a node cannot have the snake and snake food together.  </span></li></ul></li><li><p><code>public GameNode SnakeEdge</code></p><ul><li><span>This edge represents a connection in the graph to another GameNode.  In the  game, it is used only to connect the snake pieces on the GameBoard leading in the direction from the tail to the head.</span></li></ul></li></ul><h3><a name="methods" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public GameNode(int x, int y)</code></p><ul><li><span>This is the default constructor that sets the x-y coordinate properties above.</span></li></ul></li><li><p><span>You may also override the ToString method to allow for easier debugging (show the x,y coordinate with the data stored).</span></p></li></ul><h2><a name="the-gameboard-class" class="md-header-anchor"></a><span>The GameBoard Class</span></h2><p><span>This class contains the majority of the game’s logic.  It keeps information about the game board and is responsible for making the snake grow or move into a new place on the board.  The game board is setup as an array of </span><strong><span>GameNode</span></strong><span>s forming an undirected graph.  This is what will be used to know the location of game objects like the snake and the food.  In addition to this, nodes that contain the snake will also have additional graph information to track the direction of the snake.  This is an added efficiency to make constructing the snake faster than scanning the entire grid every time for each snake section.  Note that the UI does not really interact with the </span><strong><span>GameBoard</span></strong><span> class directly.  The Game class, discussed next, will be the middle ground communication.</span></p><h3><a name="properties-n98" class="md-header-anchor"></a><span>Properties</span></h3><ul><li><p><code>public GameNode Food</code></p><ul><li><span>This is a property that has public get and set accessors.  This will return the game node that contains the food.  This is intended to make the drawing of the food easier on the UI.</span></li></ul></li><li><p><code>public GameNode[,] Grid</code></p><ul><li><span>This is a property that has a public get accessor and a private set accessor. This is the array for storing the nodes of the game board.</span></li></ul></li><li><p><code>public GameNode Head</code></p><ul><li><span>This is a property that has public get and set accessors.  It maintains a reference to where the head of the snake is currently located.</span></li></ul></li><li><p><code>public GameNode Tail</code></p><ul><li><span>This is a property that has public get and set accessors.  It maintains a reference to where the tail of the snake is currently located.</span></li></ul></li><li><p><code>public int SnakeSize</code></p><ul><li><span>This is a property that has a public get accessor and  a private set accessor.  It keeps track of how big the snake is at any given time.</span></li></ul></li></ul><h3><a name="fields" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _size</code></p><ul><li><span>This field keeps track of the dimension (n) of the board.</span></li></ul></li><li><p><code>private Direction[] _aiDirection</code></p><ul><li><span>This array contains all four possible directions to make it easier to find adjacent nodes to search when finding the shortest path in the board.  My order is up, left, right, down...but this should not impact functionality, just the path order your snake AI takes.</span></li></ul></li><li><p><code>private Direction[] _leftRight</code><span> and </span><code>private Direction[] _upDown</code></p><ul><li><span>These arrays contain the directions left, right and up down respectively.  These are used for determining which directions the AI can use to extend the path when calculating the Hamiltonian path.</span></li></ul></li><li><p><code>private static Random _random</code></p><ul><li><span>This field is initialized to a new Random object.  This will be utilized in the </span><code>AddFood</code><span> method to place the food in a random location.</span></li></ul></li></ul><h3><a name="methods-n147" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public GameBoard(int size)</code></p><ul><li><span>This is a constructor that initializes the game board to a new board of the given size.  Each node should be initialized with its x-y location, but nothing else.  Once the board is made, then the head and tail should be placed in its center.  This will be slightly off-center if the board is of even size.  Be sure to set the data of this node to be the snake head and store a reference to the node in the head and tail fields.  Then, add the food to the board by using the method below. </span></li></ul></li><li><p><code>public void AddFood()</code></p><ul><li><span>This method randomly places the snake food on the board. This is done by setting data of a random node to be SnakeFood.  The food cannot be placed in a node unless it is empty.  Be sure to store the reference to the node you place the food in the </span><strong><span>Food</span></strong><span> property above.</span></li></ul></li><li><p><code>public GameNode GetNextNode(Direction dir, GameNode current)</code></p><ul><li><span>This is a helper method that will return the node that would be next from current if were headed in the given direction.  The method should return </span><strong><span>null</span></strong><span> if it would move off of the board.</span></li></ul></li><li><p><code>public SnakeStatus MoveSnake(Direction dir)</code></p><ul><li><p><span>This is the main logic on how the snake moves through the game board.  First, get the next node using the method above.  If the node is </span><strong><span>null</span></strong><span>, return that a collision happened (</span><code>SnakeStatus.Collision</code><span>).  If the next node is the node immediately before the snake head, then the user pressed an invalid direction.  Return the InvalidDirection snake status.  If the next node has part of the snake body, return that there was a collision.  </span></p><p><span>If none of the above are true, then the snake can move forward into the next node.  To do this, make the next node to be the snake head, the current head to be part of the snake body, and link the edge of the current head to the next node.  If the data in the node where the snake is moving to contains the food, add a new piece of food to the board and return that the snake is eating. Note that if the game is won (the snake fills the entire grid), then no food should be added and a Win status should be returned.</span></p><p><span>If the snake is not eating and it did not collide with something, then we need to determine if we need to cut the snake’s tail.  If we do not do this, the snake will continuously grow even if it is not eating.  If the head of the snake is not the tail of the snake, set the tail node data to be empty (if the head is the tail, we let the snake grow…this is a special case for the start of the game).  Then, the edge of the tail should be set to null and the value of the edge should become the new tail.  This process can be done with a temporary variable.  In the method above, no new game nodes should be created.  </span></p></li></ul></li><li><p><code>public List&lt;GameNode&gt; GetSnakePath()</code></p><ul><li><span>This method returns a list of game nodes that contain the snake starting from the tail.</span></li></ul></li><li><p><code>private List&lt;Direction&gt; BuildPath(Dictionary&lt;GameNode, (GameNode, Direction)&gt; path, GameNode dest)</code></p><ul><li><span>This method reverses the given path from the destination to the head of the snake.  The resulting list is a series of directions that leads the head of the snake to </span><code>dest</code><span>.  This method works similarly to the </span><strong><span>AddPath</span></strong><span> method in </span><a href='https://classroom.github.com/a/WmDXPqFk'><span>Lab 33</span></a><span>.  The given path dictionary&#39;s keys represent the destination and the corresponding value is a tuple which has the source node and the direction required to go to get to the destination.</span></li></ul></li><li><p><code>public List&lt;Direction&gt; FindShortestAiPath(GameNode dest)</code></p><ul><li><span>This method calculates the shortest path from the head of the snake to the destination.  This method works similarly to the shortest path algorithm in </span><a href='https://classroom.github.com/a/tRS1oXkz'><span>Lab34</span></a><span>.  The path should be kept in a dictionary as described in the previous method.  The queue should contain a 3-value tuple which contains the source node, destination node, and the direction required to get from the source to the destination.  This tuple represents an edge between two adjacent nodes. A helper method is recommended here to find the adjacent edges from a given source node.  Note that only valid adjacent nodes should be included as a valid edge (i.e. parts of the snake should not be included, unless the destination of the shortest path is the tail, then the tail can be included).  The snake is not allowed to path back over itself to reach its destination. Once the destination is found, rebuild and return the path using the </span><code>BuildPath</code><span> method.</span></li></ul></li><li><p><code>public List&lt;Direction&gt; FindLongestAiPath()</code></p><ul><li><span>This method is used to find the Hamiltonian path as described in the &quot;The Perfect Snake AI&quot; sections.  Utilize the </span><code>FindShortestAiPath</code><span> to find a path to the tail of the snake.  Then use the process previously described to extend this path.  You will need to keep track of which nodes you have visited (be sure to mark all in the shortest path to be visited before you start extending it). You will need to keep track of which node you are currently at and which direction in the path you are currently at (and which node that leads to).  If the current direction you are at in the path is up or down, try to extend the path left or right (up or down if the direction in the path is left or right).  If you can extend the current node and the next node (the node the current direction leads to) in either of the extension directions, then insert the direction and its opposite into the path (at the current location in the path and current location + 2 respectively).  Note that you cannot extend to a location that has already been visited.   If the path cannot be extended at its current location, advance to the next node, otherwise, keep trying to extend the current node. Once you have reached the end of the path (this should  be the tail), link the path to the rest of the snake.  Finally, load the path into a queue before returning it.</span></li></ul></li></ul><h2><a name="the-game-class" class="md-header-anchor"></a><span>The Game Class</span></h2><p><span>The game class is the communication between the UI and the game logic.  It will maintain the status of the game and manage moving the snake based off the key presses given by the UI.  This class implements the </span><strong><span>INotifyPropertyChanged</span></strong><span> interface.  </span></p><h3><a name="fields-n193" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _score</code></p><ul><li><span>Keeps track of how many points the player has.</span></li></ul></li><li><p><code>private int _delay</code></p><ul><li><span>Indicates how many milliseconds the game should wait before ticks (controls how fast the snake moves)</span></li></ul></li><li><p><code>private bool _isAI</code></p><ul><li><span>Indicates if the game should be controlled by the AI</span></li></ul></li><li><p><code>private Queue&lt;Direction&gt; _aiPath</code></p><ul><li><span>This will store the AI path, if the AI is enabled.</span></li></ul></li></ul><h3><a name="properties-n215" class="md-header-anchor"></a><span>Properties</span></h3><ul><li><p><code>public bool Play</code></p><ul><li><span>Stores whether or not the game is currently being played (i.e. the game is not over)</span></li></ul></li><li><p><code>public int Score</code></p><ul><li><p><span>This is a public property that has a get accessor that returns the private score field.  The set accessor is a bit unique.  This is the first step in implementing data binding.</span></p><p><img src="clip_image008.png" referrerpolicy="no-referrer" alt="Basic data binding diagram"></p><p><span>Data binding works by linking a data source (the Binding Source) of some kind to another object (the Binding Target).  This is done in C# between a data source and a UI control.  In data binding, when the source property changes, the target is notified of this change.  This is extremely useful in the sense that we do not have to update a UI control manually.  This will take care of it for us.  In the set accessor, check if the private score field is different from the new value given to the property.  If it is, set the private score field to the value and then call </span><strong><span>OnPropertyChanged</span></strong><span>, passing in the name of the property that changed as a string (“Score”).  This signals an event (see below for definition) that will trigger the data binding process. </span></p></li></ul></li><li><p><code>public GameBoard Board</code></p><ul><li><span>The reference to the game board object that contains the logic for moving the snake on the graph. The property has default get and private set accessors.</span></li></ul></li><li><p><code>public int Size</code></p><ul><li><span>The size of the game to create. The property has default get and a private set accessors.</span></li></ul></li><li><p><code>public Direction LastDirection</code></p><ul><li><span>The last direction that the snake successfully moved. The property has default get and set accessors.</span></li></ul></li><li><p><code>public Direction KeyPress</code></p><ul><li><span>The most recent direction reported by the UI. The property has default get and private set accessors.</span></li></ul></li><li><p><code>public SnakeStatus Status</code></p><ul><li><span>The current status of the snake. The property has default get and private set accessors.</span></li></ul></li><li><p><code>public event PropertyChangedEventHandler PropertyChanged;</code></p><ul><li><span>This is needed as part of implementing the above-mentioned interface.  The above line can be inserted verbatim into your code.</span></li></ul></li></ul><h3><a name="methods-n259" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public Game(int size, int speed, bool isAI)</code></p><ul><li><span>The constructor for the Game class.  Sets the size, initializes the game board, score to 2, and Play to true. Once the board is initialized, the snake should be moved up one (use </span><code>MoveSnake</code><span>).  The constructor should also set the </span><code>_delay</code><span> based off the given speed.  If the AI is enabled, set </span><code>_aiPath</code><span> to the result of the </span><code>FindAiPath</code><span> method from the GameBoard class.</span></li></ul></li><li><p><code>public async Task StartMoving(IProgress&lt;SnakeStatus&gt; progress, CancellationToken cancelToken)</code></p><ul><li><span>This is an asynchronous method that acts as a game clock.  The snake in the game is always moving, the user (or AI) only controls the direction.  Therefore, every game “tick” we need to move the snake.  Since this is asynchronous, it will not block the UI completely.  This method contains a loop that continues until Play is false or a cancelation request has been made from the UI (</span><code>cancelToken.IsCancellationRequested</code><span>).  Inside the loop, you will tell the game board (</span><strong><span>Board</span></strong><span>) to move the snake in the direction of </span><strong><span>KeyPress</span></strong><span>.  Then you will report the new status back to the UI using the progress interface passed to this method.  This can be done using </span><code>progress.Report(Status)</code><span>  If the snake collided with something, </span><strong><span>Play</span></strong><span> should be set to false.  If the snake is still moving, the last direction should be set to the key press.  If the snake is eating, increase the score (be sure to use the property here so it triggers the data binding events).  If the snake reported an invalid direction, try to move the snake in the last direction (be sure to check for collisions and eating here as well.  If a win status is reported, still increase the score by 1, but set Play to false.  Lastly, at the end of the loop, use the following code to control how often a tick occurs:  </span><code>await Task.Delay(_delay)</code><span>.</span></li><li><span>To add the AI control, add a check at the beginning of the loop to see if the AI is enabled, if so, override the </span><code>KeyPress</code><span> value with the next direction in the path queue.  Once the move has been made, add this direction back to the queue.</span></li></ul></li><li><p><code>private void OnPropertyChanged(string propertyName)</code></p><ul><li><p><span>This is what will call the property changed event with the appropriate property.  This method should contain only the following code:</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 31px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 27px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>1</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -27px; width: 27px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -27px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 18px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">PropertyChanged</span><span class="cm-operator">?</span>.<span class="cm-variable">Invoke</span>(<span class="cm-keyword">this</span>, <span class="cm-keyword">new</span> <span class="cm-variable">PropertyChangedEventArgs</span>(<span class="cm-variable">propertyName</span>));</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="height: 26px; left: 0px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 26px;"></div></div></div></div></pre><p><span>This is checking if the </span><code>PropertyChanged</code><span> is null.  If not, it will call the property changed event for the given property in context of “this”.</span></p></li></ul></li><li><p><code>public List&lt;GameNode&gt; GetSnakePath()</code></p><ul><li><span>This method returns the result of the GetSnakePath method contained in the GameBoard class.</span></li></ul></li><li><p><code>public GameNode GetFood()</code></p><ul><li><span>Returns the Food property of the game board.  If the Food property doesn&#39;t actually contain food, return null (this happens when the game is won and the snake fills the entire board).</span></li></ul></li><li><p><code>public void MoveUp()</code></p><ul><li><span>Sets the key press field to be the up direction.</span></li></ul></li><li><p><code>public void MoveDown()</code></p><ul><li><span>Sets the key press field to be the down direction.</span></li></ul></li><li><p><code>public void MoveLeft()</code></p><ul><li><span>Sets the key press field to be the left direction.</span></li></ul></li><li><p><code>public void MoveRight()</code></p><ul><li><span>Sets the key press field to be the right direction.</span></li></ul></li></ul><h2><a name="the-userinterface-class" class="md-header-anchor"></a><span>The UserInterface Class</span></h2><p><span>The user interface class is responsible for handling the event where a key is down as well as drawing the snake and other game data on the screen.</span></p><h3><a name="fields-n312" class="md-header-anchor"></a><span>Fields</span></h3><ul><li><p><code>private int _squareWidth</code></p><ul><li><span>This is the calculated size of a game square (a node on the graph).</span></li></ul></li><li><p><code>private int _size</code></p><ul><li><span>The width and height of the game in number of nodes/game squares.</span></li></ul></li><li><p><code>private Game _game</code></p><ul><li><span>The game object.  This gives the UI access to informing the game when the user has changed directions, as well as letting the game inform the UI of the score and where the snake is.</span></li></ul></li><li><p><code>private SolidBrush _bodyBrush</code></p><ul><li><span>This field is initialized to a new </span><strong><span>SolidBrush</span></strong><span>, passing a Color of your choice as a parameter.  This will be used to give the snake color. </span></li></ul></li><li><p><code>private SolidBrush _foodBrush</code></p><ul><li><span>Same as above, but used to color the food.</span></li></ul></li><li><p><code>private Pen _pen</code></p><ul><li><span>This is what gives each snake square an outline.  Initialize it to a new pen with a color of your choice and a width of 2.</span></li></ul></li><li><p><code>private CancellationTokenSource _cancelSource</code></p><ul><li><span>This field will allow the </span><strong><span>UserInterface</span></strong><span> to cancel or stop the </span><code>async StartMoving</code><span> method in the Game class.  Without this, if a new game is started before the previous one ends, the thread that was running the previous game will continue to run in the background. This field should be initialized to a new </span><code>CancellationTokenSource</code></li></ul></li></ul><h3><a name="methods-n349" class="md-header-anchor"></a><span>Methods</span></h3><ul><li><p><code>public UserInterface()</code></p><ul><li><span>This is the default constructor for the interface.  No changes are needed.</span></li></ul></li><li><p><code>private void NewGame(int size, int speed)</code></p><ul><li><p><span>This creates a new game with the given size and speed.  This also sets the width and height of the picture box in the UI to 600.  You can change this size, but this seems to be a good balance on a standard resolution monitor.  You will also need to change the Size property of this (the form) to be a new size taking into account the picture box and the menu strip.  The square width should be calculated to be the picture box width divided by the size.  You also need to setup the databinding to the score label.  This can be done by clearing the </span><code>DataBindings</code><span> property of the score label control, then calling Add on the same property to add a new Binding.  The parameters you pass when creating the new Binding object should be “Text” (this is the property of the label you are binding to), the </span><strong><span>_game</span></strong><span> field (the object that has your data), and “Score”, the name of the property in the data which will be your source.  Then you need to create a new progress object (you may use the code below).  Before you tell the game to start moving, set the </span><code>_cancelSource</code><span> to a new instance, then call the </span><code>StartMoving</code><span> method, passing the progress object and </span><code>_cancelSource.Token</code><span>.  This token allows the UI to communicate to the </span><code>StartMoving</code><span> method when a new game is created.  Note that Visual Studio will try to suggest that you should add the </span><code>await</code><span> keyword to the call to </span><code>StartMoving</code><span>, do </span><strong><span>not</span></strong><span> do this.  That would cause the UI to not refresh/animate the snake.</span></p></li><li><p><span>Be sure to add </span><code>_cancelSource.Cancel();</code><span> at the beginning of the this method (</span><strong><span>NewGame</span></strong><span>) so that any previous games are completely stopped before a new one is started.</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 39px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 35px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>17</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -35px; width: 35px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 26px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//this line of code goes inside the NewGame method</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">progress</span>.<span class="cm-variable">ProgressChanged</span> <span class="cm-operator">+=</span> <span class="cm-keyword">new</span> <span class="cm-variable">EventHandler</span><span class="cm-operator">&lt;</span><span class="cm-variable">SnakeStatus</span><span class="cm-operator">&gt;</span>(<span class="cm-variable">CheckProgress</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//this method goes outside of the NewGame method</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">5</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">private</span> <span class="cm-keyword">void</span> <span class="cm-variable">CheckProgress</span>(<span class="cm-variable-3">object</span> <span class="cm-variable">sender</span>, <span class="cm-variable">SnakeStatus</span> <span class="cm-variable">status</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">6</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">7</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">//Note that the Refresh call invalidates the state of the controls, forcing them to be redrawn.</span></span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">8</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">Refresh</span>();</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">9</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">status</span> <span class="cm-operator">==</span> <span class="cm-variable">SnakeStatus</span>.<span class="cm-variable">Collision</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 26px;">10</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">11</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">MessageBox</span>.<span class="cm-variable">Show</span>(<span class="cm-string">"Game over!"</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">12</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">13</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable">status</span> <span class="cm-operator">==</span> <span class="cm-variable">SnakeStatus</span>.<span class="cm-variable">Win</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">14</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">15</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">MessageBox</span>.<span class="cm-variable">Show</span>(<span class="cm-string">"Game Completed!"</span>);</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 26px;">16</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -35px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 26px;">17</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 468px;"></div><div class="CodeMirror-gutters" style="height: 468px; left: 0px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 34px;"></div></div></div></div></pre></li></ul></li><li><p><code>private void uxPictureBox_Paint(object sender, PaintEventArgs e)</code></p><ul><li><span>This is an event handler that will draw all of the game graphics.  Be sure to assign this as the Paint event handler in the UI designer window for your picture box.  It is pretty straight forward to draw graphics is C#.  In this method, get the graphics object into a local Graphics variable.  The graphics object that belongs this control is contained the arguments (</span><code>e.Graphics</code><span>).  Then get the snake path through the game class.  For each of the game nodes in the snake path, we will create a new rectangle.  This rectangle is located at the coordinates of the node times the square width.  The width and height of the rectangle is the square width field.  Then to draw the rectangle, call the </span><strong><span>FillRectangle</span></strong><span> method of the graphics object, passing in the body brush and the rectangle as parameters.  Then we draw the outline, using the </span><strong><span>DrawRectangle</span></strong><span> method of the graphics object, passing in the pen and rectangle as parameters.  Finally, after the snake is drawn, we need to draw the food.  Get the food node through the game class and draw it just like the snake, but use </span><strong><span>FillEllipse</span></strong><span> instead.  This will draw it as a circle. </span><em><span>(Note that if the food is null, it should not be drawn)</span></em></li></ul></li><li><p><code>private void UserInterface_KeyDown(object sender, KeyEventArgs e)</code></p><ul><li><span>This is a </span><strong><span>KeyDown</span></strong><span> event handler which should be hooked to your Form control AND your AI CheckBox in your UI designer window (</span><em><span>Note that this is because the CheckBox can receive focus and can block the Form from triggering the event otherwise</span></em><span>).  If the game is still active, it will call the correct move function through the game class.  You can get what key was pressed by using </span><code>e.KeyCode</code><span> and compare that to </span><code>Keys.Up</code><span> etc..  After the key press was sent on, the picture box needs to be redrawn.  This can be triggered by using uxPictureBox.Refresh();</span></li></ul></li><li><p><span>Add three click event handlers corresponding to the New Game -&gt; Easy, Normal, and Hard menu items.  Each should create a </span><code>NewGame</code><span> with the following parameters:</span></p><ul><li><span>Easy: size 10 and speed 250</span></li><li><span>Normal: size 20 and speed 150</span></li><li><span>Hard: size 30 and speed 100</span></li></ul><p><strong><span>Note: If the AI is enabled, the speed should be the value in the NumericUpDown control.</span></strong></p></li><li><p><span>Finally, add the following event handler, hooking it as a </span><strong><span>PreviewKeyDown</span></strong><span> event handler for both the </span><strong><span>Form</span></strong><span> control AND the </span><strong><span>CheckBox</span></strong><span>.  This enables the use of the arrow keys, otherwise they will not trigger the </span><strong><span>KeyDown</span></strong><span> event.</span></p><pre spellcheck="false" class="md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded" lang="c#"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="c#"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 31px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 27px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre><div class="CodeMirror-linenumber CodeMirror-gutter-elt"><div>4</div></div></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: -27px; width: 27px;"></div><div class="CodeMirror-gutter-wrapper CodeMirror-activeline-gutter" style="left: -27px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 18px;">1</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">private</span> <span class="cm-keyword">void</span> <span class="cm-variable">UserInterface_PreviewKeyDown</span>(<span class="cm-variable-3">object</span> <span class="cm-variable">sender</span>, <span class="cm-variable">PreviewKeyDownEventArgs</span> <span class="cm-variable">e</span>)</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -27px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 18px;">2</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -27px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt" style="left: 0px; width: 18px;">3</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">e</span>.<span class="cm-variable">IsInputKey</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;</span></pre></div><div style="position: relative;"><div class="CodeMirror-gutter-wrapper" style="left: -27px;"><div class="CodeMirror-linenumber CodeMirror-gutter-elt CodeMirror-linenumber-show" style="left: 0px; width: 18px;">4</div></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 104px;"></div><div class="CodeMirror-gutters" style="height: 104px; left: 0px;"><div class="CodeMirror-gutter CodeMirror-linenumbers" style="width: 26px;"></div></div></div></div></pre></li></ul><h1><a name="testing-and-performance" class="md-header-anchor"></a><span>Testing and Performance</span></h1><p><span>Unit tests are provided to test </span><em><span>basic</span></em><span> functionality but they do not test UI elements, async elements, or keyboard interactions directly.  These will need to be tested manually.  The graphics should be redrawn smoothly with nearly no interruption to the user control (which should never be locked up). The game should work without bugs or crashes and follow game rules.  The AI should not cause any delays and should win the game every time. </span></p><h1><a name="submitting-your-assignment" class="md-header-anchor"></a><span>Submitting Your Assignment</span></h1><p><span>Be sure to </span><strong><span>refresh</span></strong><span> your Team Explorer, </span><strong><span>commit</span></strong><span> all your changes, then </span><strong><span>push</span></strong><span> your commits to your GitHub repository. Then submit the </span><em><span>entire URL</span></em><span> of the commit that you want graded.</span></p><p><strong><span>Important:</span></strong><span> If the URL you submit does not contain the 40-hex-digit fingerprint of the commit you want graded, </span><strong><span>you will receive a 0</span></strong><span>, as this fingerprint is the only way we can verify that you completed your code prior to submitting your assignment. We will only grade the source code that is included in the commit that you submit. </span></p></div>
</body>
</html>